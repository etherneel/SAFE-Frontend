"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/secp256k1";
exports.ids = ["vendor-chunks/secp256k1"];
exports.modules = {

/***/ "(ssr)/./node_modules/secp256k1/bindings.js":
/*!********************************************!*\
  !*** ./node_modules/secp256k1/bindings.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst addon = __webpack_require__(/*! node-gyp-build */ \"(ssr)/./node_modules/node-gyp-build/index.js\")(__dirname);\nmodule.exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/secp256k1/lib/index.js\")(new addon.Secp256k1());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2JpbmRpbmdzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQyxzRUFBa0JDO0FBQ3hDQyxPQUFPQyxPQUFPLEdBQUdILG1CQUFPQSxDQUFDLDREQUFTLElBQUlELE1BQU1LLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvYmluZGluZ3MuanM/ZDgzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhZGRvbiA9IHJlcXVpcmUoJ25vZGUtZ3lwLWJ1aWxkJykoX19kaXJuYW1lKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpKG5ldyBhZGRvbi5TZWNwMjU2azEoKSlcbiJdLCJuYW1lcyI6WyJhZGRvbiIsInJlcXVpcmUiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiLCJleHBvcnRzIiwiU2VjcDI1NmsxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/secp256k1/bindings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/secp256k1/elliptic.js":
/*!********************************************!*\
  !*** ./node_modules/secp256k1/elliptic.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/secp256k1/lib/index.js\")(__webpack_require__(/*! ./lib/elliptic */ \"(ssr)/./node_modules/secp256k1/lib/elliptic.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2VsbGlwdGljLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHQyxtQkFBT0EsQ0FBQyw0REFBU0EsbUJBQU9BLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvZWxsaXB0aWMuanM/NDRhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/secp256k1/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/secp256k1/index.js":
/*!*****************************************!*\
  !*** ./node_modules/secp256k1/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\ntry {\n    module.exports = __webpack_require__(/*! ./bindings */ \"(ssr)/./node_modules/secp256k1/bindings.js\");\n} catch (err) {\n    module.exports = __webpack_require__(/*! ./elliptic */ \"(ssr)/./node_modules/secp256k1/elliptic.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJO0lBQ0ZBLG9HQUF5QjtBQUMzQixFQUFFLE9BQU9HLEtBQUs7SUFDWkgsb0dBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2luZGV4LmpzP2MwMzMiXSwic291cmNlc0NvbnRlbnQiOlsidHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JpbmRpbmdzJylcbn0gY2F0Y2ggKGVycikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMnKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/secp256k1/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/secp256k1/lib/elliptic.js":
/*!************************************************!*\
  !*** ./node_modules/secp256k1/lib/elliptic.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\").ec);\nconst ec = new EC(\"secp256k1\");\nconst ecparams = ec.curve;\n// Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\nconst BN = ecparams.n.constructor;\nfunction loadCompressedPublicKey(first, xbuf) {\n    let x = new BN(xbuf);\n    // overflow\n    if (x.cmp(ecparams.p) >= 0) return null;\n    x = x.toRed(ecparams.red);\n    // compute corresponding Y\n    let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();\n    if (first === 0x03 !== y.isOdd()) y = y.redNeg();\n    return ec.keyPair({\n        pub: {\n            x: x,\n            y: y\n        }\n    });\n}\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n    let x = new BN(xbuf);\n    let y = new BN(ybuf);\n    // overflow\n    if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;\n    x = x.toRed(ecparams.red);\n    y = y.toRed(ecparams.red);\n    // is odd flag\n    if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null;\n    // x*x*x + b = y*y\n    const x3 = x.redSqr().redIMul(x);\n    if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;\n    return ec.keyPair({\n        pub: {\n            x: x,\n            y: y\n        }\n    });\n}\nfunction loadPublicKey(pubkey) {\n    // length should be validated in interface\n    const first = pubkey[0];\n    switch(first){\n        case 0x02:\n        case 0x03:\n            if (pubkey.length !== 33) return null;\n            return loadCompressedPublicKey(first, pubkey.subarray(1, 33));\n        case 0x04:\n        case 0x06:\n        case 0x07:\n            if (pubkey.length !== 65) return null;\n            return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));\n        default:\n            return null;\n    }\n}\nfunction savePublicKey(output, point) {\n    const pubkey = point.encode(null, output.length === 33);\n    // Loop should be faster because we do not need create extra Uint8Array\n    // output.set(new Uint8Array(pubkey))\n    for(let i = 0; i < output.length; ++i)output[i] = pubkey[i];\n}\nmodule.exports = {\n    contextRandomize () {\n        return 0;\n    },\n    privateKeyVerify (seckey) {\n        const bn = new BN(seckey);\n        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;\n    },\n    privateKeyNegate (seckey) {\n        const bn = new BN(seckey);\n        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, \"be\", 32);\n        seckey.set(negate);\n        return 0;\n    },\n    privateKeyTweakAdd (seckey, tweak) {\n        const bn = new BN(tweak);\n        if (bn.cmp(ecparams.n) >= 0) return 1;\n        bn.iadd(new BN(seckey));\n        if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);\n        if (bn.isZero()) return 1;\n        const tweaked = bn.toArrayLike(Uint8Array, \"be\", 32);\n        seckey.set(tweaked);\n        return 0;\n    },\n    privateKeyTweakMul (seckey, tweak) {\n        let bn = new BN(tweak);\n        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n        bn.imul(new BN(seckey));\n        if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);\n        const tweaked = bn.toArrayLike(Uint8Array, \"be\", 32);\n        seckey.set(tweaked);\n        return 0;\n    },\n    publicKeyVerify (pubkey) {\n        const pair = loadPublicKey(pubkey);\n        return pair === null ? 1 : 0;\n    },\n    publicKeyCreate (output, seckey) {\n        const bn = new BN(seckey);\n        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n        const point = ec.keyFromPrivate(seckey).getPublic();\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyConvert (output, pubkey) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        const point = pair.getPublic();\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyNegate (output, pubkey) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        const point = pair.getPublic();\n        point.y = point.y.redNeg();\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyCombine (output, pubkeys) {\n        const pairs = new Array(pubkeys.length);\n        for(let i = 0; i < pubkeys.length; ++i){\n            pairs[i] = loadPublicKey(pubkeys[i]);\n            if (pairs[i] === null) return 1;\n        }\n        let point = pairs[0].getPublic();\n        for(let i = 1; i < pairs.length; ++i)point = point.add(pairs[i].pub);\n        if (point.isInfinity()) return 2;\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyTweakAdd (output, pubkey, tweak) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        tweak = new BN(tweak);\n        if (tweak.cmp(ecparams.n) >= 0) return 2;\n        const point = pair.getPublic().add(ecparams.g.mul(tweak));\n        if (point.isInfinity()) return 2;\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyTweakMul (output, pubkey, tweak) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        tweak = new BN(tweak);\n        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;\n        const point = pair.getPublic().mul(tweak);\n        savePublicKey(output, point);\n        return 0;\n    },\n    signatureNormalize (sig) {\n        const r = new BN(sig.subarray(0, 32));\n        const s = new BN(sig.subarray(32, 64));\n        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;\n        if (s.cmp(ec.nh) === 1) {\n            sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, \"be\", 32), 32);\n        }\n        return 0;\n    },\n    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n    // Adapted for Uint8Array instead Buffer\n    signatureExport (obj, sig) {\n        const sigR = sig.subarray(0, 32);\n        const sigS = sig.subarray(32, 64);\n        if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;\n        if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;\n        const { output } = obj;\n        // Prepare R\n        let r = output.subarray(4, 4 + 33);\n        r[0] = 0x00;\n        r.set(sigR, 1);\n        let lenR = 33;\n        let posR = 0;\n        for(; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);\n        r = r.subarray(posR);\n        if (r[0] & 0x80) return 1;\n        if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1;\n        // Prepare S\n        let s = output.subarray(6 + 33, 6 + 33 + 33);\n        s[0] = 0x00;\n        s.set(sigS, 1);\n        let lenS = 33;\n        let posS = 0;\n        for(; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);\n        s = s.subarray(posS);\n        if (s[0] & 0x80) return 1;\n        if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1;\n        // Set output length for return\n        obj.outputlen = 6 + lenR + lenS;\n        // Output in specified format\n        // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n        output[0] = 0x30;\n        output[1] = obj.outputlen - 2;\n        output[2] = 0x02;\n        output[3] = r.length;\n        output.set(r, 4);\n        output[4 + lenR] = 0x02;\n        output[5 + lenR] = s.length;\n        output.set(s, 6 + lenR);\n        return 0;\n    },\n    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n    // Adapted for Uint8Array instead Buffer\n    signatureImport (output, sig) {\n        if (sig.length < 8) return 1;\n        if (sig.length > 72) return 1;\n        if (sig[0] !== 0x30) return 1;\n        if (sig[1] !== sig.length - 2) return 1;\n        if (sig[2] !== 0x02) return 1;\n        const lenR = sig[3];\n        if (lenR === 0) return 1;\n        if (5 + lenR >= sig.length) return 1;\n        if (sig[4 + lenR] !== 0x02) return 1;\n        const lenS = sig[5 + lenR];\n        if (lenS === 0) return 1;\n        if (6 + lenR + lenS !== sig.length) return 1;\n        if (sig[4] & 0x80) return 1;\n        if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;\n        if (sig[lenR + 6] & 0x80) return 1;\n        if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;\n        let sigR = sig.subarray(4, 4 + lenR);\n        if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);\n        if (sigR.length > 32) return 1;\n        let sigS = sig.subarray(6 + lenR);\n        if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);\n        if (sigS.length > 32) throw new Error(\"S length is too long\");\n        let r = new BN(sigR);\n        if (r.cmp(ecparams.n) >= 0) r = new BN(0);\n        let s = new BN(sig.subarray(6 + lenR));\n        if (s.cmp(ecparams.n) >= 0) s = new BN(0);\n        output.set(r.toArrayLike(Uint8Array, \"be\", 32), 0);\n        output.set(s.toArrayLike(Uint8Array, \"be\", 32), 32);\n        return 0;\n    },\n    ecdsaSign (obj, message, seckey, data, noncefn) {\n        if (noncefn) {\n            const _noncefn = noncefn;\n            noncefn = (counter)=>{\n                const nonce = _noncefn(message, seckey, null, data, counter);\n                const isValid = nonce instanceof Uint8Array && nonce.length === 32;\n                if (!isValid) throw new Error(\"This is the way\");\n                return new BN(nonce);\n            };\n        }\n        const d = new BN(seckey);\n        if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;\n        let sig;\n        try {\n            sig = ec.sign(message, seckey, {\n                canonical: true,\n                k: noncefn,\n                pers: data\n            });\n        } catch (err) {\n            return 1;\n        }\n        obj.signature.set(sig.r.toArrayLike(Uint8Array, \"be\", 32), 0);\n        obj.signature.set(sig.s.toArrayLike(Uint8Array, \"be\", 32), 32);\n        obj.recid = sig.recoveryParam;\n        return 0;\n    },\n    ecdsaVerify (sig, msg32, pubkey) {\n        const sigObj = {\n            r: sig.subarray(0, 32),\n            s: sig.subarray(32, 64)\n        };\n        const sigr = new BN(sigObj.r);\n        const sigs = new BN(sigObj.s);\n        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 2;\n        const point = pair.getPublic();\n        const isValid = ec.verify(msg32, sigObj, point);\n        return isValid ? 0 : 3;\n    },\n    ecdsaRecover (output, sig, recid, msg32) {\n        const sigObj = {\n            r: sig.slice(0, 32),\n            s: sig.slice(32, 64)\n        };\n        const sigr = new BN(sigObj.r);\n        const sigs = new BN(sigObj.s);\n        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n        if (sigr.isZero() || sigs.isZero()) return 2;\n        // Can throw `throw new Error('Unable to find sencond key candinate');`\n        let point;\n        try {\n            point = ec.recoverPubKey(msg32, sigObj, recid);\n        } catch (err) {\n            return 2;\n        }\n        savePublicKey(output, point);\n        return 0;\n    },\n    ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        const scalar = new BN(seckey);\n        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;\n        const point = pair.getPublic().mul(scalar);\n        if (hashfn === undefined) {\n            const data = point.encode(null, true);\n            const sha256 = ec.hash().update(data).digest();\n            for(let i = 0; i < 32; ++i)output[i] = sha256[i];\n        } else {\n            if (!xbuf) xbuf = new Uint8Array(32);\n            const x = point.getX().toArray(\"be\", 32);\n            for(let i = 0; i < 32; ++i)xbuf[i] = x[i];\n            if (!ybuf) ybuf = new Uint8Array(32);\n            const y = point.getY().toArray(\"be\", 32);\n            for(let i = 0; i < 32; ++i)ybuf[i] = y[i];\n            const hash = hashfn(xbuf, ybuf, data);\n            const isValid = hash instanceof Uint8Array && hash.length === output.length;\n            if (!isValid) return 2;\n            output.set(hash);\n        }\n        return 0;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9lbGxpcHRpYy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsS0FBS0MseUZBQXNCO0FBRWpDLE1BQU1DLEtBQUssSUFBSUYsR0FBRztBQUNsQixNQUFNRyxXQUFXRCxHQUFHRSxLQUFLO0FBRXpCLDREQUE0RDtBQUM1RCw0RUFBNEU7QUFDNUUsTUFBTUMsS0FBS0YsU0FBU0csQ0FBQyxDQUFDQyxXQUFXO0FBRWpDLFNBQVNDLHdCQUF5QkMsS0FBSyxFQUFFQyxJQUFJO0lBQzNDLElBQUlDLElBQUksSUFBSU4sR0FBR0s7SUFFZixXQUFXO0lBQ1gsSUFBSUMsRUFBRUMsR0FBRyxDQUFDVCxTQUFTVSxDQUFDLEtBQUssR0FBRyxPQUFPO0lBQ25DRixJQUFJQSxFQUFFRyxLQUFLLENBQUNYLFNBQVNZLEdBQUc7SUFFeEIsMEJBQTBCO0lBQzFCLElBQUlDLElBQUlMLEVBQUVNLE1BQU0sR0FBR0MsT0FBTyxDQUFDUCxHQUFHUSxPQUFPLENBQUNoQixTQUFTaUIsQ0FBQyxFQUFFQyxPQUFPO0lBQ3pELElBQUksVUFBVyxTQUFVTCxFQUFFTSxLQUFLLElBQUlOLElBQUlBLEVBQUVPLE1BQU07SUFFaEQsT0FBT3JCLEdBQUdzQixPQUFPLENBQUM7UUFBRUMsS0FBSztZQUFFZCxHQUFHQTtZQUFHSyxHQUFHQTtRQUFFO0lBQUU7QUFDMUM7QUFFQSxTQUFTVSwwQkFBMkJqQixLQUFLLEVBQUVDLElBQUksRUFBRWlCLElBQUk7SUFDbkQsSUFBSWhCLElBQUksSUFBSU4sR0FBR0s7SUFDZixJQUFJTSxJQUFJLElBQUlYLEdBQUdzQjtJQUVmLFdBQVc7SUFDWCxJQUFJaEIsRUFBRUMsR0FBRyxDQUFDVCxTQUFTVSxDQUFDLEtBQUssS0FBS0csRUFBRUosR0FBRyxDQUFDVCxTQUFTVSxDQUFDLEtBQUssR0FBRyxPQUFPO0lBRTdERixJQUFJQSxFQUFFRyxLQUFLLENBQUNYLFNBQVNZLEdBQUc7SUFDeEJDLElBQUlB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bkMsSUFBSXFCLE1BQU00RixJQUFJLEdBQUdELE9BQU8sQ0FBQyxNQUFNO1lBQ3JDLElBQUssSUFBSXpGLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQUVBLEVBQUdaLElBQUksQ0FBQ1ksRUFBRSxHQUFHdkIsQ0FBQyxDQUFDdUIsRUFBRTtZQUUzQyxNQUFNcUYsT0FBT0osT0FBTzlHLE1BQU1pQixNQUFNcUU7WUFFaEMsTUFBTUssVUFBVXVCLGdCQUFnQnpFLGNBQWN5RSxLQUFLM0YsTUFBTSxLQUFLRyxPQUFPSCxNQUFNO1lBQzNFLElBQUksQ0FBQ29FLFNBQVMsT0FBTztZQUVyQmpFLE9BQU9nQixHQUFHLENBQUN3RTtRQUNiO1FBRUEsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2VsbGlwdGljLmpzPzc0NDEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG5cbmNvbnN0IGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKVxuY29uc3QgZWNwYXJhbXMgPSBlYy5jdXJ2ZVxuXG4vLyBIYWNrLCB3ZSBjYW4gbm90IHVzZSBibi5qc0A1LCB3aGlsZSBlbGxpcHRpYyB1c2VzIGJuLmpzQDRcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9pc3N1ZXMvMTkxI2lzc3VlY29tbWVudC01Njk4ODg3NThcbmNvbnN0IEJOID0gZWNwYXJhbXMubi5jb25zdHJ1Y3RvclxuXG5mdW5jdGlvbiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhidWYpIHtcbiAgbGV0IHggPSBuZXcgQk4oeGJ1ZilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGNvbXB1dGUgY29ycmVzcG9uZGluZyBZXG4gIGxldCB5ID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpLnJlZElBZGQoZWNwYXJhbXMuYikucmVkU3FydCgpXG4gIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpIHkgPSB5LnJlZE5lZygpXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4YnVmLCB5YnVmKSB7XG4gIGxldCB4ID0gbmV3IEJOKHhidWYpXG4gIGxldCB5ID0gbmV3IEJOKHlidWYpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDAgfHwgeS5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcblxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG4gIHkgPSB5LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBpcyBvZGQgZmxhZ1xuICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5LmlzT2RkKCkgIT09IChmaXJzdCA9PT0gMHgwNykpIHJldHVybiBudWxsXG5cbiAgLy8geCp4KnggKyBiID0geSp5XG4gIGNvbnN0IHgzID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpXG4gIGlmICgheS5yZWRTcXIoKS5yZWRJU3ViKHgzLnJlZElBZGQoZWNwYXJhbXMuYikpLmlzWmVybygpKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkUHVibGljS2V5IChwdWJrZXkpIHtcbiAgLy8gbGVuZ3RoIHNob3VsZCBiZSB2YWxpZGF0ZWQgaW4gaW50ZXJmYWNlXG4gIGNvbnN0IGZpcnN0ID0gcHVia2V5WzBdXG4gIHN3aXRjaCAoZmlyc3QpIHtcbiAgICBjYXNlIDB4MDI6XG4gICAgY2FzZSAweDAzOlxuICAgICAgaWYgKHB1YmtleS5sZW5ndGggIT09IDMzKSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpKVxuICAgIGNhc2UgMHgwNDpcbiAgICBjYXNlIDB4MDY6XG4gICAgY2FzZSAweDA3OlxuICAgICAgaWYgKHB1YmtleS5sZW5ndGggIT09IDY1KSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIGxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmtleS5zdWJhcnJheSgxLCAzMyksIHB1YmtleS5zdWJhcnJheSgzMywgNjUpKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVQdWJsaWNLZXkgKG91dHB1dCwgcG9pbnQpIHtcbiAgY29uc3QgcHVia2V5ID0gcG9pbnQuZW5jb2RlKG51bGwsIG91dHB1dC5sZW5ndGggPT09IDMzKVxuICAvLyBMb29wIHNob3VsZCBiZSBmYXN0ZXIgYmVjYXVzZSB3ZSBkbyBub3QgbmVlZCBjcmVhdGUgZXh0cmEgVWludDhBcnJheVxuICAvLyBvdXRwdXQuc2V0KG5ldyBVaW50OEFycmF5KHB1YmtleSkpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgKytpKSBvdXRwdXRbaV0gPSBwdWJrZXlbaV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRleHRSYW5kb21pemUgKCkge1xuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVZlcmlmeSAoc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIHJldHVybiBibi5jbXAoZWNwYXJhbXMubikgPCAwICYmICFibi5pc1plcm8oKSA/IDAgOiAxXG4gIH0sXG5cbiAgcHJpdmF0ZUtleU5lZ2F0ZSAoc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIGNvbnN0IG5lZ2F0ZSA9IGVjcGFyYW1zLm4uc3ViKGJuKS51bW9kKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQobmVnYXRlKVxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVR3ZWFrQWRkIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgYm4uaWFkZChuZXcgQk4oc2Vja2V5KSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIGJuLmlzdWIoZWNwYXJhbXMubilcbiAgICBpZiAoYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBjb25zdCB0d2Vha2VkID0gYm4udG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldCh0d2Vha2VkKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VHdlYWtNdWwgKHNlY2tleSwgdHdlYWspIHtcbiAgICBsZXQgYm4gPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgYm4uaW11bChuZXcgQk4oc2Vja2V5KSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIGJuID0gYm4udW1vZChlY3BhcmFtcy5uKVxuXG4gICAgY29uc3QgdHdlYWtlZCA9IGJuLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQodHdlYWtlZClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VmVyaWZ5IChwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgcmV0dXJuIHBhaXIgPT09IG51bGwgPyAxIDogMFxuICB9LFxuXG4gIHB1YmxpY0tleUNyZWF0ZSAob3V0cHV0LCBzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBlYy5rZXlGcm9tUHJpdmF0ZShzZWNrZXkpLmdldFB1YmxpYygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlDb252ZXJ0IChvdXRwdXQsIHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5TmVnYXRlIChvdXRwdXQsIHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKVxuICAgIHBvaW50LnkgPSBwb2ludC55LnJlZE5lZygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlDb21iaW5lIChvdXRwdXQsIHB1YmtleXMpIHtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBBcnJheShwdWJrZXlzLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBhaXJzW2ldID0gbG9hZFB1YmxpY0tleShwdWJrZXlzW2ldKVxuICAgICAgaWYgKHBhaXJzW2ldID09PSBudWxsKSByZXR1cm4gMVxuICAgIH1cblxuICAgIGxldCBwb2ludCA9IHBhaXJzWzBdLmdldFB1YmxpYygpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYWlycy5sZW5ndGg7ICsraSkgcG9pbnQgPSBwb2ludC5hZGQocGFpcnNbaV0ucHViKVxuICAgIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHJldHVybiAyXG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVR3ZWFrQWRkIChvdXRwdXQsIHB1YmtleSwgdHdlYWspIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkuYWRkKGVjcGFyYW1zLmcubXVsKHR3ZWFrKSlcbiAgICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSByZXR1cm4gMlxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlUd2Vha011bCAob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHR3ZWFrLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bCh0d2VhaylcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHNpZ25hdHVyZU5vcm1hbGl6ZSAoc2lnKSB7XG4gICAgY29uc3QgciA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMCwgMzIpKVxuICAgIGNvbnN0IHMgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDMyLCA2NCkpXG4gICAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgcy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGlmIChzLmNtcChlYy5uaCkgPT09IDEpIHtcbiAgICAgIHNpZy5zZXQoZWNwYXJhbXMubi5zdWIocykudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIC8vIENvcGllZCAxLXRvLTEgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpcDY2L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIC8vIEFkYXB0ZWQgZm9yIFVpbnQ4QXJyYXkgaW5zdGVhZCBCdWZmZXJcbiAgc2lnbmF0dXJlRXhwb3J0IChvYmosIHNpZykge1xuICAgIGNvbnN0IHNpZ1IgPSBzaWcuc3ViYXJyYXkoMCwgMzIpXG4gICAgY29uc3Qgc2lnUyA9IHNpZy5zdWJhcnJheSgzMiwgNjQpXG4gICAgaWYgKG5ldyBCTihzaWdSKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcbiAgICBpZiAobmV3IEJOKHNpZ1MpLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgY29uc3QgeyBvdXRwdXQgfSA9IG9ialxuXG4gICAgLy8gUHJlcGFyZSBSXG4gICAgbGV0IHIgPSBvdXRwdXQuc3ViYXJyYXkoNCwgNCArIDMzKVxuICAgIHJbMF0gPSAweDAwXG4gICAgci5zZXQoc2lnUiwgMSlcblxuICAgIGxldCBsZW5SID0gMzNcbiAgICBsZXQgcG9zUiA9IDBcbiAgICBmb3IgKDsgbGVuUiA+IDEgJiYgcltwb3NSXSA9PT0gMHgwMCAmJiAhKHJbcG9zUiArIDFdICYgMHg4MCk7IC0tbGVuUiwgKytwb3NSKTtcblxuICAgIHIgPSByLnN1YmFycmF5KHBvc1IpXG4gICAgaWYgKHJbMF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5SID4gMSAmJiAoclswXSA9PT0gMHgwMCkgJiYgIShyWzFdICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICAvLyBQcmVwYXJlIFNcbiAgICBsZXQgcyA9IG91dHB1dC5zdWJhcnJheSg2ICsgMzMsIDYgKyAzMyArIDMzKVxuICAgIHNbMF0gPSAweDAwXG4gICAgcy5zZXQoc2lnUywgMSlcblxuICAgIGxldCBsZW5TID0gMzNcbiAgICBsZXQgcG9zUyA9IDBcbiAgICBmb3IgKDsgbGVuUyA+IDEgJiYgc1twb3NTXSA9PT0gMHgwMCAmJiAhKHNbcG9zUyArIDFdICYgMHg4MCk7IC0tbGVuUywgKytwb3NTKTtcblxuICAgIHMgPSBzLnN1YmFycmF5KHBvc1MpXG4gICAgaWYgKHNbMF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5TID4gMSAmJiAoc1swXSA9PT0gMHgwMCkgJiYgIShzWzFdICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICAvLyBTZXQgb3V0cHV0IGxlbmd0aCBmb3IgcmV0dXJuXG4gICAgb2JqLm91dHB1dGxlbiA9IDYgKyBsZW5SICsgbGVuU1xuXG4gICAgLy8gT3V0cHV0IGluIHNwZWNpZmllZCBmb3JtYXRcbiAgICAvLyAweDMwIFt0b3RhbC1sZW5ndGhdIDB4MDIgW1ItbGVuZ3RoXSBbUl0gMHgwMiBbUy1sZW5ndGhdIFtTXVxuICAgIG91dHB1dFswXSA9IDB4MzBcbiAgICBvdXRwdXRbMV0gPSBvYmoub3V0cHV0bGVuIC0gMlxuICAgIG91dHB1dFsyXSA9IDB4MDJcbiAgICBvdXRwdXRbM10gPSByLmxlbmd0aFxuICAgIG91dHB1dC5zZXQociwgNClcbiAgICBvdXRwdXRbNCArIGxlblJdID0gMHgwMlxuICAgIG91dHB1dFs1ICsgbGVuUl0gPSBzLmxlbmd0aFxuICAgIG91dHB1dC5zZXQocywgNiArIGxlblIpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIC8vIENvcGllZCAxLXRvLTEgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpcDY2L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIC8vIEFkYXB0ZWQgZm9yIFVpbnQ4QXJyYXkgaW5zdGVhZCBCdWZmZXJcbiAgc2lnbmF0dXJlSW1wb3J0IChvdXRwdXQsIHNpZykge1xuICAgIGlmIChzaWcubGVuZ3RoIDwgOCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnLmxlbmd0aCA+IDcyKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMF0gIT09IDB4MzApIHJldHVybiAxXG4gICAgaWYgKHNpZ1sxXSAhPT0gc2lnLmxlbmd0aCAtIDIpIHJldHVybiAxXG4gICAgaWYgKHNpZ1syXSAhPT0gMHgwMikgcmV0dXJuIDFcblxuICAgIGNvbnN0IGxlblIgPSBzaWdbM11cbiAgICBpZiAobGVuUiA9PT0gMCkgcmV0dXJuIDFcbiAgICBpZiAoNSArIGxlblIgPj0gc2lnLmxlbmd0aCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzQgKyBsZW5SXSAhPT0gMHgwMikgcmV0dXJuIDFcblxuICAgIGNvbnN0IGxlblMgPSBzaWdbNSArIGxlblJdXG4gICAgaWYgKGxlblMgPT09IDApIHJldHVybiAxXG4gICAgaWYgKCg2ICsgbGVuUiArIGxlblMpICE9PSBzaWcubGVuZ3RoKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ1s0XSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblIgPiAxICYmIChzaWdbNF0gPT09IDB4MDApICYmICEoc2lnWzVdICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICBpZiAoc2lnW2xlblIgKyA2XSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblMgPiAxICYmIChzaWdbbGVuUiArIDZdID09PSAweDAwKSAmJiAhKHNpZ1tsZW5SICsgN10gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIGxldCBzaWdSID0gc2lnLnN1YmFycmF5KDQsIDQgKyBsZW5SKVxuICAgIGlmIChzaWdSLmxlbmd0aCA9PT0gMzMgJiYgc2lnUlswXSA9PT0gMHgwMCkgc2lnUiA9IHNpZ1Iuc3ViYXJyYXkoMSlcbiAgICBpZiAoc2lnUi5sZW5ndGggPiAzMikgcmV0dXJuIDFcblxuICAgIGxldCBzaWdTID0gc2lnLnN1YmFycmF5KDYgKyBsZW5SKVxuICAgIGlmIChzaWdTLmxlbmd0aCA9PT0gMzMgJiYgc2lnU1swXSA9PT0gMHgwMCkgc2lnUyA9IHNpZ1Muc2xpY2UoMSlcbiAgICBpZiAoc2lnUy5sZW5ndGggPiAzMikgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpXG5cbiAgICBsZXQgciA9IG5ldyBCTihzaWdSKVxuICAgIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByID0gbmV3IEJOKDApXG5cbiAgICBsZXQgcyA9IG5ldyBCTihzaWcuc3ViYXJyYXkoNiArIGxlblIpKVxuICAgIGlmIChzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBzID0gbmV3IEJOKDApXG5cbiAgICBvdXRwdXQuc2V0KHIudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAwKVxuICAgIG91dHB1dC5zZXQocy50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RzYVNpZ24gKG9iaiwgbWVzc2FnZSwgc2Vja2V5LCBkYXRhLCBub25jZWZuKSB7XG4gICAgaWYgKG5vbmNlZm4pIHtcbiAgICAgIGNvbnN0IF9ub25jZWZuID0gbm9uY2VmblxuICAgICAgbm9uY2VmbiA9IChjb3VudGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gX25vbmNlZm4obWVzc2FnZSwgc2Vja2V5LCBudWxsLCBkYXRhLCBjb3VudGVyKVxuXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBub25jZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgbm9uY2UubGVuZ3RoID09PSAzMlxuICAgICAgICBpZiAoIWlzVmFsaWQpIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyB0aGUgd2F5JylcblxuICAgICAgICByZXR1cm4gbmV3IEJOKG5vbmNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGQgPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnXG4gICAgdHJ5IHtcbiAgICAgIHNpZyA9IGVjLnNpZ24obWVzc2FnZSwgc2Vja2V5LCB7IGNhbm9uaWNhbDogdHJ1ZSwgazogbm9uY2VmbiwgcGVyczogZGF0YSB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBvYmouc2lnbmF0dXJlLnNldChzaWcuci50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDApXG4gICAgb2JqLnNpZ25hdHVyZS5zZXQoc2lnLnMudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcbiAgICBvYmoucmVjaWQgPSBzaWcucmVjb3ZlcnlQYXJhbVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RzYVZlcmlmeSAoc2lnLCBtc2czMiwgcHVia2V5KSB7XG4gICAgY29uc3Qgc2lnT2JqID0geyByOiBzaWcuc3ViYXJyYXkoMCwgMzIpLCBzOiBzaWcuc3ViYXJyYXkoMzIsIDY0KSB9XG5cbiAgICBjb25zdCBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICAgIGNvbnN0IHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gICAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcbiAgICBpZiAoc2lncy5jbXAoZWMubmgpID09PSAxIHx8IHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIDNcblxuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKVxuICAgIGNvbnN0IGlzVmFsaWQgPSBlYy52ZXJpZnkobXNnMzIsIHNpZ09iaiwgcG9pbnQpXG4gICAgcmV0dXJuIGlzVmFsaWQgPyAwIDogM1xuICB9LFxuXG4gIGVjZHNhUmVjb3ZlciAob3V0cHV0LCBzaWcsIHJlY2lkLCBtc2czMikge1xuICAgIGNvbnN0IHNpZ09iaiA9IHsgcjogc2lnLnNsaWNlKDAsIDMyKSwgczogc2lnLnNsaWNlKDMyLCA2NCkgfVxuXG4gICAgY29uc3Qgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgICBjb25zdCBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICAgIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgLy8gQ2FuIHRocm93IGB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO2BcbiAgICBsZXQgcG9pbnRcbiAgICB0cnkge1xuICAgICAgcG9pbnQgPSBlYy5yZWNvdmVyUHViS2V5KG1zZzMyLCBzaWdPYmosIHJlY2lkKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZGggKG91dHB1dCwgcHVia2V5LCBzZWNrZXksIGRhdGEsIGhhc2hmbiwgeGJ1ZiwgeWJ1Zikge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHNjYWxhciA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKHNjYWxhci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkubXVsKHNjYWxhcilcblxuICAgIGlmIChoYXNoZm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGF0YSA9IHBvaW50LmVuY29kZShudWxsLCB0cnVlKVxuICAgICAgY29uc3Qgc2hhMjU2ID0gZWMuaGFzaCgpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSBvdXRwdXRbaV0gPSBzaGEyNTZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF4YnVmKSB4YnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjb25zdCB4ID0gcG9pbnQuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgMzIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHhidWZbaV0gPSB4W2ldXG5cbiAgICAgIGlmICgheWJ1ZikgeWJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgY29uc3QgeSA9IHBvaW50LmdldFkoKS50b0FycmF5KCdiZScsIDMyKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB5YnVmW2ldID0geVtpXVxuXG4gICAgICBjb25zdCBoYXNoID0gaGFzaGZuKHhidWYsIHlidWYsIGRhdGEpXG5cbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBoYXNoLmxlbmd0aCA9PT0gb3V0cHV0Lmxlbmd0aFxuICAgICAgaWYgKCFpc1ZhbGlkKSByZXR1cm4gMlxuXG4gICAgICBvdXRwdXQuc2V0KGhhc2gpXG4gICAgfVxuXG4gICAgcmV0dXJuIDBcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkVDIiwicmVxdWlyZSIsImVjIiwiZWNwYXJhbXMiLCJjdXJ2ZSIsIkJOIiwibiIsImNvbnN0cnVjdG9yIiwibG9hZENvbXByZXNzZWRQdWJsaWNLZXkiLCJmaXJzdCIsInhidWYiLCJ4IiwiY21wIiwicCIsInRvUmVkIiwicmVkIiwieSIsInJlZFNxciIsInJlZElNdWwiLCJyZWRJQWRkIiwiYiIsInJlZFNxcnQiLCJpc09kZCIsInJlZE5lZyIsImtleVBhaXIiLCJwdWIiLCJsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IiwieWJ1ZiIsIngzIiwicmVkSVN1YiIsImlzWmVybyIsImxvYWRQdWJsaWNLZXkiLCJwdWJrZXkiLCJsZW5ndGgiLCJzdWJhcnJheSIsInNhdmVQdWJsaWNLZXkiLCJvdXRwdXQiLCJwb2ludCIsImVuY29kZSIsImkiLCJtb2R1bGUiLCJleHBvcnRzIiwiY29udGV4dFJhbmRvbWl6ZSIsInByaXZhdGVLZXlWZXJpZnkiLCJzZWNrZXkiLCJibiIsInByaXZhdGVLZXlOZWdhdGUiLCJuZWdhdGUiLCJzdWIiLCJ1bW9kIiwidG9BcnJheUxpa2UiLCJVaW50OEFycmF5Iiwic2V0IiwicHJpdmF0ZUtleVR3ZWFrQWRkIiwidHdlYWsiLCJpYWRkIiwiaXN1YiIsInR3ZWFrZWQiLCJwcml2YXRlS2V5VHdlYWtNdWwiLCJpbXVsIiwicHVibGljS2V5VmVyaWZ5IiwicGFpciIsInB1YmxpY0tleUNyZWF0ZSIsImtleUZyb21Qcml2YXRlIiwiZ2V0UHVibGljIiwicHVibGljS2V5Q29udmVydCIsInB1YmxpY0tleU5lZ2F0ZSIsInB1YmxpY0tleUNvbWJpbmUiLCJwdWJrZXlzIiwicGFpcnMiLCJBcnJheSIsImFkZCIsImlzSW5maW5pdHkiLCJwdWJsaWNLZXlUd2Vha0FkZCIsImciLCJtdWwiLCJwdWJsaWNLZXlUd2Vha011bCIsInNpZ25hdHVyZU5vcm1hbGl6ZSIsInNpZyIsInIiLCJzIiwibmgiLCJzaWduYXR1cmVFeHBvcnQiLCJvYmoiLCJzaWdSIiwic2lnUyIsImxlblIiLCJwb3NSIiwibGVuUyIsInBvc1MiLCJvdXRwdXRsZW4iLCJzaWduYXR1cmVJbXBvcnQiLCJzbGljZSIsIkVycm9yIiwiZWNkc2FTaWduIiwibWVzc2FnZSIsImRhdGEiLCJub25jZWZuIiwiX25vbmNlZm4iLCJjb3VudGVyIiwibm9uY2UiLCJpc1ZhbGlkIiwiZCIsInNpZ24iLCJjYW5vbmljYWwiLCJrIiwicGVycyIsImVyciIsInNpZ25hdHVyZSIsInJlY2lkIiwicmVjb3ZlcnlQYXJhbSIsImVjZHNhVmVyaWZ5IiwibXNnMzIiLCJzaWdPYmoiLCJzaWdyIiwic2lncyIsInZlcmlmeSIsImVjZHNhUmVjb3ZlciIsInJlY292ZXJQdWJLZXkiLCJlY2RoIiwiaGFzaGZuIiwic2NhbGFyIiwidW5kZWZpbmVkIiwic2hhMjU2IiwiaGFzaCIsInVwZGF0ZSIsImRpZ2VzdCIsImdldFgiLCJ0b0FycmF5IiwiZ2V0WSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/secp256k1/lib/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/secp256k1/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/secp256k1/lib/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\nconst errors = {\n    IMPOSSIBLE_CASE: \"Impossible case. Please create issue.\",\n    TWEAK_ADD: \"The tweak was out of range or the resulted private key is invalid\",\n    TWEAK_MUL: \"The tweak was out of range or equal to zero\",\n    CONTEXT_RANDOMIZE_UNKNOW: \"Unknow error on context randomization\",\n    SECKEY_INVALID: \"Private Key is invalid\",\n    PUBKEY_PARSE: \"Public Key could not be parsed\",\n    PUBKEY_SERIALIZE: \"Public Key serialization error\",\n    PUBKEY_COMBINE: \"The sum of the public keys is not valid\",\n    SIG_PARSE: \"Signature could not be parsed\",\n    SIGN: \"The nonce generation function failed, or the private key was invalid\",\n    RECOVER: \"Public key could not be recover\",\n    ECDH: \"Scalar was invalid (zero or overflow)\"\n};\nfunction assert(cond, msg) {\n    if (!cond) throw new Error(msg);\n}\nfunction isUint8Array(name, value, length) {\n    assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);\n    if (length !== undefined) {\n        if (Array.isArray(length)) {\n            const numbers = length.join(\", \");\n            const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;\n            assert(length.includes(value.length), msg);\n        } else {\n            const msg = `Expected ${name} to be an Uint8Array with length ${length}`;\n            assert(value.length === length, msg);\n        }\n    }\n}\nfunction isCompressed(value) {\n    assert(toTypeString(value) === \"Boolean\", \"Expected compressed to be a Boolean\");\n}\nfunction getAssertedOutput(output = (len)=>new Uint8Array(len), length) {\n    if (typeof output === \"function\") output = output(length);\n    isUint8Array(\"output\", output, length);\n    return output;\n}\nfunction toTypeString(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nmodule.exports = (secp256k1)=>{\n    return {\n        contextRandomize (seed) {\n            assert(seed === null || seed instanceof Uint8Array, \"Expected seed to be an Uint8Array or null\");\n            if (seed !== null) isUint8Array(\"seed\", seed, 32);\n            switch(secp256k1.contextRandomize(seed)){\n                case 1:\n                    throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n            }\n        },\n        privateKeyVerify (seckey) {\n            isUint8Array(\"private key\", seckey, 32);\n            return secp256k1.privateKeyVerify(seckey) === 0;\n        },\n        privateKeyNegate (seckey) {\n            isUint8Array(\"private key\", seckey, 32);\n            switch(secp256k1.privateKeyNegate(seckey)){\n                case 0:\n                    return seckey;\n                case 1:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        privateKeyTweakAdd (seckey, tweak) {\n            isUint8Array(\"private key\", seckey, 32);\n            isUint8Array(\"tweak\", tweak, 32);\n            switch(secp256k1.privateKeyTweakAdd(seckey, tweak)){\n                case 0:\n                    return seckey;\n                case 1:\n                    throw new Error(errors.TWEAK_ADD);\n            }\n        },\n        privateKeyTweakMul (seckey, tweak) {\n            isUint8Array(\"private key\", seckey, 32);\n            isUint8Array(\"tweak\", tweak, 32);\n            switch(secp256k1.privateKeyTweakMul(seckey, tweak)){\n                case 0:\n                    return seckey;\n                case 1:\n                    throw new Error(errors.TWEAK_MUL);\n            }\n        },\n        publicKeyVerify (pubkey) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            return secp256k1.publicKeyVerify(pubkey) === 0;\n        },\n        publicKeyCreate (seckey, compressed = true, output) {\n            isUint8Array(\"private key\", seckey, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyCreate(output, seckey)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.SECKEY_INVALID);\n                case 2:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyConvert (pubkey, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyConvert(output, pubkey)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyNegate (pubkey, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyNegate(output, pubkey)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n                case 3:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyCombine (pubkeys, compressed = true, output) {\n            assert(Array.isArray(pubkeys), \"Expected public keys to be an Array\");\n            assert(pubkeys.length > 0, \"Expected public keys array will have more than zero items\");\n            for (const pubkey of pubkeys){\n                isUint8Array(\"public key\", pubkey, [\n                    33,\n                    65\n                ]);\n            }\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyCombine(output, pubkeys)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.PUBKEY_COMBINE);\n                case 3:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isUint8Array(\"tweak\", tweak, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyTweakAdd(output, pubkey, tweak)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.TWEAK_ADD);\n            }\n        },\n        publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isUint8Array(\"tweak\", tweak, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyTweakMul(output, pubkey, tweak)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.TWEAK_MUL);\n            }\n        },\n        signatureNormalize (sig) {\n            isUint8Array(\"signature\", sig, 64);\n            switch(secp256k1.signatureNormalize(sig)){\n                case 0:\n                    return sig;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n            }\n        },\n        signatureExport (sig, output) {\n            isUint8Array(\"signature\", sig, 64);\n            output = getAssertedOutput(output, 72);\n            const obj = {\n                output,\n                outputlen: 72\n            };\n            switch(secp256k1.signatureExport(obj, sig)){\n                case 0:\n                    return output.slice(0, obj.outputlen);\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        signatureImport (sig, output) {\n            isUint8Array(\"signature\", sig);\n            output = getAssertedOutput(output, 64);\n            switch(secp256k1.signatureImport(output, sig)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        ecdsaSign (msg32, seckey, options = {}, output) {\n            isUint8Array(\"message\", msg32, 32);\n            isUint8Array(\"private key\", seckey, 32);\n            assert(toTypeString(options) === \"Object\", \"Expected options to be an Object\");\n            if (options.data !== undefined) isUint8Array(\"options.data\", options.data);\n            if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === \"Function\", \"Expected options.noncefn to be a Function\");\n            output = getAssertedOutput(output, 64);\n            const obj = {\n                signature: output,\n                recid: null\n            };\n            switch(secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)){\n                case 0:\n                    return obj;\n                case 1:\n                    throw new Error(errors.SIGN);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        ecdsaVerify (sig, msg32, pubkey) {\n            isUint8Array(\"signature\", sig, 64);\n            isUint8Array(\"message\", msg32, 32);\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            switch(secp256k1.ecdsaVerify(sig, msg32, pubkey)){\n                case 0:\n                    return true;\n                case 3:\n                    return false;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.PUBKEY_PARSE);\n            }\n        },\n        ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n            isUint8Array(\"signature\", sig, 64);\n            assert(toTypeString(recid) === \"Number\" && recid >= 0 && recid <= 3, \"Expected recovery id to be a Number within interval [0, 3]\");\n            isUint8Array(\"message\", msg32, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.ecdsaRecover(output, sig, recid, msg32)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.RECOVER);\n                case 3:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        ecdh (pubkey, seckey, options = {}, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isUint8Array(\"private key\", seckey, 32);\n            assert(toTypeString(options) === \"Object\", \"Expected options to be an Object\");\n            if (options.data !== undefined) isUint8Array(\"options.data\", options.data);\n            if (options.hashfn !== undefined) {\n                assert(toTypeString(options.hashfn) === \"Function\", \"Expected options.hashfn to be a Function\");\n                if (options.xbuf !== undefined) isUint8Array(\"options.xbuf\", options.xbuf, 32);\n                if (options.ybuf !== undefined) isUint8Array(\"options.ybuf\", options.ybuf, 32);\n                isUint8Array(\"output\", output);\n            } else {\n                output = getAssertedOutput(output, 32);\n            }\n            switch(secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.ECDH);\n            }\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsU0FBUztJQUNiQyxpQkFBaUI7SUFDakJDLFdBQ0U7SUFDRkMsV0FBVztJQUNYQywwQkFBMEI7SUFDMUJDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLGdCQUFnQjtJQUNoQkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsTUFBTTtBQUNSO0FBRUEsU0FBU0MsT0FBUUMsSUFBSSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksQ0FBQ0QsTUFBTSxNQUFNLElBQUlFLE1BQU1EO0FBQzdCO0FBRUEsU0FBU0UsYUFBY0MsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDeENQLE9BQU9NLGlCQUFpQkUsWUFBWSxDQUFDLFNBQVMsRUFBRUgsS0FBSyxvQkFBb0IsQ0FBQztJQUUxRSxJQUFJRSxXQUFXRSxXQUFXO1FBQ3hCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osU0FBUztZQUN6QixNQUFNSyxVQUFVTCxPQUFPTSxJQUFJLENBQUM7WUFDNUIsTUFBTVgsTUFBTSxDQUFDLFNBQVMsRUFBRUcsS0FBSyxrQ0FBa0MsRUFBRU8sUUFBUSxDQUFDLENBQUM7WUFDM0VaLE9BQU9PLE9BQU9PLFFBQVEsQ0FBQ1IsTUFBTUMsTUFBTSxHQUFHTDtRQUN4QyxPQUFPO1lBQ0wsTUFBTUEsTUFBTSxDQUFDLFNBQVMsRUFBRUcsS0FBSyxpQ0FBaUMsRUFBRUUsT0FBTyxDQUFDO1lBQ3hFUCxPQUFPTSxNQUFNQyxNQUFNLEtBQUtBLFFBQVFMO1FBQ2xDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNhLGFBQWNULEtBQUs7SUFDMUJOLE9BQU9nQixhQUFhVixXQUFXLFdBQVc7QUFDNUM7QUFFQSxTQUFTVyxrQkFBbUJDLFNBQVMsQ0FBQ0MsTUFBUSxJQUFJWCxXQUFXVyxJQUFJLEVBQUVaLE1BQU07SUFDdkUsSUFBSSxPQUFPVyxXQUFXLFlB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LEVBQUVwQyxNQUFNO1lBQ3hDZCxhQUFhLGNBQWNpQyxRQUFRO2dCQUFDO2dCQUFJO2FBQUc7WUFDM0NqQyxhQUFhLGVBQWUyQixRQUFRO1lBQ3BDL0IsT0FBT2dCLGFBQWFzQyxhQUFhLFVBQVU7WUFDM0MsSUFBSUEsUUFBUUMsSUFBSSxLQUFLOUMsV0FBV0wsYUFBYSxnQkFBZ0JrRCxRQUFRQyxJQUFJO1lBQ3pFLElBQUlELFFBQVFRLE1BQU0sS0FBS3JELFdBQVc7Z0JBQ2hDVCxPQUFPZ0IsYUFBYXNDLFFBQVFRLE1BQU0sTUFBTSxZQUFZO2dCQUNwRCxJQUFJUixRQUFRUyxJQUFJLEtBQUt0RCxXQUFXTCxhQUFhLGdCQUFnQmtELFFBQVFTLElBQUksRUFBRTtnQkFDM0UsSUFBSVQsUUFBUVUsSUFBSSxLQUFLdkQsV0FBV0wsYUFBYSxnQkFBZ0JrRCxRQUFRVSxJQUFJLEVBQUU7Z0JBQzNFNUQsYUFBYSxVQUFVYztZQUN6QixPQUFPO2dCQUNMQSxTQUFTRCxrQkFBa0JDLFFBQVE7WUFDckM7WUFFQSxPQUFRUyxVQUFVa0MsSUFBSSxDQUFDM0MsUUFBUW1CLFFBQVFOLFFBQVF1QixRQUFRQyxJQUFJLEVBQUVELFFBQVFRLE1BQU0sRUFBRVIsUUFBUVMsSUFBSSxFQUFFVCxRQUFRVSxJQUFJO2dCQUNyRyxLQUFLO29CQUNILE9BQU85QztnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSWYsTUFBTWhCLE9BQU9NLFlBQVk7Z0JBQ3JDLEtBQUs7b0JBQ0gsTUFBTSxJQUFJVSxNQUFNaEIsT0FBT1ksSUFBSTtZQUMvQjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvaW5kZXguanM/OTNhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlcnJvcnMgPSB7XG4gIElNUE9TU0lCTEVfQ0FTRTogJ0ltcG9zc2libGUgY2FzZS4gUGxlYXNlIGNyZWF0ZSBpc3N1ZS4nLFxuICBUV0VBS19BREQ6XG4gICAgJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyxcbiAgVFdFQUtfTVVMOiAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgZXF1YWwgdG8gemVybycsXG4gIENPTlRFWFRfUkFORE9NSVpFX1VOS05PVzogJ1Vua25vdyBlcnJvciBvbiBjb250ZXh0IHJhbmRvbWl6YXRpb24nLFxuICBTRUNLRVlfSU5WQUxJRDogJ1ByaXZhdGUgS2V5IGlzIGludmFsaWQnLFxuICBQVUJLRVlfUEFSU0U6ICdQdWJsaWMgS2V5IGNvdWxkIG5vdCBiZSBwYXJzZWQnLFxuICBQVUJLRVlfU0VSSUFMSVpFOiAnUHVibGljIEtleSBzZXJpYWxpemF0aW9uIGVycm9yJyxcbiAgUFVCS0VZX0NPTUJJTkU6ICdUaGUgc3VtIG9mIHRoZSBwdWJsaWMga2V5cyBpcyBub3QgdmFsaWQnLFxuICBTSUdfUEFSU0U6ICdTaWduYXR1cmUgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFNJR046ICdUaGUgbm9uY2UgZ2VuZXJhdGlvbiBmdW5jdGlvbiBmYWlsZWQsIG9yIHRoZSBwcml2YXRlIGtleSB3YXMgaW52YWxpZCcsXG4gIFJFQ09WRVI6ICdQdWJsaWMga2V5IGNvdWxkIG5vdCBiZSByZWNvdmVyJyxcbiAgRUNESDogJ1NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkgdGhyb3cgbmV3IEVycm9yKG1zZylcbn1cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5IChuYW1lLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIGFuIFVpbnQ4QXJyYXlgKVxuXG4gIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IG51bWJlcnMgPSBsZW5ndGguam9pbignLCAnKVxuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCBbJHtudW1iZXJzfV1gXG4gICAgICBhc3NlcnQobGVuZ3RoLmluY2x1ZGVzKHZhbHVlLmxlbmd0aCksIG1zZylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCAke2xlbmd0aH1gXG4gICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSBsZW5ndGgsIG1zZylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb21wcmVzc2VkICh2YWx1ZSkge1xuICBhc3NlcnQodG9UeXBlU3RyaW5nKHZhbHVlKSA9PT0gJ0Jvb2xlYW4nLCAnRXhwZWN0ZWQgY29tcHJlc3NlZCB0byBiZSBhIEJvb2xlYW4nKVxufVxuXG5mdW5jdGlvbiBnZXRBc3NlcnRlZE91dHB1dCAob3V0cHV0ID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSBvdXRwdXQgPSBvdXRwdXQobGVuZ3RoKVxuICBpc1VpbnQ4QXJyYXkoJ291dHB1dCcsIG91dHB1dCwgbGVuZ3RoKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHRvVHlwZVN0cmluZyAodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHNlY3AyNTZrMSkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRSYW5kb21pemUgKHNlZWQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgc2VlZCA9PT0gbnVsbCB8fCBzZWVkIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgJ0V4cGVjdGVkIHNlZWQgdG8gYmUgYW4gVWludDhBcnJheSBvciBudWxsJ1xuICAgICAgKVxuICAgICAgaWYgKHNlZWQgIT09IG51bGwpIGlzVWludDhBcnJheSgnc2VlZCcsIHNlZWQsIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5jb250ZXh0UmFuZG9taXplKHNlZWQpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkNPTlRFWFRfUkFORE9NSVpFX1VOS05PVylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVZlcmlmeSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHNlY2tleSkgPT09IDBcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShzZWNrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrQWRkIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19BREQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoc2Vja2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVia2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGUgKHNlY2tleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShvdXRwdXQsIHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0VDS0VZX0lOVkFMSUQpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNvbnZlcnQgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29udmVydChvdXRwdXQsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlOZWdhdGUgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5TmVnYXRlKG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29tYmluZSAocHVia2V5cywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocHVia2V5cyksICdFeHBlY3RlZCBwdWJsaWMga2V5cyB0byBiZSBhbiBBcnJheScpXG4gICAgICBhc3NlcnQocHVia2V5cy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgcHVibGljIGtleXMgYXJyYXkgd2lsbCBoYXZlIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zJylcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIH1cbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShvdXRwdXQsIHB1YmtleXMpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX0NPTUJJTkUpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrQWRkIChwdWJrZXksIHR3ZWFrLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtNdWwgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNpZ1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNzIpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgb3V0cHV0LCBvdXRwdXRsZW46IDcyIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChvYmosIHNpZykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXQuc2xpY2UoMCwgb2JqLm91dHB1dGxlbilcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KG91dHB1dCwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FTaWduIChtc2czMiwgc2Vja2V5LCBvcHRpb25zID0ge30sIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5ub25jZWZuICE9PSB1bmRlZmluZWQpIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5ub25jZWZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMubm9uY2VmbiB0byBiZSBhIEZ1bmN0aW9uJylcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNjQpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgc2lnbmF0dXJlOiBvdXRwdXQsIHJlY2lkOiBudWxsIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhU2lnbihvYmosIG1zZzMyLCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5ub25jZWZuKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdOKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KHNpZywgbXNnMzIsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhUmVjb3ZlciAoc2lnLCByZWNpZCwgbXNnMzIsIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGFzc2VydChcbiAgICAgICAgdG9UeXBlU3RyaW5nKHJlY2lkKSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICByZWNpZCA+PSAwICYmXG4gICAgICAgICAgcmVjaWQgPD0gMyxcbiAgICAgICAgJ0V4cGVjdGVkIHJlY292ZXJ5IGlkIHRvIGJlIGEgTnVtYmVyIHdpdGhpbiBpbnRlcnZhbCBbMCwgM10nXG4gICAgICApXG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlJFQ09WRVIpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkaCAocHVia2V5LCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5oYXNoZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMuaGFzaGZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMuaGFzaGZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgICBpZiAob3B0aW9ucy54YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy54YnVmJywgb3B0aW9ucy54YnVmLCAzMilcbiAgICAgICAgaWYgKG9wdGlvbnMueWJ1ZiAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMueWJ1ZicsIG9wdGlvbnMueWJ1ZiwgMzIpXG4gICAgICAgIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCAzMilcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkaChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBvcHRpb25zLmRhdGEsIG9wdGlvbnMuaGFzaGZuLCBvcHRpb25zLnhidWYsIG9wdGlvbnMueWJ1ZikpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5FQ0RIKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImVycm9ycyIsIklNUE9TU0lCTEVfQ0FTRSIsIlRXRUFLX0FERCIsIlRXRUFLX01VTCIsIkNPTlRFWFRfUkFORE9NSVpFX1VOS05PVyIsIlNFQ0tFWV9JTlZBTElEIiwiUFVCS0VZX1BBUlNFIiwiUFVCS0VZX1NFUklBTElaRSIsIlBVQktFWV9DT01CSU5FIiwiU0lHX1BBUlNFIiwiU0lHTiIsIlJFQ09WRVIiLCJFQ0RIIiwiYXNzZXJ0IiwiY29uZCIsIm1zZyIsIkVycm9yIiwiaXNVaW50OEFycmF5IiwibmFtZSIsInZhbHVlIiwibGVuZ3RoIiwiVWludDhBcnJheSIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsIm51bWJlcnMiLCJqb2luIiwiaW5jbHVkZXMiLCJpc0NvbXByZXNzZWQiLCJ0b1R5cGVTdHJpbmciLCJnZXRBc3NlcnRlZE91dHB1dCIsIm91dHB1dCIsImxlbiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsInNlY3AyNTZrMSIsImNvbnRleHRSYW5kb21pemUiLCJzZWVkIiwicHJpdmF0ZUtleVZlcmlmeSIsInNlY2tleSIsInByaXZhdGVLZXlOZWdhdGUiLCJwcml2YXRlS2V5VHdlYWtBZGQiLCJ0d2VhayIsInByaXZhdGVLZXlUd2Vha011bCIsInB1YmxpY0tleVZlcmlmeSIsInB1YmtleSIsInB1YmxpY0tleUNyZWF0ZSIsImNvbXByZXNzZWQiLCJwdWJsaWNLZXlDb252ZXJ0IiwicHVibGljS2V5TmVnYXRlIiwicHVibGljS2V5Q29tYmluZSIsInB1YmtleXMiLCJwdWJsaWNLZXlUd2Vha0FkZCIsInB1YmxpY0tleVR3ZWFrTXVsIiwic2lnbmF0dXJlTm9ybWFsaXplIiwic2lnIiwic2lnbmF0dXJlRXhwb3J0Iiwib2JqIiwib3V0cHV0bGVuIiwic2lnbmF0dXJlSW1wb3J0IiwiZWNkc2FTaWduIiwibXNnMzIiLCJvcHRpb25zIiwiZGF0YSIsIm5vbmNlZm4iLCJzaWduYXR1cmUiLCJyZWNpZCIsImVjZHNhVmVyaWZ5IiwiZWNkc2FSZWNvdmVyIiwiZWNkaCIsImhhc2hmbiIsInhidWYiLCJ5YnVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/secp256k1/lib/index.js\n");

/***/ })

};
;
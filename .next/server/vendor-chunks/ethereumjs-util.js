"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-util";
exports.ids = ["vendor-chunks/ethereumjs-util"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/account.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/account.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-util/dist/constants.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\");\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */ constructor(nonce = new externals_1.BN(0), balance = new externals_1.BN(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL){\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, stateRoot, codeHash } = accountData;\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = externals_1.rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error(\"Invalid serialized account input. Must be array\");\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, stateRoot, codeHash] = values;\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce.lt(new externals_1.BN(0))) {\n            throw new Error(\"nonce must be greater than zero\");\n        }\n        if (this.balance.lt(new externals_1.BN(0))) {\n            throw new Error(\"balance must be greater than zero\");\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error(\"stateRoot must have a length of 32\");\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error(\"codeHash must have a length of 32\");\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */ raw() {\n        return [\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\n            this.stateRoot,\n            this.codeHash\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */ serialize() {\n        return externals_1.rlp.encode(this.raw());\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */ isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */ isEmpty() {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ const isValidAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */ const toChecksumAddress = function(hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = \"\";\n    if (eip1191ChainId) {\n        const chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + \"0x\";\n    }\n    const hash = (0, hash_1.keccakFromString)(prefix + address).toString(\"hex\");\n    let ret = \"0x\";\n    for(let i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ const generateAddress = function(from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    const nonceBN = new externals_1.BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return (0, hash_1.rlphash)([\n            from,\n            null\n        ]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.rlphash)([\n        from,\n        Buffer.from(nonceBN.toArray())\n    ]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ const generateAddress2 = function(from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    (0, assert_1.default)(from.length === 20);\n    (0, assert_1.default)(salt.length === 32);\n    const address = (0, hash_1.keccak256)(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        from,\n        salt,\n        (0, hash_1.keccak256)(initCode)\n    ]));\n    return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ const isValidPrivate = function(privateKey) {\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const isValidPublic = function(publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([\n            Buffer.from([\n                4\n            ]),\n            publicKey\n        ]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const pubToAddress = function(pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n    }\n    (0, assert_1.default)(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToPublic = function(privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToAddress = function(privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */ const importPublic = function(publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */ const zeroAddress = function() {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */ const isZeroAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSw4QkFBOEIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUM5WCxNQUFNaUIsV0FBV3RCLGdCQUFnQnVCLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pELE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pDLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLGdHQUFpQztBQUM3RCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN2QyxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyxpRUFBUTtBQUMvQixNQUFNTyxZQUFZUCxtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQyxNQUFNUSxVQUFVUixtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNRjtJQUNGOzs7S0FHQyxHQUNEVyxZQUFZQyxRQUFRLElBQUlULFlBQVlVLEVBQUUsQ0FBQyxFQUFFLEVBQUVDLFVBQVUsSUFBSVgsWUFBWVUsRUFBRSxDQUFDLEVB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eEMsT0FBT3FHLGFBQWE3QztBQUN4QjtBQUNBM0QscUJBQXFCLEdBQUdFLGVBQ3hCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2FjY291bnQuanM/YmIxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MgPSBleHBvcnRzLmltcG9ydFB1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBleHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZXhwb3J0cy5BY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY2xhc3MgQWNjb3VudCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciBhc3NpZ25zIGFuZCB2YWxpZGF0ZXMgdGhlIHZhbHVlcy5cbiAgICAgKiBVc2UgdGhlIHN0YXRpYyBmYWN0b3J5IG1ldGhvZHMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGFuIEFjY291bnQgZnJvbSB2YXJ5aW5nIGRhdGEgdHlwZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9uY2UgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oMCksIGJhbGFuY2UgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oMCksIHN0YXRlUm9vdCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9STFAsIGNvZGVIYXNoID0gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpIHtcbiAgICAgICAgdGhpcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB0aGlzLmJhbGFuY2UgPSBiYWxhbmNlO1xuICAgICAgICB0aGlzLnN0YXRlUm9vdCA9IHN0YXRlUm9vdDtcbiAgICAgICAgdGhpcy5jb2RlSGFzaCA9IGNvZGVIYXNoO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGFjY291bnREYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgbm9uY2UsIGJhbGFuY2UsIHN0YXRlUm9vdCwgY29kZUhhc2ggfSA9IGFjY291bnREYXRhO1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnQobm9uY2UgPyBuZXcgZXh0ZXJuYWxzXzEuQk4oKDAsIGJ5dGVzXzEudG9CdWZmZXIpKG5vbmNlKSkgOiB1bmRlZmluZWQsIGJhbGFuY2UgPyBuZXcgZXh0ZXJuYWxzXzEuQk4oKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGJhbGFuY2UpKSA6IHVuZGVmaW5lZCwgc3RhdGVSb290ID8gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHN0YXRlUm9vdCkgOiB1bmRlZmluZWQsIGNvZGVIYXNoID8gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGNvZGVIYXNoKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmxwU2VyaWFsaXplZEFjY291bnQoc2VyaWFsaXplZCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBleHRlcm5hbHNfMS5ybHAuZGVjb2RlKHNlcmlhbGl6ZWQpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcmlhbGl6ZWQgYWNjb3VudCBpbnB1dC4gTXVzdCBiZSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgICAgICBjb25zdCBbbm9uY2UsIGJhbGFuY2UsIHN0YXRlUm9vdCwgY29kZUhhc2hdID0gdmFsdWVzO1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnQobmV3IGV4dGVybmFsc18xLkJOKG5vbmNlKSwgbmV3IGV4dGVybmFsc18xLkJOKGJhbGFuY2UpLCBzdGF0ZVJvb3QsIGNvZGVIYXNoKTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub25jZS5sdChuZXcgZXh0ZXJuYWxzXzEuQk4oMCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYWxhbmNlLmx0KG5ldyBleHRlcm5hbHNfMS5CTigwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFsYW5jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGVSb290Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhdGVSb290IG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAzMicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvZGVIYXNoLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29kZUhhc2ggbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBBcnJheSBvZiB0aGUgcmF3IEJ1ZmZlcnMgZm9yIHRoZSBhY2NvdW50LCBpbiBvcmRlci5cbiAgICAgKi9cbiAgICByYXcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoMCwgdHlwZXNfMS5iblRvVW5wYWRkZWRCdWZmZXIpKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgKDAsIHR5cGVzXzEuYm5Ub1VucGFkZGVkQnVmZmVyKSh0aGlzLmJhbGFuY2UpLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZVJvb3QsXG4gICAgICAgICAgICB0aGlzLmNvZGVIYXNoLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBSTFAgc2VyaWFsaXphdGlvbiBvZiB0aGUgYWNjb3VudCBhcyBhIGBCdWZmZXJgLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsc18xLnJscC5lbmNvZGUodGhpcy5yYXcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQm9vbGVhbmAgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjY291bnQgaXMgYSBjb250cmFjdC5cbiAgICAgKi9cbiAgICBpc0NvbnRyYWN0KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29kZUhhc2guZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCb29sZWFuYCBkZXRlcm1pbmluZyBpZiB0aGUgYWNjb3VudCBpcyBlbXB0eSBjb21wbHlpbmcgdG8gdGhlIGRlZmluaXRpb24gb2ZcbiAgICAgKiBhY2NvdW50IGVtcHRpbmVzcyBpbiBbRUlQLTE2MV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNjEpOlxuICAgICAqIFwiQW4gYWNjb3VudCBpcyBjb25zaWRlcmVkIGVtcHR5IHdoZW4gaXQgaGFzIG5vIGNvZGUgYW5kIHplcm8gbm9uY2UgYW5kIHplcm8gYmFsYW5jZS5cIlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2UuaXNaZXJvKCkgJiYgdGhpcy5ub25jZS5pc1plcm8oKSAmJiB0aGlzLmNvZGVIYXNoLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvby5cbiAqL1xuY29uc3QgaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGhleEFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChoZXhBZGRyZXNzKTtcbn07XG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gaXNWYWxpZEFkZHJlc3M7XG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIElmIGFuIGVpcDExOTFDaGFpbklkIGlzIHByb3ZpZGVkLCB0aGUgY2hhaW5JZCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjaGVja3N1bSBjYWxjdWxhdGlvbi4gVGhpc1xuICogaGFzIHRoZSBlZmZlY3Qgb2YgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIGZvciBvbmUgY2hhaW4gaGF2aW5nIGludmFsaWQgY2hlY2tzdW1zIGZvciBvdGhlcnMuXG4gKiBGb3IgbW9yZSBkZXRhaWxzIHNlZSBbRUlQLTExOTFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5MSkuXG4gKlxuICogV0FSTklORzogQ2hlY2tzdW1zIHdpdGggYW5kIHdpdGhvdXQgdGhlIGNoYWluSWQgd2lsbCBkaWZmZXIgYW5kIHRoZSBFSVAtMTE5MSBjaGVja3N1bSBpcyBub3RcbiAqIGJhY2t3YXJkcyBjb21wYXRpYmxlIHRvIHRoZSBvcmlnaW5hbCB3aWRlbHkgYWRvcHRlZCBjaGVja3N1bSBmb3JtYXQgc3RhbmRhcmQgaW50cm9kdWNlZCBpblxuICogW0VJUC01NV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC01NSksIHNvIHRoaXMgd2lsbCBicmVhayBpbiBleGlzdGluZyBhcHBsaWNhdGlvbnMuXG4gKiBVc2FnZSBvZiB0aGlzIEVJUCBpcyB0aGVyZWZvcmUgZGlzY291cmFnZWQgdW5sZXNzIHlvdSBoYXZlIGEgdmVyeSB0YXJnZXRlZCB1c2UgY2FzZS5cbiAqL1xuY29uc3QgdG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShoZXhBZGRyZXNzKTtcbiAgICBjb25zdCBhZGRyZXNzID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGhleEFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHByZWZpeCA9ICcnO1xuICAgIGlmIChlaXAxMTkxQ2hhaW5JZCkge1xuICAgICAgICBjb25zdCBjaGFpbklkID0gKDAsIHR5cGVzXzEudG9UeXBlKShlaXAxMTkxQ2hhaW5JZCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICAgICAgcHJlZml4ID0gY2hhaW5JZC50b1N0cmluZygpICsgJzB4JztcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9ICgwLCBoYXNoXzEua2VjY2FrRnJvbVN0cmluZykocHJlZml4ICsgYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xuICAgIGxldCByZXQgPSAnMHgnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSB0b0NoZWNrc3VtQWRkcmVzcztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBTZWUgdG9DaGVja3N1bUFkZHJlc3MnIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMgYWJvdXQgdGhlIGVpcDExOTFDaGFpbklkIHBhcmFtZXRlci5cbiAqL1xuY29uc3QgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcykoaGV4QWRkcmVzcykgJiYgKDAsIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MpKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSA9PT0gaGV4QWRkcmVzcztcbn07XG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3QuXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqL1xuY29uc3QgZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoZnJvbSk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobm9uY2UpO1xuICAgIGNvbnN0IG5vbmNlQk4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4obm9uY2UpO1xuICAgIGlmIChub25jZUJOLmlzWmVybygpKSB7XG4gICAgICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAgICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgICAgICByZXR1cm4gKDAsIGhhc2hfMS5ybHBoYXNoKShbZnJvbSwgbnVsbF0pLnNsaWNlKC0yMCk7XG4gICAgfVxuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICAgIHJldHVybiAoMCwgaGFzaF8xLnJscGhhc2gpKFtmcm9tLCBCdWZmZXIuZnJvbShub25jZUJOLnRvQXJyYXkoKSldKS5zbGljZSgtMjApO1xufTtcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBjb250cmFjdCBjcmVhdGVkIHVzaW5nIENSRUFURTIuXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0gc2FsdCBBIHNhbHRcbiAqIEBwYXJhbSBpbml0Q29kZSBUaGUgaW5pdCBjb2RlIG9mIHRoZSBjb250cmFjdCBiZWluZyBjcmVhdGVkXG4gKi9cbmNvbnN0IGdlbmVyYXRlQWRkcmVzczIgPSBmdW5jdGlvbiAoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShmcm9tKTtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShzYWx0KTtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShpbml0Q29kZSk7XG4gICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGZyb20ubGVuZ3RoID09PSAyMCk7XG4gICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKHNhbHQubGVuZ3RoID09PSAzMik7XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBoYXNoXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb20sIHNhbHQsICgwLCBoYXNoXzEua2VjY2FrMjU2KShpbml0Q29kZSldKSk7XG4gICAgcmV0dXJuIGFkZHJlc3Muc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBnZW5lcmF0ZUFkZHJlc3MyO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqL1xuY29uc3QgaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiAoMCwgc2VjcDI1NmsxXzEucHJpdmF0ZUtleVZlcmlmeSkocHJpdmF0ZUtleSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGlzVmFsaWRQcml2YXRlO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5jb25zdCBpc1ZhbGlkUHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgc2FuaXRpemUgPSBmYWxzZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YmxpY0tleSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgICAgIHJldHVybiAoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5VmVyaWZ5KShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gICAgfVxuICAgIGlmICghc2FuaXRpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleVZlcmlmeSkocHVibGljS2V5KTtcbn07XG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBpc1ZhbGlkUHVibGljO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5jb25zdCBwdWJUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSA9IGZhbHNlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikocHViS2V5KTtcbiAgICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgcHViS2V5ID0gQnVmZmVyLmZyb20oKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleUNvbnZlcnQpKHB1YktleSwgZmFsc2UpLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKHB1YktleS5sZW5ndGggPT09IDY0KTtcbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gKDAsIGhhc2hfMS5rZWNjYWspKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IHB1YlRvQWRkcmVzcztcbmV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3M7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKi9cbmNvbnN0IHByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikocHJpdmF0ZUtleSk7XG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDcmVhdGUpKHByaXZhdGVLZXksIGZhbHNlKSkuc2xpY2UoMSk7XG59O1xuZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBwcml2YXRlVG9QdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKi9cbmNvbnN0IHByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MpKCgwLCBleHBvcnRzLnByaXZhdGVUb1B1YmxpYykocHJpdmF0ZUtleSkpO1xufTtcbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IHByaXZhdGVUb0FkZHJlc3M7XG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byB0aGUgRXRoZXJldW0gZm9ybWF0LlxuICovXG5jb25zdCBpbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmZyb20oKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleUNvbnZlcnQpKHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGltcG9ydFB1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgemVybyBhZGRyZXNzLlxuICovXG5jb25zdCB6ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gICAgY29uc3QgYWRkciA9ICgwLCBieXRlc18xLnplcm9zKShhZGRyZXNzTGVuZ3RoKTtcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKGFkZHIpO1xufTtcbmV4cG9ydHMuemVyb0FkZHJlc3MgPSB6ZXJvQWRkcmVzcztcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyB0aGUgemVybyBhZGRyZXNzLlxuICovXG5jb25zdCBpc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShoZXhBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvQWRkciA9ICgwLCBleHBvcnRzLnplcm9BZGRyZXNzKSgpO1xuICAgIHJldHVybiB6ZXJvQWRkciA9PT0gaGV4QWRkcmVzcztcbn07XG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBpc1plcm9BZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNaZXJvQWRkcmVzcyIsInplcm9BZGRyZXNzIiwiaW1wb3J0UHVibGljIiwicHJpdmF0ZVRvQWRkcmVzcyIsInByaXZhdGVUb1B1YmxpYyIsInB1YmxpY1RvQWRkcmVzcyIsInB1YlRvQWRkcmVzcyIsImlzVmFsaWRQdWJsaWMiLCJpc1ZhbGlkUHJpdmF0ZSIsImdlbmVyYXRlQWRkcmVzczIiLCJnZW5lcmF0ZUFkZHJlc3MiLCJpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzIiwidG9DaGVja3N1bUFkZHJlc3MiLCJpc1ZhbGlkQWRkcmVzcyIsIkFjY291bnQiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJleHRlcm5hbHNfMSIsInNlY3AyNTZrMV8xIiwiaW50ZXJuYWxfMSIsImNvbnN0YW50c18xIiwiYnl0ZXNfMSIsImhhc2hfMSIsImhlbHBlcnNfMSIsInR5cGVzXzEiLCJjb25zdHJ1Y3RvciIsIm5vbmNlIiwiQk4iLCJiYWxhbmNlIiwic3RhdGVSb290IiwiS0VDQ0FLMjU2X1JMUCIsImNvZGVIYXNoIiwiS0VDQ0FLMjU2X05VTEwiLCJfdmFsaWRhdGUiLCJmcm9tQWNjb3VudERhdGEiLCJhY2NvdW50RGF0YSIsInRvQnVmZmVyIiwidW5kZWZpbmVkIiwiZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50Iiwic2VyaWFsaXplZCIsInZhbHVlcyIsInJscCIsImRlY29kZSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiZnJvbVZhbHVlc0FycmF5IiwibHQiLCJsZW5ndGgiLCJyYXciLCJiblRvVW5wYWRkZWRCdWZmZXIiLCJzZXJpYWxpemUiLCJlbmNvZGUiLCJpc0NvbnRyYWN0IiwiZXF1YWxzIiwiaXNFbXB0eSIsImlzWmVybyIsImhleEFkZHJlc3MiLCJhc3NlcnRJc1N0cmluZyIsImUiLCJ0ZXN0IiwiZWlwMTE5MUNoYWluSWQiLCJhc3NlcnRJc0hleFN0cmluZyIsImFkZHJlc3MiLCJzdHJpcEhleFByZWZpeCIsInRvTG93ZXJDYXNlIiwicHJlZml4IiwiY2hhaW5JZCIsInRvVHlwZSIsIlR5cGVPdXRwdXQiLCJ0b1N0cmluZyIsImhhc2giLCJrZWNjYWtGcm9tU3RyaW5nIiwicmV0IiwiaSIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJmcm9tIiwiYXNzZXJ0SXNCdWZmZXIiLCJub25jZUJOIiwicmxwaGFzaCIsInNsaWNlIiwiQnVmZmVyIiwidG9BcnJheSIsInNhbHQiLCJpbml0Q29kZSIsImRlZmF1bHQiLCJrZWNjYWsyNTYiLCJjb25jYXQiLCJwcml2YXRlS2V5IiwicHJpdmF0ZUtleVZlcmlmeSIsInB1YmxpY0tleSIsInNhbml0aXplIiwicHVibGljS2V5VmVyaWZ5IiwicHViS2V5IiwicHVibGljS2V5Q29udmVydCIsImtlY2NhayIsInB1YmxpY0tleUNyZWF0ZSIsImFkZHJlc3NMZW5ndGgiLCJhZGRyIiwiemVyb3MiLCJidWZmZXJUb0hleCIsInplcm9BZGRyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/address.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/address.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Address = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-util/dist/account.js\");\nclass Address {\n    constructor(buf){\n        (0, assert_1.default)(buf.length === 20, \"Invalid address length\");\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */ static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */ static fromString(str) {\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), \"Invalid address\");\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */ static fromPublicKey(pubKey) {\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), \"Public key should be Buffer\");\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */ static fromPrivateKey(privateKey) {\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), \"Private key should be Buffer\");\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */ static generate(from, nonce) {\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */ static generate2(from, salt, initCode) {\n        (0, assert_1.default)(Buffer.isBuffer(salt));\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */ equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */ isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */ isPrecompileOrSystemAddress() {\n        const addressBN = new externals_1.BN(this.buf);\n        const rangeMin = new externals_1.BN(0);\n        const rangeMax = new externals_1.BN(\"ffff\", \"hex\");\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    }\n    /**\n     * Returns hex encoding of address.\n     */ toString() {\n        return \"0x\" + this.buf.toString(\"hex\");\n    }\n    /**\n     * Returns Buffer representation of address.\n     */ toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsV0FBV1IsZ0JBQWdCUyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQyxNQUFNRjtJQUNGTSxZQUFZQyxHQUFHLENBQUU7UUFDWixJQUFHTixTQUFTTyxPQUFPLEVBQUVELElBQUlFLE1BQU0sS0FBSyxJQUFJO1FBQ3pDLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtJQUNmO0lBQ0E7O0tBRUMsR0FDRCxPQUFPRyxPQUFPO1FBQ1YsT0FBTyxJQUFJVixRQUFRLENBQUMsR0FBR0ksUUFBUU8sS0FBSyxFQUFFO0lBQzFDO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0MsV0FBV0MsR0FBRyxFQUFFO1FBQ2xCLElBQUdaLFNBQVNPLE9BQU8sRUFBRSxDQUFDLEdBQUdILFVBQVVTLGNBQWMsRUFBRUQsTUFBTTtRQUMxRCxPQUFPLElBQUliLFFBQVEsQ0FBQyxHQUFHSSxRQUFRVyxRQUFRLEVBQUVGO0lBQzdDO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0csY0FBY0MsTUFBTSxFQUFFO1FBQ3hCLElBQUdoQixTQUFTTyxPQUFPLEVBQUVVLE9BQU9DLFFBQVEsQ0FBQ0YsU0FBUztRQUMvQyxNQUFNVixNQUFNLENBQUMsR0FBR0YsVUFBVWUsWUFBWSxFQUFFSDtRQUN4QyxPQUFPLElBQUlqQixRQUFRTztJQUN2QjtJQUNBOzs7S0FHQyxHQUNELE9BQU9jLGVBQWVDLFVBQVUsRUFBRTtRQUM3QixJQUFHckIsU0FBU08sT0FBTyxFQUFFVSxPQUFPQyxRQUFRLENBQUNHLGFBQWE7UUFDbkQsTUFBTWYsTUFBTSxDQUFDLEdBQUdGLFVBQVVrQixnQkFBZ0IsRUFBRUQ7UUFDNUMsT0FBTyxJQUFJdEIsUUFBUU87SUFDdkI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT2lCLFNBQVNDLElBQUksRUFBRUMsS0FBSyxFQUFFO1FBQ3hCLElBQUd6QixTQUFTTyxPQUFPLEVBQUVMLFlBQVl3QixFQUFFLENBQUNDLElBQUksQ0FBQ0Y7UUFDMUMsT0FBTyxJQUFJMUIsUUFBUSxDQUFDLEdBQUdLLFVBQVV3QixlQUFlLEVBQUVKLEtBQUtsQixHQUFHLEVBQUVtQixNQUFNSSxXQUFXLENBQUNaO0lBQ2xGO0lBQ0E7Ozs7O0tBS0MsR0FDRCxPQUFPYSxVQUFVTixJQUFJLEVBQUVPLElBQUksRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLElBQUdoQyxTQUFTTyxPQUFPLEVBQUVVLE9BQU9DLFFBQVEsQ0FBQ2E7UUFDckMsSUFBRy9CLFNBQVNPLE9BQU8sRUFBRVUsT0FBT0MsUUFBUSxDQUFDYztRQUN0QyxPQUFPLElBQUlqQyxRQUFRLENBQUMsR0FBR0ssVUFBVTZCLGdCQUFnQixFQUFFVCxLQUFLbEIsR0FBRyxFQUFFeUIsTUFBTUM7SUFDdkU7SUFDQTs7S0FFQyxHQUNERSxPQUFPQyxPQUFPLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQzdCLEdBQUcsQ0FBQzRCLE1BQU0sQ0FBQ0MsUUFBUTdCLEdBQUc7SUFDdEM7SUFDQTs7S0FFQyxHQUNEOEIsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDRixNQUFNLENBQUNuQyxRQUFRVSxJQUFJO0lBQ25DO0lBQ0E7OztLQUdDLEdBQ0Q0Qiw4QkFBOEI7UUFDMUIsTUFBTUMsWUFBWSxJQUFJcEMsWUFBWXdCLEVBQUUsQ0FBQyxJQUFJLENBQUNwQixHQUFHO1FBQzdDLE1BQU1pQyxXQUFXLElBQUlyQyxZQUFZd0IsRUFBRSxDQUFDO1FBQ3BDLE1BQU1jLFdBQVcsSUFBSXRDLFlBQVl3QixFQUFFLENBQUMsUUFBUTtRQUM1QyxPQUFPWSxVQUFVRyxHQUFHLENBQUNGLGFBQWFELFVBQVVJLEdBQUcsQ0FBQ0Y7SUFDcEQ7SUFDQTs7S0FFQyxHQUNERyxXQUFXO1FBQ1AsT0FBTyxPQUFPLElBQUksQ0FBQ3JDLEdBQUcsQ0FBQ3FDLFFBQVEsQ0FBQztJQUNwQztJQUNBOztLQUVDLEdBQ0Q3QixXQUFXO1FBQ1AsT0FBT0csT0FBT08sSUFBSSxDQUFDLElBQUksQ0FBQ2xCLEdBQUc7SUFDL0I7QUFDSjtBQUNBVCxlQUFlLEdBQUdFLFNBQ2xCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2FkZHJlc3MuanM/MzQzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBhY2NvdW50XzEgPSByZXF1aXJlKFwiLi9hY2NvdW50XCIpO1xuY2xhc3MgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShidWYubGVuZ3RoID09PSAyMCwgJ0ludmFsaWQgYWRkcmVzcyBsZW5ndGgnKTtcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBieXRlc18xLnplcm9zKSgyMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEFkZHJlc3Mgb2JqZWN0IGZyb20gYSBoZXgtZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0ciAtIEhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKCgwLCBhY2NvdW50XzEuaXNWYWxpZEFkZHJlc3MpKHN0ciksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBieXRlc18xLnRvQnVmZmVyKShzdHIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhZGRyZXNzIGZvciBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gICAgICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5XG4gICAgICovXG4gICAgc3RhdGljIGZyb21QdWJsaWNLZXkocHViS2V5KSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShCdWZmZXIuaXNCdWZmZXIocHViS2V5KSwgJ1B1YmxpYyBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICBjb25zdCBidWYgPSAoMCwgYWNjb3VudF8xLnB1YlRvQWRkcmVzcykocHViS2V5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGJ1Zik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleSksICdQcml2YXRlIGtleSBzaG91bGQgYmUgQnVmZmVyJyk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCBhY2NvdW50XzEucHJpdmF0ZVRvQWRkcmVzcykocHJpdmF0ZUtleSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhidWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGUoZnJvbSwgbm9uY2UpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGV4dGVybmFsc18xLkJOLmlzQk4obm9uY2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBhY2NvdW50XzEuZ2VuZXJhdGVBZGRyZXNzKShmcm9tLmJ1Ziwgbm9uY2UudG9BcnJheUxpa2UoQnVmZmVyKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBjb250cmFjdCBjcmVhdGVkIHVzaW5nIENSRUFURTIuXG4gICAgICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBzYWx0IEEgc2FsdFxuICAgICAqIEBwYXJhbSBpbml0Q29kZSBUaGUgaW5pdCBjb2RlIG9mIHRoZSBjb250cmFjdCBiZWluZyBjcmVhdGVkXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlMihmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHNhbHQpKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihpbml0Q29kZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MyKShmcm9tLmJ1Ziwgc2FsdCwgaW5pdENvZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyBlcXVhbCB0byBhbm90aGVyLlxuICAgICAqL1xuICAgIGVxdWFscyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5lcXVhbHMoYWRkcmVzcy5idWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyBhZGRyZXNzIHplcm8uXG4gICAgICovXG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoQWRkcmVzcy56ZXJvKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGFkZHJlc3MgaXMgaW4gdGhlIGFkZHJlc3MgcmFuZ2UgZGVmaW5lZFxuICAgICAqIGJ5IEVJUC0xMzUyXG4gICAgICovXG4gICAgaXNQcmVjb21waWxlT3JTeXN0ZW1BZGRyZXNzKCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzQk4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4odGhpcy5idWYpO1xuICAgICAgICBjb25zdCByYW5nZU1pbiA9IG5ldyBleHRlcm5hbHNfMS5CTigwKTtcbiAgICAgICAgY29uc3QgcmFuZ2VNYXggPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJ2ZmZmYnLCAnaGV4Jyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzQk4uZ3RlKHJhbmdlTWluKSAmJiBhZGRyZXNzQk4ubHRlKHJhbmdlTWF4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZXggZW5jb2Rpbmcgb2YgYWRkcmVzcy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9CdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJ1Zik7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFkZHJlc3MiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJhY2NvdW50XzEiLCJjb25zdHJ1Y3RvciIsImJ1ZiIsImRlZmF1bHQiLCJsZW5ndGgiLCJ6ZXJvIiwiemVyb3MiLCJmcm9tU3RyaW5nIiwic3RyIiwiaXNWYWxpZEFkZHJlc3MiLCJ0b0J1ZmZlciIsImZyb21QdWJsaWNLZXkiLCJwdWJLZXkiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInB1YlRvQWRkcmVzcyIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsInByaXZhdGVUb0FkZHJlc3MiLCJnZW5lcmF0ZSIsImZyb20iLCJub25jZSIsIkJOIiwiaXNCTiIsImdlbmVyYXRlQWRkcmVzcyIsInRvQXJyYXlMaWtlIiwiZ2VuZXJhdGUyIiwic2FsdCIsImluaXRDb2RlIiwiZ2VuZXJhdGVBZGRyZXNzMiIsImVxdWFscyIsImFkZHJlc3MiLCJpc1plcm8iLCJpc1ByZWNvbXBpbGVPclN5c3RlbUFkZHJlc3MiLCJhZGRyZXNzQk4iLCJyYW5nZU1pbiIsInJhbmdlTWF4IiwiZ3RlIiwibHRlIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/bytes.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/bytes.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */ const intToHex = function(i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */ const intToBuffer = function(i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), \"hex\");\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ const zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */ const setLength = function(msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthLeft = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthRight = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ const stripZeros = function(a) {\n    let first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */ const unpadBuffer = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */ const unpadArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */ const unpadHexString = function(a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */ const toBuffer = function(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === \"string\") {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), \"hex\");\n    }\n    if (typeof v === \"number\") {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (externals_1.BN.isBN(v)) {\n        if (v.isNeg()) {\n            throw new Error(`Cannot convert negative BN to buffer. Given: ${v}`);\n        }\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error(\"invalid type\");\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ const bufferToInt = function(buf) {\n    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ const bufferToHex = function(buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ const fromSigned = function(num) {\n    return new externals_1.BN(num).fromTwos(256);\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ const toUnsigned = function(num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ const addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : \"0x\" + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */ const toUtf8 = function(hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid non-even hex string input for toUtf8() provided\");\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, \"\"), \"hex\");\n    return bufferVal.toString(\"utf8\");\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ const baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString(\"hex\")}`;\n    } else if (ba instanceof Array) {\n        const array = [];\n        for(let i = 0; i < ba.length; i++){\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */ const validateNoLeadingZeroes = function(values) {\n    for (const [k, v] of Object.entries(values)){\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString(\"hex\")}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a)=>arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);\n    }\n    return arr.map((a)=>bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsK0JBQStCLEdBQUdBLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHNCQUFzQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyYSxNQUFNcUIsY0FBY0MsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMseUVBQVk7QUFDdkMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsdUVBQVc7QUFDckM7Ozs7Q0FJQyxHQUNELE1BQU1GLFdBQVcsU0FBVUssQ0FBQztJQUN4QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUFHO1FBQ25DLE1BQU0sSUFBSUcsTUFBTSxDQUFDLGtDQUFrQyxFQUFFSCxFQUFFLENBQUM7SUFDNUQ7SUFDQSxPQUFPLENBQUMsRUFBRSxFQUFFQSxFQUFFSSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ2hDO0FBQ0E3QixnQkFBZ0IsR0FBR29CO0FBQ25COzs7O0NBSUMsR0FDRCxNQUFNRCxjQUFjLFNBQVVNLENBQUM7SUFDM0IsTUFBTUssTUFBTSxDQUFDLEdBQUc5QixRQUFRb0IsUUFBUSxFQUFFSztJQUNsQyxPQUFPTSxPQUFPQyxJQUFJLENBQUMsQ0FBQyxHQUFHVCxXQUFXVSxTQUFTLEVBQUVILElBQUlJLEtBQUssQ0FBQyxLQUFLO0FBQ2hFO0FBQ0FsQyxtQkFB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Z0QsTUFBTUMsSUFBSSxDQUFDLENBQUMsR0FBRzFFLFFBQVFLLFFBQVEsRUFBRW1FLEVBQUUsQ0FBQy9DLEVBQUU7UUFDMUM7UUFDQSxPQUFPZ0Q7SUFDWDtBQUNKO0FBQ0F6RSxnQkFBZ0IsR0FBR0s7QUFDbkI7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsTUFBTUQsMEJBQTBCLFNBQVV1RSxNQUFNO0lBQzVDLEtBQUssTUFBTSxDQUFDQyxHQUFHekIsRUFBRSxJQUFJckQsT0FBTytFLE9BQU8sQ0FBQ0YsUUFBUztRQUN6QyxJQUFJeEIsTUFBTUMsYUFBYUQsRUFBRVgsTUFBTSxHQUFHLEtBQUtXLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRztZQUMvQyxNQUFNLElBQUl2QixNQUFNLENBQUMsRUFBRWdELEVBQUUsdUNBQXVDLEVBQUV6QixFQUFFdEIsUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUNyRjtJQUNKO0FBQ0o7QUFDQTdCLCtCQUErQixHQUFHSTtBQUNsQyxTQUFTRCxZQUFZMkUsR0FBRztJQUNwQixJQUFJLENBQUN4QixNQUFNQyxPQUFPLENBQUN1QixNQUFNO1FBQ3JCLE9BQU8vQyxPQUFPQyxJQUFJLENBQUM4QztJQUN2QjtJQUNBLE9BQU9BLElBQUlDLEdBQUcsQ0FBQyxDQUFDakMsSUFBTTNDLFlBQVkyQztBQUN0QztBQUNBOUMsbUJBQW1CLEdBQUdHO0FBQ3RCLFNBQVNELFlBQVk0RSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3hCLE1BQU1DLE9BQU8sQ0FBQ3VCLE1BQU07UUFDckIsT0FBT3RCLFdBQVd4QixJQUFJLENBQUM4QyxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJQSxNQUFNLEVBQUU7SUFDcEU7SUFDQSxPQUFPQSxJQUFJQyxHQUFHLENBQUMsQ0FBQ2pDLElBQU01QyxZQUFZNEM7QUFDdEM7QUFDQTlDLG1CQUFtQixHQUFHRSxhQUN0QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9ieXRlcy5qcz8xYjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWZBcnJUb0FyciA9IGV4cG9ydHMuYXJyVG9CdWZBcnIgPSBleHBvcnRzLnZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gZXhwb3J0cy5iYVRvSlNPTiA9IGV4cG9ydHMudG9VdGY4ID0gZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBleHBvcnRzLnRvVW5zaWduZWQgPSBleHBvcnRzLmZyb21TaWduZWQgPSBleHBvcnRzLmJ1ZmZlclRvSGV4ID0gZXhwb3J0cy5idWZmZXJUb0ludCA9IGV4cG9ydHMudG9CdWZmZXIgPSBleHBvcnRzLnVucGFkSGV4U3RyaW5nID0gZXhwb3J0cy51bnBhZEFycmF5ID0gZXhwb3J0cy51bnBhZEJ1ZmZlciA9IGV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBleHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnplcm9zID0gZXhwb3J0cy5pbnRUb0J1ZmZlciA9IGV4cG9ydHMuaW50VG9IZXggPSB2b2lkIDA7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgaW50VG9IZXggPSBmdW5jdGlvbiAoaSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaSkgfHwgaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBhbiBpbnZhbGlkIGludGVnZXIgdHlwZTogJHtpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtpLnRvU3RyaW5nKDE2KX1gO1xufTtcbmV4cG9ydHMuaW50VG9IZXggPSBpbnRUb0hleDtcbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuY29uc3QgaW50VG9CdWZmZXIgPSBmdW5jdGlvbiAoaSkge1xuICAgIGNvbnN0IGhleCA9ICgwLCBleHBvcnRzLmludFRvSGV4KShpKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGludGVybmFsXzEucGFkVG9FdmVuKShoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59O1xuZXhwb3J0cy5pbnRUb0J1ZmZlciA9IGludFRvQnVmZmVyO1xuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAqL1xuY29uc3QgemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbmV4cG9ydHMuemVyb3MgPSB6ZXJvcztcbi8qKlxuICogUGFkcyBhIGBCdWZmZXJgIHdpdGggemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBUcnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgaW5wdXQgaWYgaXRzIGxlbmd0aCBleGNlZWRzIGBsZW5ndGhgLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSByaWdodCB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGggPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgsIHJpZ2h0KSB7XG4gICAgY29uc3QgYnVmID0gKDAsIGV4cG9ydHMuemVyb3MpKGxlbmd0aCk7XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgICB9XG59O1xuLyoqXG4gKiBMZWZ0IFBhZHMgYSBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoTGVmdCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1zZyk7XG4gICAgcmV0dXJuIHNldExlbmd0aChtc2csIGxlbmd0aCwgZmFsc2UpO1xufTtcbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IHNldExlbmd0aExlZnQ7XG4vKipcbiAqIFJpZ2h0IFBhZHMgYSBgQnVmZmVyYCB3aXRoIHRyYWlsaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogaXQgdHJ1bmNhdGVzIHRoZSBlbmQgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobXNnKTtcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gc2V0TGVuZ3RoUmlnaHQ7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgLCBgU3RyaW5nYCBvciBgTnVtYmVyW11gLlxuICogQHBhcmFtIGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICovXG5jb25zdCBzdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgICBsZXQgZmlyc3QgPSBhWzBdO1xuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgICAgICBmaXJzdCA9IGFbMF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyKVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCB1bnBhZEJ1ZmZlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuZXhwb3J0cy51bnBhZEJ1ZmZlciA9IHVucGFkQnVmZmVyO1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYW4gYEFycmF5YCAob2YgbnVtYmVycykuXG4gKiBAcGFyYW0gYSAobnVtYmVyW10pXG4gKiBAcmV0dXJuIChudW1iZXJbXSlcbiAqL1xuY29uc3QgdW5wYWRBcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkQXJyYXkgPSB1bnBhZEFycmF5O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBoZXgtcHJlZml4ZWQgYFN0cmluZ2AuXG4gKiBAcGFyYW0gYSAoU3RyaW5nKVxuICogQHJldHVybiAoU3RyaW5nKVxuICovXG5jb25zdCB1bnBhZEhleFN0cmluZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoYSk7XG4gICAgYSA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkSGV4U3RyaW5nID0gdW5wYWRIZXhTdHJpbmc7XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuXG4gKiBJbnB1dHMgc3VwcG9ydGVkOiBgQnVmZmVyYCwgYFN0cmluZ2AgKGhleC1wcmVmaXhlZCksIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0c1xuICogd2l0aCBhIGB0b0FycmF5KClgIG9yIGB0b0J1ZmZlcigpYCBtZXRob2QuXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWVcbiAqL1xuY29uc3QgdG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKHYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogJHt2fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KSh2KSksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaW50VG9CdWZmZXIpKHYpO1xuICAgIH1cbiAgICBpZiAoZXh0ZXJuYWxzXzEuQk4uaXNCTih2KSkge1xuICAgICAgICBpZiAodi5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IG5lZ2F0aXZlIEJOIHRvIGJ1ZmZlci4gR2l2ZW46ICR7dn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH1cbiAgICBpZiAodi50b0FycmF5KSB7XG4gICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9XG4gICAgaWYgKHYudG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9CdWZmZXIoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG59O1xuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmAuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5jb25zdCBidWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBleHBvcnRzLnRvQnVmZmVyKShidWYpKS50b051bWJlcigpO1xufTtcbmV4cG9ydHMuYnVmZmVyVG9JbnQgPSBidWZmZXJUb0ludDtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgYDB4YC1wcmVmaXhlZCBoZXggYFN0cmluZ2AuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKi9cbmNvbnN0IGJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGJ1ZiA9ICgwLCBleHBvcnRzLnRvQnVmZmVyKShidWYpO1xuICAgIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gYnVmZmVyVG9IZXg7XG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtIFNpZ25lZCBpbnRlZ2VyIHZhbHVlXG4gKi9cbmNvbnN0IGZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbHNfMS5CTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnJvbVNpZ25lZDtcbi8qKlxuICogQ29udmVydHMgYSBgQk5gIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgaXQgYXMgYSBgQnVmZmVyYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtXG4gKi9cbmNvbnN0IHRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcbmV4cG9ydHMudG9VbnNpZ25lZCA9IHRvVW5zaWduZWQ7XG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIi5cbiAqL1xuY29uc3QgYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGludGVybmFsXzEuaXNIZXhQcmVmaXhlZCkoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBhZGRIZXhQcmVmaXg7XG4vKipcbiAqIFJldHVybnMgdGhlIHV0Zjggc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZyb20gYSBoZXggc3RyaW5nLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIElucHV0IDE6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICogSW5wdXQgMjogJzY1NzQ2ODY1NzI2NTc1NmQnXG4gKiBJbnB1dCAzOiAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjU3NDY4NjU3MjY1NzU2ZCdcbiAqXG4gKiBPdXRwdXQgKGFsbCAzIGlucHV0IHZhcmlhbnRzKTogJ2V0aGVyZXVtJ1xuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGhleCBzdHJpbmdzXG4gKiByZXByZXNlbnRpbmcgcXVhbnRpdGllcyBpbiBib3RoIGJpZyBlbmRpYW4gb3IgbGl0dGxlIGVuZGlhbiBub3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIEhleCBzdHJpbmcsIHNob3VsZCBiZSBgMHhgIHByZWZpeGVkXG4gKiBAcmV0dXJuIFV0Zjggc3RyaW5nXG4gKi9cbmNvbnN0IHRvVXRmOCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBjb25zdCB6ZXJvc1JlZ2V4cCA9IC9eKDAwKSt8KDAwKSskL2c7XG4gICAgaGV4ID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGhleCk7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub24tZXZlbiBoZXggc3RyaW5nIGlucHV0IGZvciB0b1V0ZjgoKSBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJWYWwgPSBCdWZmZXIuZnJvbShoZXgucmVwbGFjZSh6ZXJvc1JlZ2V4cCwgJycpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIGJ1ZmZlclZhbC50b1N0cmluZygndXRmOCcpO1xufTtcbmV4cG9ydHMudG9VdGY4ID0gdG9VdGY4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTi5cbiAqIEBwYXJhbSBiYSAoQnVmZmVyfEFycmF5KVxuICogQHJldHVybiAoQXJyYXl8U3RyaW5nfG51bGwpXG4gKi9cbmNvbnN0IGJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7YmEudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaCgoMCwgZXhwb3J0cy5iYVRvSlNPTikoYmFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbmV4cG9ydHMuYmFUb0pTT04gPSBiYVRvSlNPTjtcbi8qKlxuICogQ2hlY2tzIHByb3ZpZGVkIEJ1ZmZlcnMgZm9yIGxlYWRpbmcgemVyb2VzIGFuZCB0aHJvd3MgaWYgZm91bmQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogVmFsaWQgdmFsdWVzOiAweDEsIDB4LCAweDAxLCAweDEyMzRcbiAqIEludmFsaWQgdmFsdWVzOiAweDAsIDB4MDAsIDB4MDAxLCAweDAwMDFcbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHZhbGlkYXRpbmcgdGhhdCBSTFAgZW5jb2RlZCBpbnRlZ2VycyBjb21wbHkgd2l0aCB0aGUgcnVsZSB0aGF0IGFsbFxuICogaW50ZWdlciB2YWx1ZXMgZW5jb2RlZCB0byBSTFAgbXVzdCBiZSBpbiB0aGUgbW9zdCBjb21wYWN0IGZvcm0gYW5kIGNvbnRhaW4gbm8gbGVhZGluZyB6ZXJvIGJ5dGVzXG4gKiBAcGFyYW0gdmFsdWVzIEFuIG9iamVjdCBjb250YWluaW5nIHN0cmluZyBrZXlzIGFuZCBCdWZmZXIgdmFsdWVzXG4gKiBAdGhyb3dzIGlmIGFueSBwcm92aWRlZCB2YWx1ZSBpcyBmb3VuZCB0byBoYXZlIGxlYWRpbmcgemVybyBieXRlc1xuICovXG5jb25zdCB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdi5sZW5ndGggPiAwICYmIHZbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrfSBjYW5ub3QgaGF2ZSBsZWFkaW5nIHplcm9lcywgcmVjZWl2ZWQ6ICR7di50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzO1xuZnVuY3Rpb24gYXJyVG9CdWZBcnIoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBhcnJUb0J1ZkFycihhKSk7XG59XG5leHBvcnRzLmFyclRvQnVmQXJyID0gYXJyVG9CdWZBcnI7XG5mdW5jdGlvbiBidWZBcnJUb0FycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFyciAhPT0gbnVsbCAmJiBhcnIgIT09IHZvaWQgMCA/IGFyciA6IFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5tYXAoKGEpID0+IGJ1ZkFyclRvQXJyKGEpKTtcbn1cbmV4cG9ydHMuYnVmQXJyVG9BcnIgPSBidWZBcnJUb0Fycjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ1ZkFyclRvQXJyIiwiYXJyVG9CdWZBcnIiLCJ2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyIsImJhVG9KU09OIiwidG9VdGY4IiwiYWRkSGV4UHJlZml4IiwidG9VbnNpZ25lZCIsImZyb21TaWduZWQiLCJidWZmZXJUb0hleCIsImJ1ZmZlclRvSW50IiwidG9CdWZmZXIiLCJ1bnBhZEhleFN0cmluZyIsInVucGFkQXJyYXkiLCJ1bnBhZEJ1ZmZlciIsInNldExlbmd0aFJpZ2h0Iiwic2V0TGVuZ3RoTGVmdCIsInplcm9zIiwiaW50VG9CdWZmZXIiLCJpbnRUb0hleCIsImV4dGVybmFsc18xIiwicmVxdWlyZSIsImludGVybmFsXzEiLCJoZWxwZXJzXzEiLCJpIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwidG9TdHJpbmciLCJoZXgiLCJCdWZmZXIiLCJmcm9tIiwicGFkVG9FdmVuIiwic2xpY2UiLCJieXRlcyIsImFsbG9jVW5zYWZlIiwiZmlsbCIsInNldExlbmd0aCIsIm1zZyIsImxlbmd0aCIsInJpZ2h0IiwiYnVmIiwiY29weSIsImFzc2VydElzQnVmZmVyIiwic3RyaXBaZXJvcyIsImEiLCJmaXJzdCIsImFzc2VydElzQXJyYXkiLCJhc3NlcnRJc0hleFN0cmluZyIsInN0cmlwSGV4UHJlZml4IiwidiIsInVuZGVmaW5lZCIsImlzQnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5IiwiVWludDhBcnJheSIsImlzSGV4U3RyaW5nIiwiQk4iLCJpc0JOIiwiaXNOZWciLCJ0b0FycmF5TGlrZSIsInRvQXJyYXkiLCJ0b051bWJlciIsIm51bSIsImZyb21Ud29zIiwidG9Ud29zIiwic3RyIiwiaXNIZXhQcmVmaXhlZCIsInplcm9zUmVnZXhwIiwiYnVmZmVyVmFsIiwicmVwbGFjZSIsImJhIiwiYXJyYXkiLCJwdXNoIiwidmFsdWVzIiwiayIsImVudHJpZXMiLCJhcnIiLCJtYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/constants.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\n/**\n * 2^64-1\n */ exports.MAX_UINT64 = new externals_1.BN(\"ffffffffffffffff\", 16);\n/**\n * The max integer that the evm can handle (2^256-1)\n */ exports.MAX_INTEGER = new externals_1.BN(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n/**\n * 2^256\n */ exports.TWO_POW256 = new externals_1.BN(\"10000000000000000000000000000000000000000000000000000000000000000\", 16);\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, \"hex\"); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDek8sTUFBTVcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekM7O0NBRUMsR0FDRFosa0JBQWtCLEdBQUcsSUFBSWEsWUFBWUMsRUFBRSxDQUFDLG9CQUFvQjtBQUM1RDs7Q0FFQyxHQUNEZCxtQkFBbUIsR0FBRyxJQUFJYSxZQUFZQyxFQUFFLENBQUMsb0VBQW9FO0FBQzdHOztDQUVDLEdBQ0RkLGtCQUFrQixHQUFHLElBQUlhLFlBQVlDLEVBQUUsQ0FBQyxxRUFBcUU7QUFDN0c7O0NBRUMsR0FDRGQsd0JBQXdCLEdBQUc7QUFDM0I7O0NBRUMsR0FDREEsc0JBQXNCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUU8sZ0JBQWdCLEVBQUU7QUFDeEU7O0NBRUMsR0FDRFAsNkJBQTZCLEdBQUc7QUFDaEM7O0NBRUMsR0FDREEsMkJBQTJCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUUsscUJBQXFCLEVBQUU7QUFDbEY7O0NBRUMsR0FDREwsdUJBQXVCLEdBQUc7QUFDMUI7O0NBRUMsR0FDREEscUJBQXFCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUUcsZUFBZSxFQUFFLFFBQ3RFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2NvbnN0YW50cy5qcz9jMTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gZXhwb3J0cy5NQVhfVUlOVDY0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG4vKipcbiAqIDJeNjQtMVxuICovXG5leHBvcnRzLk1BWF9VSU5UNjQgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJ2ZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoZSBldm0gY2FuIGhhbmRsZSAoMl4yNTYtMSlcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IGV4dGVybmFsc18xLkJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5XG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiS0VDQ0FLMjU2X1JMUCIsIktFQ0NBSzI1Nl9STFBfUyIsIktFQ0NBSzI1Nl9STFBfQVJSQVkiLCJLRUNDQUsyNTZfUkxQX0FSUkFZX1MiLCJLRUNDQUsyNTZfTlVMTCIsIktFQ0NBSzI1Nl9OVUxMX1MiLCJUV09fUE9XMjU2IiwiTUFYX0lOVEVHRVIiLCJNQVhfVUlOVDY0IiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJCTiIsIkJ1ZmZlciIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/externals.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/externals.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlp = exports.BN = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nexports.BN = bn_js_1.default;\nconst rlp = __importStar(__webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\"));\nexports.rlp = rlp; //# sourceMappingURL=externals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvZXh0ZXJuYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Q0FJQyxHQUNELElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0EsSUFBSUksa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVMLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJVixVQUFVLEdBQUlVLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FuQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RRLFdBQVcsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDaEMsTUFBTUcsVUFBVUosZ0JBQWdCSyxtQkFBT0EsQ0FBQyxtREFBTztBQUMvQ0osVUFBVSxHQUFHRyxRQUFRRSxPQUFPO0FBQzVCLE1BQU1KLE1BQU1SLGFBQWFXLG1CQUFPQSxDQUFDLG1EQUFLO0FBQ3RDSixXQUFXLEdBQUdDLEtBQ2QscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvZXh0ZXJuYWxzLmpzP2M4NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJlLWV4cG9ydHMgY29tbW9ubHkgdXNlZCBtb2R1bGVzOlxuICogKiBFeHBvcnRzIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcyksIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKS5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmxwID0gZXhwb3J0cy5CTiA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmV4cG9ydHMuQk4gPSBibl9qc18xLmRlZmF1bHQ7XG5jb25zdCBybHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJscFwiKSk7XG5leHBvcnRzLnJscCA9IHJscDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVybmFscy5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsInJscCIsIkJOIiwiYm5fanNfMSIsInJlcXVpcmUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/externals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/hash.js":
/*!***************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/hash.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */ const keccak = function(a, bits = 256) {\n    (0, helpers_1.assertIsBuffer)(a);\n    switch(bits){\n        case 224:\n            {\n                return (0, keccak_1.keccak224)(a);\n            }\n        case 256:\n            {\n                return (0, keccak_1.keccak256)(a);\n            }\n        case 384:\n            {\n                return (0, keccak_1.keccak384)(a);\n            }\n        case 512:\n            {\n                return (0, keccak_1.keccak512)(a);\n            }\n        default:\n            {\n                throw new Error(`Invald algorithm: keccak${bits}`);\n            }\n    }\n};\nexports.keccak = keccak;\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */ const keccak256 = function(a) {\n    return (0, exports.keccak)(a);\n};\nexports.keccak256 = keccak256;\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromString = function(a, bits = 256) {\n    (0, helpers_1.assertIsString)(a);\n    const buf = Buffer.from(a, \"utf8\");\n    return (0, exports.keccak)(buf, bits);\n};\nexports.keccakFromString = keccakFromString;\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromHexString = function(a, bits = 256) {\n    (0, helpers_1.assertIsHexString)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromHexString = keccakFromHexString;\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */ const keccakFromArray = function(a, bits = 256) {\n    (0, helpers_1.assertIsArray)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromArray = keccakFromArray;\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */ const _sha256 = function(a) {\n    a = (0, bytes_1.toBuffer)(a);\n    return createHash(\"sha256\").update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */ const sha256 = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _sha256(a);\n};\nexports.sha256 = sha256;\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */ const sha256FromString = function(a) {\n    (0, helpers_1.assertIsString)(a);\n    return _sha256(a);\n};\nexports.sha256FromString = sha256FromString;\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */ const sha256FromArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return _sha256(a);\n};\nexports.sha256FromArray = sha256FromArray;\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */ const _ripemd160 = function(a, padded) {\n    a = (0, bytes_1.toBuffer)(a);\n    const hash = createHash(\"rmd160\").update(a).digest();\n    if (padded === true) {\n        return (0, bytes_1.setLengthLeft)(hash, 32);\n    } else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160 = function(a, padded) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160 = ripemd160;\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromString = function(a, padded) {\n    (0, helpers_1.assertIsString)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromString = ripemd160FromString;\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromArray = function(a, padded) {\n    (0, helpers_1.assertIsArray)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromArray = ripemd160FromArray;\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */ const rlphash = function(a) {\n    return (0, exports.keccak)(externals_1.rlp.encode(a));\n};\nexports.rlphash = rlphash; //# sourceMappingURL=hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EsMkJBQTJCLEdBQUdBLGlCQUFpQixHQUFHQSx1QkFBdUIsR0FBR0Esd0JBQXdCLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3BTLE1BQU1jLFdBQVdDLG1CQUFPQSxDQUFDLDBGQUE4QjtBQUN2RCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQzs7OztDQUlDLEdBQ0QsTUFBTUYsU0FBUyxTQUFVTyxDQUFDLEVBQUVDLE9BQU8sR0FBRztJQUNqQyxJQUFHRixVQUFVRyxjQUFjLEVBQUVGO0lBQzlCLE9BQVFDO1FBQ0osS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHUCxTQUFTUyxTQUFTLEVBQUVIO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTRixTQUFTLEVBQUVRO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTVSxTQUFTLEVBQUVKO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTVyxTQUFTLEVBQUVMO1lBQ25DO1FBQ0E7WUFBUztnQkFDTCxNQUFNLElBQUlNLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUwsS0FBSyxDQUFDO1lBQ3JEO0lBQ0o7QUFDSjtBQUNBckIsY0FBYyxHQUFHYTtBQUNq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Q0F0QywwQkFBMEIsR0FBR0c7QUFDN0I7OztDQUdDLEdBQ0QsTUFBTUQsVUFBVSxTQUFVa0IsQ0FBQztJQUN2QixPQUFPLENBQUMsR0FBR3BCLFFBQVFhLE1BQU0sRUFBRUksWUFBWXdCLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDdEI7QUFDdEQ7QUFDQXBCLGVBQWUsR0FBR0UsU0FDbEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcz9jOWEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ybHBoYXNoID0gZXhwb3J0cy5yaXBlbWQxNjBGcm9tQXJyYXkgPSBleHBvcnRzLnJpcGVtZDE2MEZyb21TdHJpbmcgPSBleHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMuc2hhMjU2RnJvbUFycmF5ID0gZXhwb3J0cy5zaGEyNTZGcm9tU3RyaW5nID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLmtlY2Nha0Zyb21BcnJheSA9IGV4cG9ydHMua2VjY2FrRnJvbUhleFN0cmluZyA9IGV4cG9ydHMua2VjY2FrRnJvbVN0cmluZyA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5rZWNjYWsgPSB2b2lkIDA7XG5jb25zdCBrZWNjYWtfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrXCIpO1xuY29uc3QgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSBCdWZmZXIgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmNvbnN0IGtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgIGNhc2UgMjI0OiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazIyNCkoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNTY6IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDM4NDoge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWtfMS5rZWNjYWszODQpKGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTEyOiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazUxMikoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWske2JpdHN9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5rZWNjYWsgPSBrZWNjYWs7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpLlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqL1xuY29uc3Qga2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShhKTtcbn07XG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1Njtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIHV0Zi04IHN0cmluZyBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKFN0cmluZylcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuY29uc3Qga2VjY2FrRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoYSk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oYSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShidWYsIGJpdHMpO1xufTtcbmV4cG9ydHMua2VjY2FrRnJvbVN0cmluZyA9IGtlY2Nha0Zyb21TdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYW4gMHgtcHJlZml4ZWQgc3RyaW5nIGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoU3RyaW5nKVxuICogQHBhcmFtIGJpdHMgKG51bWJlciA9IDI1NikgVGhlIEtlY2NhayB3aWR0aFxuICovXG5jb25zdCBrZWNjYWtGcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEsIGJpdHMgPSAyNTYpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShhKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSksIGJpdHMpO1xufTtcbmV4cG9ydHMua2VjY2FrRnJvbUhleFN0cmluZyA9IGtlY2Nha0Zyb21IZXhTdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSBudW1iZXIgYXJyYXkgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuY29uc3Qga2VjY2FrRnJvbUFycmF5ID0gZnVuY3Rpb24gKGEsIGJpdHMgPSAyNTYpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKCgwLCBieXRlc18xLnRvQnVmZmVyKShhKSwgYml0cyk7XG59O1xuZXhwb3J0cy5rZWNjYWtGcm9tQXJyYXkgPSBrZWNjYWtGcm9tQXJyYXk7XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYW4gaW5wdXQuXG4gKiBAcGFyYW0gIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSk7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYSBCdWZmZXIgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxuICovXG5jb25zdCBzaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHJldHVybiBfc2hhMjU2KGEpO1xufTtcbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgc3RyaW5nIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKHN0cmluZylcbiAqL1xuY29uc3Qgc2hhMjU2RnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuZXhwb3J0cy5zaGEyNTZGcm9tU3RyaW5nID0gc2hhMjU2RnJvbVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhIG51bWJlcltdIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKG51bWJlcltdKVxuICovXG5jb25zdCBzaGEyNTZGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuZXhwb3J0cy5zaGEyNTZGcm9tQXJyYXkgPSBzaGEyNTZGcm9tQXJyYXk7XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IF9yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgYSA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShhKTtcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICAgIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKGhhc2gsIDMyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBCdWZmZXIgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IHJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICByZXR1cm4gX3JpcGVtZDE2MChhLCBwYWRkZWQpO1xufTtcbmV4cG9ydHMucmlwZW1kMTYwID0gcmlwZW1kMTYwO1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIGEgc3RyaW5nIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKFN0cmluZylcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5jb25zdCByaXBlbWQxNjBGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGEpO1xuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XG59O1xuZXhwb3J0cy5yaXBlbWQxNjBGcm9tU3RyaW5nID0gcmlwZW1kMTYwRnJvbVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiBhIG51bWJlcltdIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKG51bWJlcltdKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IHJpcGVtZDE2MEZyb21BcnJheSA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XG59O1xuZXhwb3J0cy5yaXBlbWQxNjBGcm9tQXJyYXkgPSByaXBlbWQxNjBGcm9tQXJyYXk7XG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgaGFzaCBvZiB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YVxuICovXG5jb25zdCBybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShleHRlcm5hbHNfMS5ybHAuZW5jb2RlKGEpKTtcbn07XG5leHBvcnRzLnJscGhhc2ggPSBybHBoYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJybHBoYXNoIiwicmlwZW1kMTYwRnJvbUFycmF5IiwicmlwZW1kMTYwRnJvbVN0cmluZyIsInJpcGVtZDE2MCIsInNoYTI1NkZyb21BcnJheSIsInNoYTI1NkZyb21TdHJpbmciLCJzaGEyNTYiLCJrZWNjYWtGcm9tQXJyYXkiLCJrZWNjYWtGcm9tSGV4U3RyaW5nIiwia2VjY2FrRnJvbVN0cmluZyIsImtlY2NhazI1NiIsImtlY2NhayIsImtlY2Nha18xIiwicmVxdWlyZSIsImNyZWF0ZUhhc2giLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJoZWxwZXJzXzEiLCJhIiwiYml0cyIsImFzc2VydElzQnVmZmVyIiwia2VjY2FrMjI0Iiwia2VjY2FrMzg0Iiwia2VjY2FrNTEyIiwiRXJyb3IiLCJhc3NlcnRJc1N0cmluZyIsImJ1ZiIsIkJ1ZmZlciIsImZyb20iLCJhc3NlcnRJc0hleFN0cmluZyIsInRvQnVmZmVyIiwiYXNzZXJ0SXNBcnJheSIsIl9zaGEyNTYiLCJ1cGRhdGUiLCJkaWdlc3QiLCJfcmlwZW1kMTYwIiwicGFkZGVkIiwiaGFzaCIsInNldExlbmd0aExlZnQiLCJybHAiLCJlbmNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/helpers.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/helpers.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */ const assertIsHexString = function(input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */ const assertIsBuffer = function(input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */ const assertIsArray = function(input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */ const assertIsString = function(input) {\n    if (typeof input !== \"string\") {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMzRyxNQUFNTSxhQUFhQyxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN2Qzs7O0NBR0MsR0FDRCxNQUFNRixvQkFBb0IsU0FBVUcsS0FBSztJQUNyQyxJQUFJLENBQUMsQ0FBQyxHQUFHRixXQUFXRyxXQUFXLEVBQUVELFFBQVE7UUFDckMsTUFBTUUsTUFBTSxDQUFDLGlFQUFpRSxFQUFFRixNQUFNLENBQUM7UUFDdkYsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHlCQUF5QixHQUFHSztBQUM1Qjs7O0NBR0MsR0FDRCxNQUFNRCxpQkFBaUIsU0FBVUksS0FBSztJQUNsQyxJQUFJLENBQUNJLE9BQU9DLFFBQVEsQ0FBQ0wsUUFBUTtRQUN6QixNQUFNRSxNQUFNLENBQUMsZ0RBQWdELEVBQUVGLE1BQU0sQ0FBQztRQUN0RSxNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYsc0JBQXNCLEdBQUdJO0FBQ3pCOzs7Q0FHQyxHQUNELE1BQU1ELGdCQUFnQixTQUFVSyxLQUFLO0lBQ2pDLElBQUksQ0FBQ00sTUFBTUMsT0FBTyxDQUFDUCxRQUFRO1FBQ3ZCLE1BQU1FLE1BQU0sQ0FBQyx1REFBdUQsRUFBRUYsTUFBTSxDQUFDO1FBQzdFLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVixxQkFBcUIsR0FBR0c7QUFDeEI7OztDQUdDLEdBQ0QsTUFBTUQsaUJBQWlCLFNBQVVNLEtBQUs7SUFDbEMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsTUFBTUUsTUFBTSxDQUFDLGlEQUFpRCxFQUFFRixNQUFNLENBQUM7UUFDdkUsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHNCQUFzQixHQUFHRSxnQkFDekIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGVscGVycy5qcz80YmVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRJc1N0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNBcnJheSA9IGV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gdm9pZCAwO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuLyoqXG4gKiBUaHJvd3MgaWYgYSBzdHJpbmcgaXMgbm90IGhleCBwcmVmaXhlZFxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHN0cmluZyB0byBjaGVjayBoZXggcHJlZml4IG9mXG4gKi9cbmNvbnN0IGFzc2VydElzSGV4U3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCEoMCwgaW50ZXJuYWxfMS5pc0hleFN0cmluZykoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBhc3NlcnRJc0hleFN0cmluZztcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0IHZhbHVlIHRvIGNoZWNrXG4gKi9cbmNvbnN0IGFzc2VydElzQnVmZmVyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIEJ1ZmZlciBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzQnVmZmVyID0gYXNzZXJ0SXNCdWZmZXI7XG4vKipcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyW119IGlucHV0IHZhbHVlIHRvIGNoZWNrXG4gKi9cbmNvbnN0IGFzc2VydElzQXJyYXkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIG51bWJlciBhcnJheXMgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0FycmF5ID0gYXNzZXJ0SXNBcnJheTtcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHZhbHVlIHRvIGNoZWNrXG4gKi9cbmNvbnN0IGFzc2VydElzU3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgc3RyaW5ncyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gYXNzZXJ0SXNTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFzc2VydElzU3RyaW5nIiwiYXNzZXJ0SXNBcnJheSIsImFzc2VydElzQnVmZmVyIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJpbnRlcm5hbF8xIiwicmVxdWlyZSIsImlucHV0IiwiaXNIZXhTdHJpbmciLCJtc2ciLCJFcnJvciIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-util/dist/constants.js\"), exports);\n/**\n * Account class and helper functions\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-util/dist/account.js\"), exports);\n/**\n * Address type\n */ __exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/ethereumjs-util/dist/address.js\"), exports);\n/**\n * Hash functions\n */ __exportStar(__webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/ethereumjs-util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\"), exports);\n/**\n * Function for definining properties on an object\n */ __exportStar(__webpack_require__(/*! ./object */ \"(ssr)/./node_modules/ethereumjs-util/dist/object.js\"), exports);\n/**\n * External exports (BN, rlp)\n */ __exportStar(__webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\"), exports);\n/**\n * Helpful TypeScript types\n */ __exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\"), exports);\n/**\n * Export ethjs-util methods\n */ var internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nObject.defineProperty(exports, \"isHexPrefixed\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexPrefixed;\n    }\n}));\nObject.defineProperty(exports, \"stripHexPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.stripHexPrefix;\n    }\n}));\nObject.defineProperty(exports, \"padToEven\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.padToEven;\n    }\n}));\nObject.defineProperty(exports, \"getBinarySize\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getBinarySize;\n    }\n}));\nObject.defineProperty(exports, \"arrayContainsArray\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.arrayContainsArray;\n    }\n}));\nObject.defineProperty(exports, \"toAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.toAscii;\n    }\n}));\nObject.defineProperty(exports, \"fromUtf8\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromUtf8;\n    }\n}));\nObject.defineProperty(exports, \"fromAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromAscii;\n    }\n}));\nObject.defineProperty(exports, \"getKeys\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getKeys;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexString;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RMLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUNoTzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsMkVBQWEsR0FBR2hCO0FBQ3JDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyx1RUFBVyxHQUFHaEI7QUFDbkM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLHVFQUFXLEdBQUdoQjtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsaUVBQVEsR0FBR2hCO0FBQ2hDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywyRUFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLG1FQUFTLEdBQUdoQjtBQUNqQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMscUVBQVUsR0FBR2hCO0FBQ2xDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywyRUFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLG1FQUFTLEdBQUdoQjtBQUNqQzs7Q0FFQyxHQUNELElBQUlpQixhQUFhRCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUNyQ2hDLGlEQUFnRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0YsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVIL0Isa0RBQWlEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXSCxjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUg5Qiw2Q0FBNEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdKLFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSDdCLGlEQUFnRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0wsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVINUIsc0RBQXFEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXTixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0STNCLDJDQUEwQztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1AsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hIMUIsNENBQTJDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXUixRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEh6Qiw2Q0FBNEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdULFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSHhCLDJDQUEwQztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1YsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hIdkIsK0NBQThDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXWCxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDeEgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanM/MDhiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0S2V5cyA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZXhwb3J0cy5wYWRUb0V2ZW4gPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5pc0hleFByZWZpeGVkID0gdm9pZCAwO1xuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEFjY291bnQgY2xhc3MgYW5kIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBBZGRyZXNzIHR5cGVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FkZHJlc3NcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIYXNoIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEVDRFNBIHNpZ25hdHVyZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmF0dXJlXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgQnVmZmVycywgYnl0ZSBhcnJheXMsIGV0Yy5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRnVuY3Rpb24gZm9yIGRlZmluaW5pbmcgcHJvcGVydGllcyBvbiBhbiBvYmplY3RcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEV4dGVybmFsIGV4cG9ydHMgKEJOLCBybHApXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHRlcm5hbHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIZWxwZnVsIFR5cGVTY3JpcHQgdHlwZXNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRXhwb3J0IGV0aGpzLXV0aWwgbWV0aG9kc1xuICovXG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhQcmVmaXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5pc0hleFByZWZpeGVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaXBIZXhQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYWRUb0V2ZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEucGFkVG9FdmVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmluYXJ5U2l6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRCaW5hcnlTaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXJyYXlDb250YWluc0FycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmFycmF5Q29udGFpbnNBcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQXNjaWlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEudG9Bc2NpaTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21VdGY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmZyb21VdGY4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbUFzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmZyb21Bc2NpaTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEtleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZ2V0S2V5czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGV4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJpc0hleFN0cmluZyIsImdldEtleXMiLCJmcm9tQXNjaWkiLCJmcm9tVXRmOCIsInRvQXNjaWkiLCJhcnJheUNvbnRhaW5zQXJyYXkiLCJnZXRCaW5hcnlTaXplIiwicGFkVG9FdmVuIiwic3RyaXBIZXhQcmVmaXgiLCJpc0hleFByZWZpeGVkIiwicmVxdWlyZSIsImludGVybmFsXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/internal.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/internal.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */ function isHexPrefixed(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === \"0\" && str[1] === \"x\";\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */ const stripHexPrefix = (str)=>{\n    if (typeof str !== \"string\") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */ function padToEven(value) {\n    let a = value;\n    if (typeof a !== \"string\") {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2) a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */ function getBinarySize(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[getBinarySize] method requires input type 'string', recieved ${typeof str}`);\n    }\n    return Buffer.byteLength(str, \"utf8\");\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */ function arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some ? \"some\" : \"every\"]((value)=>superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */ function toAscii(hex) {\n    let str = \"\";\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") i = 2;\n    for(; i < l; i += 2){\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */ function fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, \"utf8\");\n    return `0x${padToEven(str.toString(\"hex\")).replace(/^0+|0+$/g, \"\")}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */ function fromAscii(stringValue) {\n    let hex = \"\";\n    for(let i = 0; i < stringValue.length; i++){\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */ function getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for(let i = 0; i < params.length; i++){\n        let value = params[i][key];\n        if (allowEmpty && !value) {\n            value = \"\";\n        } else if (typeof value !== \"string\") {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n    if (length && value.length !== 2 + 2 * length) return false;\n    return true;\n}\nexports.isHexString = isHexString; //# sourceMappingURL=internal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxlQUFlLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ2hPOzs7OztDQUtDLEdBQ0QsU0FBU1csY0FBY0MsR0FBRztJQUN0QixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QixNQUFNLElBQUlDLE1BQU0sQ0FBQywyREFBMkQsRUFBRSxPQUFPRCxJQUFJLENBQUM7SUFDOUY7SUFDQSxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUs7QUFDeEM7QUFDQVoscUJBQXFCLEdBQUdXO0FBQ3hCOzs7O0NBSUMsR0FDRCxNQUFNRCxpQkFBaUIsQ0FBQ0U7SUFDcEIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJQyxNQUFNLENBQUMsdURBQXVELEVBQUUsT0FBT0QsSUFBSSxDQUFDO0lBQzFGLE9BQU9ELGNBQWNDLE9BQU9BLElBQUlFLEtBQUssQ0FBQyxLQUFLRjtBQUMvQztBQUNBWixzQkFBc0IsR0FBR1U7QUFDekI7Ozs7Q0FJQyxHQUNELFNBQVNELFVBQVVSLEtBQUs7SUFDcEIsSUFBSWMsSUFBSWQ7SUFDUixJQUFJLE9BQU9jLE1BQU0sVUFBVTtRQUN2QixNQUFNLElBQUlGLE1BQU0sQ0FBQyxrREFBa0QsRUFBRSxPQUFPRSxFQUFFLENBQUM7SUFDbkY7SUFDQSxJQUFJQSxFQUFFQyxNQUFNLEdBQUcsR0FDWEQsSUFBSSxDQUFDLENBQUMsRUFBRUEsRUFBRSxDQUFDO0lB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YyxDQUFDekMsT0FBTztZQUN0QkEsUUFBUTtRQUNaLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDaEMsTUFBTSxJQUFJWSxNQUFNLENBQUMsK0NBQStDLEVBQUUsT0FBT1osTUFBTSxDQUFDO1FBQ3BGO1FBQ0EwQyxPQUFPQyxJQUFJLENBQUMzQztJQUNoQjtJQUNBLE9BQU8wQztBQUNYO0FBQ0EzQyxlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFlBQVlELEtBQUssRUFBRWUsTUFBTTtJQUM5QixJQUFJLE9BQU9mLFVBQVUsWUFBWSxDQUFDQSxNQUFNNEMsS0FBSyxDQUFDLHFCQUMxQyxPQUFPO0lBQ1gsSUFBSTdCLFVBQVVmLE1BQU1lLE1BQU0sS0FBSyxJQUFJLElBQUlBLFFBQ25DLE9BQU87SUFDWCxPQUFPO0FBQ1g7QUFDQWhCLG1CQUFtQixHQUFHRSxhQUN0QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbnRlcm5hbC5qcz8wZmY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcblRoZSBNSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTYgTmljayBEb2Rzb24uIG5pY2tkb2Rzb24uY29tXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRLZXlzID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy50b0FzY2lpID0gZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSB2b2lkIDA7XG4vKipcbiAqIFJldHVybnMgYSBgQm9vbGVhbmAgb24gd2hldGhlciBvciBub3QgdGhlIGEgYFN0cmluZ2Agc3RhcnRzIHdpdGggJzB4J1xuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJuIGEgYm9vbGVhbiBpZiBpdCBpcyBvciBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAdGhyb3dzIGlmIHRoZSBzdHIgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2lzSGV4UHJlZml4ZWRdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJbMF0gPT09ICcwJyAmJiBzdHJbMV0gPT09ICd4Jztcbn1cbmV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IGlzSGV4UHJlZml4ZWQ7XG4vKipcbiAqIFJlbW92ZXMgJzB4JyBmcm9tIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgcHJlc2VudFxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHZhbHVlXG4gKiBAcmV0dXJucyB0aGUgc3RyaW5nIHdpdGhvdXQgMHggcHJlZml4XG4gKi9cbmNvbnN0IHN0cmlwSGV4UHJlZml4ID0gKHN0cikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbc3RyaXBIZXhQcmVmaXhdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59O1xuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgICBsZXQgYSA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbcGFkVG9FdmVuXSB2YWx1ZSBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIGF9YCk7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAlIDIpXG4gICAgICAgIGEgPSBgMCR7YX1gO1xuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5wYWRUb0V2ZW4gPSBwYWRUb0V2ZW47XG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEJpbmFyeVNpemVdIG1ldGhvZCByZXF1aXJlcyBpbnB1dCB0eXBlICdzdHJpbmcnLCByZWNpZXZlZCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5leHBvcnRzLmdldEJpbmFyeVNpemUgPSBnZXRCaW5hcnlTaXplO1xuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0gc3VwZXJzZXRcbiAqIEBwYXJhbSBzdWJzZXRcbiAqXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdXBlcnNldCcgdG8gYmUgYW4gYXJyYXksIGdvdCB0eXBlICcke3R5cGVvZiBzdXBlcnNldH0nYCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYXJyYXlDb250YWluc0FycmF5XSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgJ3N1YnNldCcgdG8gYmUgYW4gYXJyYXksIGdvdCB0eXBlICcke3R5cGVvZiBzdWJzZXR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2V0W3NvbWUgPyAnc29tZScgOiAnZXZlcnknXSgodmFsdWUpID0+IHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDApO1xufVxuZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBhcnJheUNvbnRhaW5zQXJyYXk7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXRzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4JylcbiAgICAgICAgaSA9IDI7XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnRvQXNjaWkgPSB0b0FzY2lpO1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHJpbmdcbiAqIEBwYXJhbSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gICAgY29uc3Qgc3RyID0gQnVmZmVyLmZyb20oc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG4gICAgcmV0dXJuIGAweCR7cGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpfWA7XG59XG5leHBvcnRzLmZyb21VdGY4ID0gZnJvbVV0Zjg7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBwYXJhbSAgc3RyaW5nXG4gKiBAcGFyYW0gIG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zICBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjb25zdCBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyBgMCR7bn1gIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4fWA7XG59XG5leHBvcnRzLmZyb21Bc2NpaSA9IGZyb21Bc2NpaTtcbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGdldEtleXMoW3thOiAnMScsIGI6ICcyJ30sIHthOiAnMycsIGI6ICc0J31dLCAnYScpID0+IFsnMScsICczJ11cbiAqYGBgYFxuICogQHBhcmFtICBwYXJhbXNcbiAqIEBwYXJhbSAga2V5XG4gKiBAcGFyYW0gIGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRLZXlzXSBtZXRob2QgZXhwZWN0cyBpbnB1dCAncGFyYW1zJyB0byBiZSBhbiBhcnJheSwgZ290ICR7dHlwZW9mIHBhcmFtc31gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdrZXknIHRvIGJlIHR5cGUgJ3N0cmluZycsIGdvdCAke3R5cGVvZiBwYXJhbXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldO1xuICAgICAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFiaSAtIGV4cGVjdGVkIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0S2V5cyA9IGdldEtleXM7XG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAgdmFsdWVcbiAqIEBwYXJhbSAgbGVuZ3RoXG4gKiBAcmV0dXJucyAgb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNIZXhTdHJpbmciLCJnZXRLZXlzIiwiZnJvbUFzY2lpIiwiZnJvbVV0ZjgiLCJ0b0FzY2lpIiwiYXJyYXlDb250YWluc0FycmF5IiwiZ2V0QmluYXJ5U2l6ZSIsInBhZFRvRXZlbiIsInN0cmlwSGV4UHJlZml4IiwiaXNIZXhQcmVmaXhlZCIsInN0ciIsIkVycm9yIiwic2xpY2UiLCJhIiwibGVuZ3RoIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsInN1cGVyc2V0Iiwic3Vic2V0Iiwic29tZSIsIkFycmF5IiwiaXNBcnJheSIsImluZGV4T2YiLCJoZXgiLCJpIiwibCIsInN1YnN0cmluZyIsImNvZGUiLCJwYXJzZUludCIsInN1YnN0ciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN0cmluZ1ZhbHVlIiwiZnJvbSIsInRvU3RyaW5nIiwicmVwbGFjZSIsImNoYXJDb2RlQXQiLCJuIiwicGFyYW1zIiwia2V5IiwiYWxsb3dFbXB0eSIsInJlc3VsdCIsInB1c2giLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/object.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/object.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defineProperties = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */ const defineProperties = function(self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function(label = false) {\n        if (label) {\n            const obj = {};\n            self._fields.forEach((field)=>{\n                obj[field] = `0x${self[field].toString(\"hex\")}`;\n            });\n            return obj;\n        }\n        return (0, bytes_1.baToJSON)(self.raw);\n    };\n    self.serialize = function serialize() {\n        return externals_1.rlp.encode(self.raw);\n    };\n    fields.forEach((field, i)=>{\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = (0, bytes_1.toBuffer)(v);\n            if (v.toString(\"hex\") === \"00\" && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = (0, bytes_1.unpadBuffer)(v);\n                (0, assert_1.default)(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);\n            } else if (!(field.allowZero && v.length === 0) && field.length) {\n                (0, assert_1.default)(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === \"string\") {\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), \"hex\");\n        }\n        if (Buffer.isBuffer(data)) {\n            data = externals_1.rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error(\"wrong number of fields in data\");\n            }\n            // make sure all the items are buffers\n            data.forEach((d, i)=>{\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n            });\n        } else if (typeof data === \"object\") {\n            const keys = Object.keys(data);\n            fields.forEach((field)=>{\n                if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n            });\n        } else {\n            throw new Error(\"invalid data\");\n        }\n    }\n};\nexports.defineProperties = defineProperties; //# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFdBQVdSLGdCQUFnQlMsbUJBQU9BLENBQUMsc0JBQVE7QUFDakQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMseUVBQVk7QUFDdkMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsbUVBQVM7QUFDakM7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU1GLG1CQUFtQixTQUFVTSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsSUFBSTtJQUNqREYsS0FBS0csR0FBRyxHQUFHLEVBQUU7SUFDYkgsS0FBS0ksT0FBTyxHQUFHLEVBQUU7SUFDakIsc0JBQXNCO0lBQ3RCSixLQUFLSyxNQUFNLEdBQUcsU0FBVUMsUUFBUSxLQUFLO1FBQ2pDLElBQUlBLE9BQU87WUFDUCxNQUFNQyxNQUFNLENBQUM7WUFDYlAsS0FBS0ksT0FBTyxDQUFDSSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ2xCRixHQUFHLENBQUNFLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRVQsSUFBSSxDQUFDUyxNQUFNLENBQUNDLFFBQVEsQ0FBQyxPQUFPLENBQUM7WUFDbkQ7WUFDQSxPQUFPSDtRQUNYO1FBQ0EsT0FBTyxDQUFDLEdBQUdSLFFBQVFZLFFBQVEsRUFBRVgsS0FBS0csR0FBRztJQUN6QztJQUNBSCxLQUFLWSxTQUFTLEdBQUcsU0FBU0E7UUFDdEIsT0FBT2QsWUFBWWUsR0FB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QUNTLE1BQU1RLElBQUksQ0FBQyxHQUFHZixJQUFJLENBQUNPLE1BQU1RLElBQUksQ0FBQztnQkFDdkMsSUFBSXlCLEtBQUtDLE9BQU8sQ0FBQ2xDLE1BQU13QixLQUFLLE1BQU0sQ0FBQyxHQUMvQmpDLElBQUksQ0FBQ1MsTUFBTXdCLEtBQUssQ0FBQyxHQUFHL0IsSUFBSSxDQUFDTyxNQUFNd0IsS0FBSyxDQUFDO1lBQzdDO1FBQ0osT0FDSztZQUNELE1BQU0sSUFBSU8sTUFBTTtRQUNwQjtJQUNKO0FBQ0o7QUFDQWhELHdCQUF3QixHQUFHRSxrQkFDM0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvb2JqZWN0LmpzPzRkNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICAgIHNlbGYucmF3ID0gW107XG4gICAgc2VsZi5fZmllbGRzID0gW107XG4gICAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIG9ialtmaWVsZF0gPSBgMHgke3NlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5iYVRvSlNPTikoc2VsZi5yYXcpO1xuICAgIH07XG4gICAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbHNfMS5ybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCwgaSkgPT4ge1xuICAgICAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmF3W2ldO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICAgICAgICB2ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHYpO1xuICAgICAgICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2ID0gKDAsIGJ5dGVzXzEudW5wYWRCdWZmZXIpKHYpO1xuICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsIGBUaGUgZmllbGQgJHtmaWVsZC5uYW1lfSBtdXN0IG5vdCBoYXZlIG1vcmUgJHtmaWVsZC5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsIGBUaGUgZmllbGQgJHtmaWVsZC5uYW1lfSBtdXN0IGhhdmUgYnl0ZSBsZW5ndGggb2YgJHtmaWVsZC5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgICAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGRhdGEpLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IGV4dGVybmFsc18xLnJscC5kZWNvZGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSIsImV4dGVybmFsc18xIiwiYnl0ZXNfMSIsInNlbGYiLCJmaWVsZHMiLCJkYXRhIiwicmF3IiwiX2ZpZWxkcyIsInRvSlNPTiIsImxhYmVsIiwib2JqIiwiZm9yRWFjaCIsImZpZWxkIiwidG9TdHJpbmciLCJiYVRvSlNPTiIsInNlcmlhbGl6ZSIsInJscCIsImVuY29kZSIsImkiLCJwdXNoIiwibmFtZSIsImdldHRlciIsInNldHRlciIsInYiLCJ0b0J1ZmZlciIsImFsbG93WmVybyIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwiYWxsb3dMZXNzIiwibGVuZ3RoIiwidW5wYWRCdWZmZXIiLCJkZWZhdWx0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImdldCIsInNldCIsImFsaWFzIiwiZnJvbSIsInN0cmlwSGV4UHJlZml4IiwiaXNCdWZmZXIiLCJkZWNvZGUiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImQiLCJrZXlzIiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/signature.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/signature.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    const { signature, recid: recovery } = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey);\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === \"number\") {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n        }\n        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return {\n            r,\n            s,\n            v\n        };\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return {\n        r,\n        s,\n        v\n    };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    const vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (vBN.eqn(0) || vBN.eqn(1)) return (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    const rec = new externals_1.BN(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Recovered public key\n */ const ecrecover = function(msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32)\n    ], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);\n    return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toRpcSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32),\n        (0, bytes_1.toBuffer)(v)\n    ]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toCompactSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);\n    let ss = s;\n    if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(ss, 32)\n    ]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */ const fromRpcSig = function(sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(64));\n    } else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;\n        s[0] &= 0x7f;\n    } else {\n        throw new Error(\"Invalid signature length\");\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v,\n        r,\n        s\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {\n    const SECP256K1_N_DIV_2 = new externals_1.BN(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16);\n    const SECP256K1_N = new externals_1.BN(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBN = new externals_1.BN(r);\n    const sBN = new externals_1.BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ const hashPersonalMessage = function(message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, \"utf-8\");\n    return (0, hash_1.keccak)(Buffer.concat([\n        prefix,\n        message\n    ]));\n};\nexports.hashPersonalMessage = hashPersonalMessage; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUNsSyxNQUFNUyxjQUFjQyxtQkFBT0EsQ0FBQyxnR0FBaUM7QUFDN0QsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsaUVBQVE7QUFDL0IsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsdUVBQVc7QUFDckMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsU0FBU0YsT0FBT1EsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE9BQU87SUFDeEMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLE9BQU9DLFFBQVEsRUFBRSxHQUFHLENBQUMsR0FBR1osWUFBWWEsU0FBUyxFQUFFTixTQUFTQztJQUMzRSxNQUFNTSxJQUFJQyxPQUFPQyxJQUFJLENBQUNOLFVBQVVPLEtBQUssQ0FBQyxHQUFHO0lBQ3pDLE1BQU1DLElBQUlILE9BQU9DLElBQUksQ0FBQ04sVUFBVU8sS0FBSyxDQUFDLElBQUk7SUFDMUMsSUFBSSxDQUFDUixXQUFXLE9BQU9BLFlBQVksVUFBVTtRQUN6QywyR0FBMkc7UUFDM0csSUFBSUEsV0FBVyxDQUFDVSxPQUFPQyxhQUFhLENBQUNYLFVBQVU7WUFDM0MsTUFBTSxJQUFJWSxNQUFNO1FBQ3BCO1FBQ0EsTUFBTUMsSUFBSWIsVUFBVUcsV0FBWUgsQ0FBQUEsVUFBVSxJQUFJLEVBQUMsSUFBS0csV0FBVztRQUMvRCxPQUFPO1lBQUVFO1lBQUdJO1lB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UVYsTUFBTSxDQUFDLENBQUMsRUFBRTtJQUNoRixPQUFPLENBQUMsR0FBRzdDLE9BQU8wRCxNQUFNLEVBQUUvQyxPQUFPc0IsTUFBTSxDQUFDO1FBQUN3QjtRQUFRRjtLQUFRO0FBQzdEO0FBQ0FwRSwyQkFBMkIsR0FBR0UscUJBQzlCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NpZ25hdHVyZS5qcz9mYjI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZXhwb3J0cy5mcm9tUnBjU2lnID0gZXhwb3J0cy50b0NvbXBhY3RTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZnVuY3Rpb24gZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSwgcmVjaWQ6IHJlY292ZXJ5IH0gPSAoMCwgc2VjcDI1NmsxXzEuZWNkc2FTaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCByID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKTtcbiAgICBpZiAoIWNoYWluSWQgfHwgdHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIHJldHVybiBsZWdhY3kgdHlwZSBFQ0RTQVNpZ25hdHVyZSAoZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBFQ0RTQVNpZ25hdHVyZUJ1ZmZlciB0byBoYW5kbGUgbGFyZ2UgY2hhaW5JZHMpXG4gICAgICAgIGlmIChjaGFpbklkICYmICFOdW1iZXIuaXNTYWZlSW50ZWdlcihjaGFpbklkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIGlucHV0IHR5cGUpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IGNoYWluSWQgPyByZWNvdmVyeSArIChjaGFpbklkICogMiArIDM1KSA6IHJlY292ZXJ5ICsgMjc7XG4gICAgICAgIHJldHVybiB7IHIsIHMsIHYgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZEJOID0gKDAsIHR5cGVzXzEudG9UeXBlKShjaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIGNvbnN0IHYgPSBjaGFpbklkQk4ubXVsbigyKS5hZGRuKDM1KS5hZGRuKHJlY292ZXJ5KS50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIHJldHVybiB7IHIsIHMsIHYgfTtcbn1cbmV4cG9ydHMuZWNzaWduID0gZWNzaWduO1xuZnVuY3Rpb24gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkge1xuICAgIGNvbnN0IHZCTiA9ICgwLCB0eXBlc18xLnRvVHlwZSkodiwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICBpZiAodkJOLmVxbigwKSB8fCB2Qk4uZXFuKDEpKVxuICAgICAgICByZXR1cm4gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gdkJOLnN1Ym4oMjcpO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbklkQk4gPSAoMCwgdHlwZXNfMS50b1R5cGUpKGNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgcmV0dXJuIHZCTi5zdWIoY2hhaW5JZEJOLm11bG4oMikuYWRkbigzNSkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgY29uc3QgcmVjID0gbmV3IGV4dGVybmFsc18xLkJOKHJlY292ZXJ5KTtcbiAgICByZXR1cm4gcmVjLmVxbigwKSB8fCByZWMuZXFuKDEpO1xufVxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlLlxuICogTk9URTogQWNjZXB0cyBgdiA9PSAwIHwgdiA9PSAxYCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnNcbiAqIEByZXR1cm5zIFJlY292ZXJlZCBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IGVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMildLCA2NCk7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbmRlclB1YktleSA9ICgwLCBzZWNwMjU2azFfMS5lY2RzYVJlY292ZXIpKHNpZ25hdHVyZSwgcmVjb3ZlcnkudG9OdW1iZXIoKSwgbXNnSGFzaCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKSk7XG59O1xuZXhwb3J0cy5lY3JlY292ZXIgPSBlY3JlY292ZXI7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZC5cbiAqIE5PVEU6IEFjY2VwdHMgYHYgPT0gMCB8IHYgPT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMiksICgwLCBieXRlc18xLnRvQnVmZmVyKSh2KV0pKTtcbn07XG5leHBvcnRzLnRvUnBjU2lnID0gdG9ScGNTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChFSVAtMjA5OCkuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09IDAgfCB2ID09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmNvbnN0IHRvQ29tcGFjdFNpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHZuID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuTnVtYmVyKTtcbiAgICBsZXQgc3MgPSBzO1xuICAgIGlmICgodm4gPiAyOCAmJiB2biAlIDIgPT09IDEpIHx8IHZuID09PSAxIHx8IHZuID09PSAyOCkge1xuICAgICAgICBzcyA9IEJ1ZmZlci5mcm9tKHMpO1xuICAgICAgICBzc1swXSB8PSAweDgwO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkoc3MsIDMyKV0pKTtcbn07XG5leHBvcnRzLnRvQ29tcGFjdFNpZyA9IHRvQ29tcGFjdFNpZztcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogTk9URTogQWZ0ZXIgRUlQMTU1OSwgYHZgIGNvdWxkIGJlIGAwYCBvciBgMWAgYnV0IHRoaXMgZnVuY3Rpb24gYXNzdW1lc1xuICogaXQncyBhIHNpZ25lZCBtZXNzYWdlIChFSVAtMTkxIG9yIEVJUC03MTIpIGFkZGluZyBgMjdgIGF0IHRoZSBlbmQuIFJlbW92ZSBpZiBuZWVkZWQuXG4gKi9cbmNvbnN0IGZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgY29uc3QgYnVmID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHNpZyk7XG4gICAgbGV0IHI7XG4gICAgbGV0IHM7XG4gICAgbGV0IHY7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPj0gNjUpIHtcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoNjQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgLy8gQ29tcGFjdCBTaWduYXR1cmUgUmVwcmVzZW50YXRpb24gKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjA5OClcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoMzIsIDMzKSkgPj4gNztcbiAgICAgICAgc1swXSAmPSAweDdmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgICB9XG4gICAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXG4gICAgaWYgKHYgPCAyNykge1xuICAgICAgICB2ICs9IDI3O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2LFxuICAgICAgICByLFxuICAgICAgICBzLFxuICAgIH07XG59O1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnJvbVJwY1NpZztcbi8qKlxuICogVmFsaWRhdGUgYSBFQ0RTQSBzaWduYXR1cmUuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09IDAgfCB2ID09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkT3JMYXRlciA9IHRydWUsIGNoYWluSWQpIHtcbiAgICBjb25zdCBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBleHRlcm5hbHNfMS5CTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgICBjb25zdCBTRUNQMjU2SzFfTiA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcbiAgICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJCTiA9IG5ldyBleHRlcm5hbHNfMS5CTihyKTtcbiAgICBjb25zdCBzQk4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4ocyk7XG4gICAgaWYgKHJCTi5pc1plcm8oKSB8fCByQk4uZ3QoU0VDUDI1NksxX04pIHx8IHNCTi5pc1plcm8oKSB8fCBzQk4uZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JOLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBpc1ZhbGlkU2lnbmF0dXJlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqL1xuY29uc3QgaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobWVzc2FnZSk7XG4gICAgY29uc3QgcHJlZml4ID0gQnVmZmVyLmZyb20oYFxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4ke21lc3NhZ2UubGVuZ3RofWAsICd1dGYtOCcpO1xuICAgIHJldHVybiAoMCwgaGFzaF8xLmtlY2NhaykoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGhhc2hQZXJzb25hbE1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzaFBlcnNvbmFsTWVzc2FnZSIsImlzVmFsaWRTaWduYXR1cmUiLCJmcm9tUnBjU2lnIiwidG9Db21wYWN0U2lnIiwidG9ScGNTaWciLCJlY3JlY292ZXIiLCJlY3NpZ24iLCJzZWNwMjU2azFfMSIsInJlcXVpcmUiLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJoYXNoXzEiLCJoZWxwZXJzXzEiLCJ0eXBlc18xIiwibXNnSGFzaCIsInByaXZhdGVLZXkiLCJjaGFpbklkIiwic2lnbmF0dXJlIiwicmVjaWQiLCJyZWNvdmVyeSIsImVjZHNhU2lnbiIsInIiLCJCdWZmZXIiLCJmcm9tIiwic2xpY2UiLCJzIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwidiIsImNoYWluSWRCTiIsInRvVHlwZSIsIlR5cGVPdXRwdXQiLCJCTiIsIm11bG4iLCJhZGRuIiwidG9BcnJheUxpa2UiLCJjYWxjdWxhdGVTaWdSZWNvdmVyeSIsInZCTiIsImVxbiIsInN1Ym4iLCJzdWIiLCJpc1ZhbGlkU2lnUmVjb3ZlcnkiLCJyZWMiLCJjb25jYXQiLCJzZXRMZW5ndGhMZWZ0Iiwic2VuZGVyUHViS2V5IiwiZWNkc2FSZWNvdmVyIiwidG9OdW1iZXIiLCJwdWJsaWNLZXlDb252ZXJ0IiwiYnVmZmVyVG9IZXgiLCJ0b0J1ZmZlciIsInZuIiwic3MiLCJzaWciLCJidWYiLCJsZW5ndGgiLCJidWZmZXJUb0ludCIsImhvbWVzdGVhZE9yTGF0ZXIiLCJTRUNQMjU2SzFfTl9ESVZfMiIsIlNFQ1AyNTZLMV9OIiwickJOIiwic0JOIiwiaXNaZXJvIiwiZ3QiLCJjbXAiLCJtZXNzYWdlIiwiYXNzZXJ0SXNCdWZmZXIiLCJwcmVmaXgiLCJrZWNjYWsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/types.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */ function bnToHex(value) {\n    return `0x${value.toString(16)}`;\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */ function bnToUnpaddedBuffer(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */ function bnToRlp(value) {\n    return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */ var TypeOutput;\n(function(TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === \"string\" && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    } else if (typeof input === \"number\" && !Number.isSafeInteger(input)) {\n        throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    if (outputType === TypeOutput.Buffer) {\n        return output;\n    } else if (outputType === TypeOutput.BN) {\n        return new externals_1.BN(output);\n    } else if (outputType === TypeOutput.Number) {\n        const bn = new externals_1.BN(output);\n        const max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n        }\n        return bn.toNumber();\n    } else {\n        // outputType === TypeOutput.PrefixedHexString\n        return `0x${output.toString(\"hex\")}`;\n    }\n}\nexports.toType = toType; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0Esa0JBQWtCLEdBQUdBLGVBQWUsR0FBR0EsMEJBQTBCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzVHLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHlFQUFZO0FBQ3ZDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLG1FQUFTO0FBQ2pDOztDQUVDLEdBQ0QsU0FBU0YsUUFBUUwsS0FBSztJQUNsQixPQUFPLENBQUMsRUFBRSxFQUFFQSxNQUFNVSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ3BDO0FBQ0FYLGVBQWUsR0FBR007QUFDbEI7Ozs7Q0FJQyxHQUNELFNBQVNELG1CQUFtQkosS0FBSztJQUM3Qiw0REFBNEQ7SUFDNUQsc0RBQXNEO0lBQ3RELE9BQU8sQ0FBQyxHQUFHUyxRQUFRRSxXQUFXLEVBQUVYLE1BQU1ZLFdBQVcsQ0FBQ0M7QUFDdEQ7QUFDQWQsMEJBQTBCLEdBQUdLO0FBQzdCOzs7Q0FHQyxHQUNELFNBQVNELFFBQVFILEtBQUs7SUFDbEIsT0FBT0ksbUJBQW1CSjtBQUM5QjtBQUNBRCxlQUFlLEdBQUdJO0FBQ2xCOztDQUVDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHO0lBQ25DQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDdEQsR0FBR0EsYUFBYUgsUUFBUUcsVUFBVSxJQUFLSCxDQUFBQSxrQkFBa0IsR0FBRyxDQUFDO0FBQzdELFNBQVNFLE9BQU9hLEtBQUssRUFBRUMsVUFBVTtJQUM3QixJQUFJRCxVQUFVLE1BQU07UUFDaEIsT0FBTztJQUNYO0lBQ0EsSUFBSUEsVUFBVUUsV0FBVztRQUNyQixPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFPRixVQUFVLFlBQVksQ0FBQyxDQUFDLEdBQUdOLFdBQVdTLFdBQVcsRUFBRUgsUUFBUTtRQUNsRSxNQUFNLElBQUlJLE1BQU0sQ0FBQyxtREFBbUQsRUFBRUosTUFBTSxDQUFDO0lBQ2pGLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0ssT0FBT0MsYUFBYSxDQUFDTixRQUFRO1FBQ2hFLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUNBLE1BQU1HLFNBQVMsQ0FBQyxHQUFHWixRQUFRYSxRQUFRLEVBQUVSO0lBQ3JDLElBQUlDLGVBQWViLFdBQVdXLE1BQU0sRUFBRTtRQUNsQyxPQUFPUTtJQUNYLE9BQ0ssSUFBSU4sZUFBZWIsV0FBV3FCLEVBQUUsRUFBRTtRQUNuQyxPQUFPLElBQUlqQixZQUFZaUIsRUFBRSxDQUFDRjtJQUM5QixPQUNLLElBQUlOLGVBQWViLFdBQVdpQixNQUFNLEVBQUU7UUFDdkMsTUFBTUssS0FBSyxJQUFJbEIsWUFBWWlCLEVBQUUsQ0FBQ0Y7UUFDOUIsTUFBTUksTUFBTSxJQUFJbkIsWUFBWWlCLEVBQUUsQ0FBQ0osT0FBT08sZ0JBQWdCLENBQUNoQixRQUFRO1FBQy9ELElBQUljLEdBQUdHLEVBQUUsQ0FBQ0YsTUFBTTtZQUNaLE1BQU0sSUFBSVAsTUFBTTtRQUNwQjtRQUNBLE9BQU9NLEdBQUdJLFFBQVE7SUFDdEIsT0FDSztRQUNELDhDQUE4QztRQUM5QyxPQUFPLENBQUMsRUFBRSxFQUFFUCxPQUFPWCxRQUFRLENBQUMsT0FBTyxDQUFDO0lBQ3hDO0FBQ0o7QUFDQVgsY0FBYyxHQUFHRSxRQUNqQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC90eXBlcy5qcz8zYWYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1R5cGUgPSBleHBvcnRzLlR5cGVPdXRwdXQgPSBleHBvcnRzLmJuVG9SbHAgPSBleHBvcnRzLmJuVG9VbnBhZGRlZEJ1ZmZlciA9IGV4cG9ydHMuYm5Ub0hleCA9IHZvaWQgMDtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IEJOIHRvIDB4LXByZWZpeGVkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJuVG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZS50b1N0cmluZygxNil9YDtcbn1cbmV4cG9ydHMuYm5Ub0hleCA9IGJuVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgdmFsdWUgZnJvbSBCTiB0byBhbiB1bnBhZGRlZCBCdWZmZXJcbiAqICh1c2VmdWwgZm9yIFJMUCB0cmFuc3BvcnQpXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY29udmVydFxuICovXG5mdW5jdGlvbiBiblRvVW5wYWRkZWRCdWZmZXIodmFsdWUpIHtcbiAgICAvLyBVc2luZyBgYm4udG9BcnJheUxpa2UoQnVmZmVyKWAgaW5zdGVhZCBvZiBgYm4udG9CdWZmZXIoKWBcbiAgICAvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGJyb3dzZXJpZnkgYW5kIHNpbWlsYXIgdG9vbHNcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEudW5wYWRCdWZmZXIpKHZhbHVlLnRvQXJyYXlMaWtlKEJ1ZmZlcikpO1xufVxuZXhwb3J0cy5iblRvVW5wYWRkZWRCdWZmZXIgPSBiblRvVW5wYWRkZWRCdWZmZXI7XG4vKipcbiAqIERlcHJlY2F0ZWQgYWxpYXMgZm9yIHtAbGluayBiblRvVW5wYWRkZWRCdWZmZXJ9XG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBiblRvUmxwKHZhbHVlKSB7XG4gICAgcmV0dXJuIGJuVG9VbnBhZGRlZEJ1ZmZlcih2YWx1ZSk7XG59XG5leHBvcnRzLmJuVG9SbHAgPSBiblRvUmxwO1xuLyoqXG4gKiBUeXBlIG91dHB1dCBvcHRpb25zXG4gKi9cbnZhciBUeXBlT3V0cHV0O1xuKGZ1bmN0aW9uIChUeXBlT3V0cHV0KSB7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiTnVtYmVyXCJdID0gMF0gPSBcIk51bWJlclwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIkJOXCJdID0gMV0gPSBcIkJOXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQnVmZmVyXCJdID0gMl0gPSBcIkJ1ZmZlclwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIlByZWZpeGVkSGV4U3RyaW5nXCJdID0gM10gPSBcIlByZWZpeGVkSGV4U3RyaW5nXCI7XG59KShUeXBlT3V0cHV0ID0gZXhwb3J0cy5UeXBlT3V0cHV0IHx8IChleHBvcnRzLlR5cGVPdXRwdXQgPSB7fSkpO1xuZnVuY3Rpb24gdG9UeXBlKGlucHV0LCBvdXRwdXRUeXBlKSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiAhKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIDB4LXByZWZpeCwgZ2l2ZW46ICR7aW5wdXR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGlucHV0KTtcbiAgICBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5CTikge1xuICAgICAgICByZXR1cm4gbmV3IGV4dGVybmFsc18xLkJOKG91dHB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGJuID0gbmV3IGV4dGVybmFsc18xLkJOKG91dHB1dCk7XG4gICAgICAgIGNvbnN0IG1heCA9IG5ldyBleHRlcm5hbHNfMS5CTihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGJuLmd0KG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gTUFYX1NBRkVfSU5URUdFUiAocGxlYXNlIHVzZSBhbiBhbHRlcm5hdGl2ZSBvdXRwdXQgdHlwZSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm4udG9OdW1iZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuUHJlZml4ZWRIZXhTdHJpbmdcbiAgICAgICAgcmV0dXJuIGAweCR7b3V0cHV0LnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgIH1cbn1cbmV4cG9ydHMudG9UeXBlID0gdG9UeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidG9UeXBlIiwiVHlwZU91dHB1dCIsImJuVG9SbHAiLCJiblRvVW5wYWRkZWRCdWZmZXIiLCJiblRvSGV4IiwiZXh0ZXJuYWxzXzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSIsImJ5dGVzXzEiLCJ0b1N0cmluZyIsInVucGFkQnVmZmVyIiwidG9BcnJheUxpa2UiLCJCdWZmZXIiLCJpbnB1dCIsIm91dHB1dFR5cGUiLCJ1bmRlZmluZWQiLCJpc0hleFN0cmluZyIsIkVycm9yIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm91dHB1dCIsInRvQnVmZmVyIiwiQk4iLCJibiIsIm1heCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJndCIsInRvTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/types.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blocto";
exports.ids = ["vendor-chunks/@blocto"];
exports.modules = {

/***/ "(ssr)/./node_modules/@blocto/sdk/dist/blocto-sdk.module.js":
/*!************************************************************!*\
  !*** ./node_modules/@blocto/sdk/dist/blocto-sdk.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* Version: 0.5.5 - August 14, 2023 10:23:52 */ /******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ \nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return BloctoSDK;\n    }\n});\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// instead invariant from package, since all error will throw on production\nfunction invariant(condition, format) {\n    if (!condition) {\n        throw new Error(format);\n    }\n}\n// local storage version naming rule: [milestone].[patch]\nvar KEY_SESSION;\n(function(KEY_SESSION) {\n    KEY_SESSION[\"prod\"] = \"BLOCTO_SDK\";\n    KEY_SESSION[\"dev\"] = \"BLOCTO_SDK_DEV\";\n    KEY_SESSION[\"staging\"] = \"BLOCTO_SDK_STAGING\";\n})(KEY_SESSION || (KEY_SESSION = {}));\nvar CHAIN;\n(function(CHAIN) {\n    CHAIN[\"ETHEREUM\"] = \"ethereum\";\n    CHAIN[\"SOLANA\"] = \"solana\";\n    CHAIN[\"APTOS\"] = \"aptos\";\n})(CHAIN || (CHAIN = {}));\nclass MemoryStorage {\n    constructor(){\n        this.storage = {};\n    }\n    getItem(key) {\n        return this[key] || null;\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n}\nconst memoryStorage =  false ? 0 : new MemoryStorage();\nconst isSupported = ()=>{\n    if (true) {\n        return false;\n    }\n    try {\n        window.sessionStorage.setItem(\"local_storage_supported\", \"1\");\n        const result = window.sessionStorage.getItem(\"local_storage_supported\");\n        window.sessionStorage.removeItem(\"local_storage_supported\");\n        return result === \"1\";\n    } catch (error) {\n        return false;\n    }\n};\nconst storage = isSupported() ? window.sessionStorage : memoryStorage;\nconst getItem = (key, defaultValue = null)=>{\n    const value = storage.getItem(key);\n    try {\n        return value && JSON.parse(value) || defaultValue;\n    } catch (SyntaxError) {\n        return value || defaultValue;\n    }\n};\nconst setItem = (key, value)=>storage.setItem(key, typeof value === \"string\" ? value : JSON.stringify(value));\nconst removeItem = (key)=>{\n    setItem(key, \"\"); // Due to some versions of browser bug can't removeItem correctly.\n    storage.removeItem(key);\n};\n/**\n * @param {keys.KEY_SESSION} key - key to retrieve the data\n * @returns {ProviderSession | null} ProviderSession | null\n * @description\n * Get ProviderSession from storage.\n * If the data is expired, will remove the data and return null\n */ const getAccountStorage = (key)=>{\n    const rawAccountStorage = getItem(key, null);\n    if (!rawAccountStorage) return null;\n    // compare the expiry time of the item with the current time\n    if (new Date().getTime() > rawAccountStorage.expiry || rawAccountStorage.v !== SDK_VERSION) {\n        removeItem(key);\n        return null;\n    }\n    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;\n};\n/**\n  @param {keys.KEY_SESSION} key - key to store the data\n  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated\n  {\n    connected?: boolean;\n    code?: string | null;\n    accounts: Record<string, string[] | undefined>;\n  }\n  @param {number} expiry - expiry time of the data\n*/ const setAccountStorage = (key, data, expiry)=>{\n    var _a, _b, _c;\n    const rawAccountStorage = getItem(key);\n    const newAccountStorage = {\n        data: {\n            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),\n            connected: !!((data === null || data === void 0 ? void 0 : data.code) || ((_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.code)),\n            accounts: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.accounts), data === null || data === void 0 ? void 0 : data.accounts)\n        },\n        expiry: expiry || (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) || new Date().getTime() + LOGIN_PERSISTING_TIME,\n        v: SDK_VERSION\n    };\n    setItem(key, newAccountStorage);\n    return;\n};\nconst getChainAddress = (key, chain)=>{\n    var _a, _b;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts[chain]) || null;\n};\nconst setChainAddress = (key, chain, account)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: account\n        }\n    });\n    return;\n};\nconst removeChainAddress = (key, chain)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: undefined\n        }\n    });\n    return;\n};\n/* eth series constants begin */ const ETH_RPC_LIST = {\n    // This is the list of public RPC endpoints that we known to be working\n    // Used to help developers did not set up their own RPC endpoints\n    // BSC mainnet\n    56: \"https://bsc-dataseed1.binance.org\",\n    // BSC testnet\n    97: \"https://data-seed-prebsc-1-s1.binance.org:8545\",\n    // Polygon Mainnet\n    137: \"https://rpc-mainnet.maticvigil.com/\",\n    // Polygon Testnet\n    80001: \"https://rpc-mumbai.matic.today/\",\n    // Avalanche Mainnet\n    43114: \"https://api.avax.network/ext/bc/C/rpc\",\n    // Avalanche Fuji Testnet\n    43113: \"https://api.avax-test.network/ext/bc/C/rpc\",\n    // Arbitrum Mainnet\n    42161: \"https://arb1.arbitrum.io/rpc\",\n    // Arbitrum Testnet\n    421613: \"https://endpoints.omniatech.io/v1/arbitrum/goerli/public\",\n    // Optimism Mainnet\n    10: \"https://mainnet.optimism.io\",\n    // Optimism Goerli Testnet\n    420: \"https://goerli.optimism.io\"\n};\nconst ETH_ENV_WALLET_SERVER_MAPPING = {\n    prod: \"https://wallet-v2.blocto.app\",\n    staging: \"https://wallet-v2-staging.blocto.app\",\n    dev: \"https://wallet-v2-dev.blocto.app\"\n};\nconst ETH_SESSION_KEY_MAPPING = {\n    prod: KEY_SESSION.prod,\n    staging: KEY_SESSION.staging,\n    dev: KEY_SESSION.dev\n};\n/* eth series constants end */ /* sol constants begin */ const SOL_NET = {\n    MainnetBeta: \"mainnet-beta\",\n    Testnet: \"testnet\",\n    Devnet: \"devnet\"\n};\nconst SOL_NET_SERVER_MAPPING = {\n    [SOL_NET.MainnetBeta]: \"https://wallet-v2.blocto.app\",\n    [SOL_NET.Devnet]: \"https://wallet-v2-dev.blocto.app\",\n    [SOL_NET.Testnet]: \"https://wallet-v2-dev.blocto.app\"\n};\nconst SOL_SESSION_KEY_MAPPING = {\n    [SOL_NET.MainnetBeta]: KEY_SESSION.prod,\n    [SOL_NET.Devnet]: KEY_SESSION.dev,\n    [SOL_NET.Testnet]: KEY_SESSION.dev\n};\n/* sol constants end */ /* aptos constants begin */ const APT_SESSION_KEY_MAPPING = {\n    1: KEY_SESSION.prod,\n    2: KEY_SESSION.dev,\n    3: KEY_SESSION.dev,\n    4: KEY_SESSION.dev,\n    5: KEY_SESSION.staging\n};\nconst APT_CHAIN_ID_SERVER_MAPPING = {\n    // MAINNET\n    1: \"https://wallet-v2.blocto.app\",\n    // TESTNET\n    2: \"https://wallet-v2-dev.blocto.app\",\n    // DEVNET\n    3: \"https://wallet-v2-dev.blocto.app\",\n    // TESTING\n    4: \"https://wallet-v2-dev.blocto.app\",\n    // PREMAINNET\n    5: \"https://wallet-v2-staging.blocto.app\"\n};\nvar WalletAdapterNetwork;\n(function(WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n    WalletAdapterNetwork[\"Testing\"] = \"testing\";\n    WalletAdapterNetwork[\"Premainnet\"] = \"premainnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\nconst APT_CHAIN_ID_NAME_MAPPING = {\n    1: WalletAdapterNetwork.Mainnet,\n    2: WalletAdapterNetwork.Testnet,\n    3: WalletAdapterNetwork.Devnet,\n    4: WalletAdapterNetwork.Testing,\n    5: WalletAdapterNetwork.Premainnet\n};\nconst APT_CHAIN_ID_RPC_MAPPING = {\n    1: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n    2: \"https://fullnode.testnet.aptoslabs.com/v1\",\n    3: \"https://fullnode.devnet.aptoslabs.com/v1\",\n    4: \"\",\n    5: \"https://premainnet.aptosdev.com/v1\"\n};\n/* aptos constants end */ const EIP1193_EVENTS = [\n    \"connect\",\n    \"disconnect\",\n    \"message\",\n    \"chainChanged\",\n    \"accountsChanged\"\n];\n// Preserve login for 1 day\nconst LOGIN_PERSISTING_TIME = 86400 * 1000;\nconst DEFAULT_APP_ID = \"00000000-0000-0000-0000-000000000000\";\n// Will inject the version of the SDK by rollup versionInjector during build time\nconst SDK_VERSION = \"0.5.5\";\n// The root class for all providers\nclass BloctoProvider {\n    constructor(){\n        this.isBlocto = true;\n        this.isConnecting = false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.eventListeners = {};\n        // alias removeListener\n        this.off = this.removeListener;\n        // init event listeners\n        EIP1193_EVENTS.forEach((event)=>{\n            this.eventListeners[event] = [];\n        });\n        this.appId = DEFAULT_APP_ID;\n    }\n    // implement by children\n    // eslint-disable-next-line\n    request(payload) {\n        return __awaiter(this, void 0, void 0, function*() {});\n    }\n    on(event, listener) {\n        if (!EIP1193_EVENTS.includes(event)) return;\n        this.eventListeners[event].push(listener);\n    }\n    // @todo: implement it\n    // eslint-disable-next-line\n    once() {}\n    removeListener(event, listener) {\n        const listeners = this.eventListeners[event];\n        const index = listeners.findIndex((item)=>item === listener);\n        if (index !== -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n}\nconst IFRAME_STYLE = \"width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;\";\nfunction createFrame(url) {\n    const frame = document.createElement(\"iframe\");\n    frame.setAttribute(\"src\", url);\n    frame.setAttribute(\"style\", IFRAME_STYLE);\n    return frame;\n}\nfunction attachFrame(frame) {\n    document.body.appendChild(frame);\n}\nfunction detatchFrame(frame) {\n    const parentNode = frame && frame.parentNode;\n    if (parentNode && parentNode.removeChild instanceof Function) {\n        parentNode.removeChild(frame);\n    }\n}\nvar addSelfRemovableHandler = (eventType, handler, target = window)=>{\n    function listener(e) {\n        const removeEventListener = ()=>target.removeEventListener(eventType, listener);\n        handler(e, removeEventListener);\n    }\n    target.addEventListener(eventType, listener);\n};\nfunction responseSessionGuard(response, key, disconnectHandler) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (response.status === 403 || response.status === 401) {\n            if (disconnectHandler) {\n                disconnectHandler();\n            }\n            removeItem(key);\n        }\n        if (!response.ok) {\n            const data = yield response.json();\n            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || \"unknown error\");\n            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;\n            throw e;\n        }\n        return response.json();\n    });\n}\nconst isEmail = (value)=>/\\S+@\\S+\\.\\S+/.test(value);\nconst isValidTransaction = (transaction)=>typeof transaction === \"object\" && transaction !== null && \"from\" in transaction;\nconst isValidTransactions = (transactions)=>Array.isArray(transactions) && transactions.every((tx)=>isValidTransaction(tx));\nfunction getEvmSupport() {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { networks } = yield fetch(\"https://api.blocto.app/networks/evm\").then((response)=>response.json());\n        const evmSupportMap = networks.reduce((a, v)=>Object.assign(Object.assign({}, a), {\n                [v.chain_id]: v\n            }), {});\n        return evmSupportMap;\n    });\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar dist = {};\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _assertThisInitialized(self1) {\n    if (self1 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self1;\n}\nfunction _possibleConstructorReturn(self1, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self1);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct$1()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nvar classes = {};\nvar fastSafeStringify = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(obj, replacer, spacer);\n        } else {\n            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(classes, \"__esModule\", {\n    value: true\n});\nclasses.EthereumProviderError = classes.EthereumRpcError = void 0;\nvar fast_safe_stringify_1 = fastSafeStringify;\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n * Permits any integer error code.\n */ var EthereumRpcError = /*#__PURE__*/ function(_Error) {\n    _inherits(EthereumRpcError, _Error);\n    var _super = _createSuper(EthereumRpcError);\n    function EthereumRpcError(code, message, data) {\n        var _this;\n        _classCallCheck(this, EthereumRpcError);\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string.');\n        }\n        _this = _super.call(this, message);\n        _this.code = code;\n        if (data !== undefined) {\n            _this.data = data;\n        }\n        return _this;\n    }\n    /**\n   * Returns a plain object with all public class properties.\n   */ _createClass(EthereumRpcError, [\n        {\n            key: \"serialize\",\n            value: function serialize() {\n                var serialized = {\n                    code: this.code,\n                    message: this.message\n                };\n                if (this.data !== undefined) {\n                    serialized.data = this.data;\n                }\n                if (this.stack) {\n                    serialized.stack = this.stack;\n                }\n                return serialized;\n            }\n        },\n        {\n            key: \"toString\",\n            value: function toString() {\n                return fast_safe_stringify_1[\"default\"](this.serialize(), stringifyReplacer, 2);\n            }\n        }\n    ]);\n    return EthereumRpcError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nclasses.EthereumRpcError = EthereumRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ var EthereumProviderError = /*#__PURE__*/ function(_EthereumRpcError) {\n    _inherits(EthereumProviderError, _EthereumRpcError);\n    var _super2 = _createSuper(EthereumProviderError);\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */ function EthereumProviderError(code, message, data) {\n        _classCallCheck(this, EthereumProviderError);\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        return _super2.call(this, code, message, data);\n    }\n    return _createClass(EthereumProviderError);\n}(EthereumRpcError);\nclasses.EthereumProviderError = EthereumProviderError;\n// Internal\nfunction isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\nvar utils = {};\nvar errorConstants = {};\nObject.defineProperty(errorConstants, \"__esModule\", {\n    value: true\n});\nerrorConstants.errorValues = errorConstants.errorCodes = void 0;\nerrorConstants.errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nerrorConstants.errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\n(function(exports1) {\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.serializeError = exports1.isValidCode = exports1.getMessageFromCode = exports1.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n    var error_constants_1 = errorConstants;\n    var classes_1 = classes;\n    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\n    var FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\n    var FALLBACK_ERROR = {\n        code: FALLBACK_ERROR_CODE,\n        message: getMessageFromCode(FALLBACK_ERROR_CODE)\n    };\n    exports1.JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n    /**\n   * Gets the message for a given code, or a fallback message if the code has\n   * no corresponding message.\n   */ function getMessageFromCode(code) {\n        var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n        if (Number.isInteger(code)) {\n            var codeString = code.toString();\n            if (hasKey(error_constants_1.errorValues, codeString)) {\n                return error_constants_1.errorValues[codeString].message;\n            }\n            if (isJsonRpcServerError(code)) {\n                return exports1.JSON_RPC_SERVER_ERROR_MESSAGE;\n            }\n        }\n        return fallbackMessage;\n    }\n    exports1.getMessageFromCode = getMessageFromCode;\n    /**\n   * Returns whether the given code is valid.\n   * A code is only valid if it has a message.\n   */ function isValidCode(code) {\n        if (!Number.isInteger(code)) {\n            return false;\n        }\n        var codeString = code.toString();\n        if (error_constants_1.errorValues[codeString]) {\n            return true;\n        }\n        if (isJsonRpcServerError(code)) {\n            return true;\n        }\n        return false;\n    }\n    exports1.isValidCode = isValidCode;\n    /**\n   * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n   * Merely copies the given error's values if it is already compatible.\n   * If the given error is not fully compatible, it will be preserved on the\n   * returned object's data.originalError property.\n   */ function serializeError(error) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$fallbackError = _ref.fallbackError, fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError, _ref$shouldIncludeSta = _ref.shouldIncludeStack, shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;\n        var _a, _b;\n        if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== \"string\") {\n            throw new Error(\"Must provide fallback error with integer number code and string message.\");\n        }\n        if (error instanceof classes_1.EthereumRpcError) {\n            return error.serialize();\n        }\n        var serialized = {};\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error) && hasKey(error, \"code\") && isValidCode(error.code)) {\n            var _error = error;\n            serialized.code = _error.code;\n            if (_error.message && typeof _error.message === \"string\") {\n                serialized.message = _error.message;\n                if (hasKey(_error, \"data\")) {\n                    serialized.data = _error.data;\n                }\n            } else {\n                serialized.message = getMessageFromCode(serialized.code);\n                serialized.data = {\n                    originalError: assignOriginalError(error)\n                };\n            }\n        } else {\n            serialized.code = fallbackError.code;\n            var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\n            serialized.message = message && typeof message === \"string\" ? message : fallbackError.message;\n            serialized.data = {\n                originalError: assignOriginalError(error)\n            };\n        }\n        var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\n        if (shouldIncludeStack && error && stack && typeof stack === \"string\") {\n            serialized.stack = stack;\n        }\n        return serialized;\n    }\n    exports1.serializeError = serializeError;\n    // Internal\n    function isJsonRpcServerError(code) {\n        return code >= -32099 && code <= -32000;\n    }\n    function assignOriginalError(error) {\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error)) {\n            return Object.assign({}, error);\n        }\n        return error;\n    }\n    function hasKey(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n})(utils);\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally{\n            try {\n                if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nvar errors = {};\nObject.defineProperty(errors, \"__esModule\", {\n    value: true\n});\nerrors.ethErrors = void 0;\nvar classes_1 = classes;\nvar utils_1 = utils;\nvar error_constants_1 = errorConstants;\nerrors.ethErrors = {\n    rpc: {\n        /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     */ parse: function parse(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     */ invalidRequest: function invalidRequest(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     */ invalidParams: function invalidParams(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     */ methodNotFound: function methodNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     */ internal: function internal(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     */ server: function server(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n            }\n            var code = opts.code;\n            if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n                throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n            }\n            return getEthJsonRpcError(code, opts);\n        },\n        /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     */ invalidInput: function invalidInput(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     */ resourceNotFound: function resourceNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     */ resourceUnavailable: function resourceUnavailable(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     */ transactionRejected: function transactionRejected(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     */ methodNotSupported: function methodNotSupported(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     */ limitExceeded: function limitExceeded(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);\n        }\n    },\n    provider: {\n        /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     */ userRejectedRequest: function userRejectedRequest(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     */ unauthorized: function unauthorized(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     */ unsupportedMethod: function unsupportedMethod(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n        },\n        /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     */ disconnected: function disconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n        },\n        /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     */ chainDisconnected: function chainDisconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n        },\n        /**\n     * Get a custom Ethereum Provider error.\n     */ custom: function custom(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n            }\n            var code = opts.code, message = opts.message, data = opts.data;\n            if (!message || typeof message !== \"string\") {\n                throw new Error('\"message\" must be a nonempty string');\n            }\n            return new classes_1.EthereumProviderError(code, message, data);\n        }\n    }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n    var _parseOpts = parseOpts(arg), _parseOpts2 = _slicedToArray(_parseOpts, 2), message = _parseOpts2[0], data = _parseOpts2[1];\n    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n    var _parseOpts3 = parseOpts(arg), _parseOpts4 = _slicedToArray(_parseOpts3, 2), message = _parseOpts4[0], data = _parseOpts4[1];\n    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (_typeof(arg) === \"object\" && !Array.isArray(arg)) {\n            var message = arg.message, data = arg.data;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message || undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n(function(exports1) {\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.getMessageFromCode = exports1.serializeError = exports1.EthereumProviderError = exports1.EthereumRpcError = exports1.ethErrors = exports1.errorCodes = void 0;\n    var classes_1 = classes;\n    Object.defineProperty(exports1, \"EthereumRpcError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumRpcError;\n        }\n    });\n    Object.defineProperty(exports1, \"EthereumProviderError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumProviderError;\n        }\n    });\n    var utils_1 = utils;\n    Object.defineProperty(exports1, \"serializeError\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.serializeError;\n        }\n    });\n    Object.defineProperty(exports1, \"getMessageFromCode\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.getMessageFromCode;\n        }\n    });\n    var errors_1 = errors;\n    Object.defineProperty(exports1, \"ethErrors\", {\n        enumerable: true,\n        get: function get() {\n            return errors_1.ethErrors;\n        }\n    });\n    var error_constants_1 = errorConstants;\n    Object.defineProperty(exports1, \"errorCodes\", {\n        enumerable: true,\n        get: function get() {\n            return error_constants_1.errorCodes;\n        }\n    });\n})(dist);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {};\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n    inited = true;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(var i = 0, len = code.length; i < len; ++i){\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n}\nfunction toByteArray(b64) {\n    if (!inited) {\n        init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === \"=\" ? 2 : b64[len - 1] === \"=\" ? 1 : 0;\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(len * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n    for(i = 0, j = 0; i < l; i += 4, j += 3){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    if (!inited) {\n        init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = \"\";\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += \"==\";\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += \"=\";\n    }\n    parts.push(output);\n    return parts.join(\"\");\n}\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n}\nvar toString = {}.toString;\nvar isArray = Array.isArray || function(arr) {\n    return toString.call(arr) == \"[object Array]\";\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */ var INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */ Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */ kMaxLength();\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError(\"Invalid typed array length\");\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new Error(\"If encoding is specified then the first argument must be a string\");\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) ;\n}\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for(var i = 0; i < size; ++i){\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for(var i = 0; i < length; i += 1){\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n            if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === \"Buffer\" && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n}\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError(\"Arguments must be Buffers\");\n    }\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n    for(var i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for(i = 0; i < list.length; ++i){\n        var buf = list[i];\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined:\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                ;\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(var i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(var i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(var i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n        if (this.length > max) str += \" ... \";\n    }\n    return \"<Buffer \" + str + \">\";\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError(\"Argument must be a Buffer\");\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for(var i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            var found = true;\n            for(var j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for(var i = 0; i < length; ++i){\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n                return asciiWrite(this, string, offset, length);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Write(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return fromByteArray(buf);\n    } else {\n        return fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while(i < end){\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = \"\";\n    var i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for(var i = start; i < end; ++i){\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for(var i = 0; i < bytes.length; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for(var i = 0; i < sliceLen; ++i){\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for(i = len - 1; i >= 0; --i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for(i = 0; i < len; ++i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction toHex(n) {\n    if (n < 16) return \"0\" + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for(var i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for(var i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n    ;\n}\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\nfunction isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isFastBuffer(obj.slice(0, 0));\n}\nconst isHexString = (hex)=>typeof hex === \"string\" && /^0x[0-9A-Fa-f]*$/.test(hex);\nconst utf8ToHex = (str)=>{\n    return Buffer.from(str, \"utf8\").toString(\"hex\");\n};\nvar _EthereumProvider_instances, _EthereumProvider_getBloctoProperties, _EthereumProvider_addToSwitchable, _EthereumProvider_checkNetworkMatched;\nfunction parseChainId(chainId) {\n    if (!chainId) {\n        return 1;\n    }\n    if (typeof chainId === \"number\") {\n        return chainId;\n    } else if (chainId.startsWith(\"0x\")) {\n        return parseInt(chainId, 16);\n    }\n    return parseInt(chainId, 10);\n}\nclass EthereumProvider extends BloctoProvider {\n    constructor({ chainId, rpc, walletServer, appId }){\n        super();\n        _EthereumProvider_instances.add(this);\n        this.networkVersion = \"1\"; // same as chainId but in decimal\n        // setup chainId\n        invariant(chainId, \"'chainId' is required\");\n        this.networkVersion = `${parseChainId(chainId)}`;\n        this.chainId = `0x${parseChainId(chainId).toString(16)}`;\n        // setup rpc\n        this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];\n        invariant(this.rpc, \"'rpc' is required\");\n        // setup injectedWalletServer\n        this.injectedWalletServer = walletServer;\n        // NOTE: _blocto is not fully initialized yet at this point\n        // Any function should call #getBloctoProperties() to get the full _blocto properties\n        this._blocto = {\n            sessionKey: KEY_SESSION.prod,\n            walletServer: this.injectedWalletServer || \"\",\n            blockchainName: \"\",\n            networkType: \"\",\n            supportNetworkList: {},\n            switchableNetwork: {}\n        };\n        this.appId = appId || DEFAULT_APP_ID;\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated\n    send(methodOrPayload, paramsOrCallback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(true){\n                // signature type 1: arg1 - JSON-RPC payload, arg2 - callback;\n                // ethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n                // This signature is exactly like ethereum.sendAsync()\n                case paramsOrCallback instanceof Function:\n                    return this.sendAsync(methodOrPayload, paramsOrCallback);\n                // signature type 2: arg1 - JSON-RPC method name, arg2 - params array;\n                // ethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n                // This signature is like an async ethereum.sendAsync() with method and params as arguments,\n                // instead of a JSON-RPC payload and callback\n                case typeof methodOrPayload === \"string\" && Array.isArray(paramsOrCallback):\n                    return this.sendAsync({\n                        jsonrpc: \"2.0\",\n                        method: methodOrPayload,\n                        params: paramsOrCallback\n                    });\n                // signature type 3: arg1 - JSON-RPC payload(should be synchronous methods)\n                // ethereum.send(payload: JsonRpcRequest): unknown;\n                // This signature enables you to call some type of RPC methods synchronously\n                default:\n                    return this.sendAsync(methodOrPayload);\n            }\n        });\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation\n    // web3 v1.x BatchRequest still depends on it so we need to implement anyway \\_()_/\n    sendAsync(payload, callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const handleRequest = new Promise((resolve)=>{\n                // web3 v1.x concat batched JSON-RPC requests to an array, handle it here\n                if (Array.isArray(payload)) {\n                    // collect transactions and send batch with custom method\n                    const transactions = payload.filter((request)=>request.method === \"eth_sendTransaction\").map((request)=>{\n                        var _a;\n                        return (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n                    });\n                    const idBase = Math.floor(Math.random() * 10000);\n                    const batchedRequestPayload = {\n                        method: \"blocto_sendBatchTransaction\",\n                        params: transactions\n                    };\n                    const batchResponsePromise = this.request(batchedRequestPayload);\n                    const requests = payload.map(({ method, params }, index)=>method === \"eth_sendTransaction\" ? batchResponsePromise : this.request({\n                            id: idBase + index + 1,\n                            jsonrpc: \"2.0\",\n                            method,\n                            params\n                        }));\n                    // resolve response when all request are executed\n                    Promise.allSettled(requests).then((responses)=>resolve(responses.map((response, index)=>{\n                            return {\n                                id: String(idBase + index + 1),\n                                jsonrpc: \"2.0\",\n                                method: payload[index].method,\n                                result: response.status === \"fulfilled\" ? response.value : undefined,\n                                error: response.status !== \"fulfilled\" ? response.reason : undefined\n                            };\n                        }))).catch((error)=>{\n                        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n                    });\n                } else {\n                    this.request(Object.assign(Object.assign({}, payload), {\n                        id: Number(payload.id)\n                    })).then(resolve);\n                }\n            });\n            // execute callback or return promise, depdends on callback arg given or not\n            if (callback) {\n                handleRequest.then((data)=>callback(null, data)).catch((error)=>callback(error));\n            } else {\n                return handleRequest;\n            }\n        });\n    }\n    /**\n     * Sending userOperation using Blocto SDK.\n     * @param {IUserOperation} userOp - userOperation object\n     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.\n     * These parameters will be ignored.\n     * @returns {Promise<string>} - userOperation hash\n     */ sendUserOperation(userOp) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.request({\n                method: \"eth_sendUserOperation\",\n                params: [\n                    userOp\n                ]\n            });\n        });\n    }\n    request(payload) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!(payload === null || payload === void 0 ? void 0 : payload.method)) throw dist.ethErrors.rpc.invalidRequest();\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (payload.method === \"wallet_switchEthereumChain\") {\n                    if (!((_b = (_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams();\n                    }\n                    return existedSDK.request(payload).then(()=>{\n                        var _a, _b, _c;\n                        this.networkVersion = `${parseChainId((_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0].chainId)}`;\n                        this.chainId = `0x${parseChainId((_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0].chainId).toString(16)}`;\n                        this.rpc = (_c = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c === void 0 ? void 0 : _c.rpc_url;\n                        return null;\n                    });\n                }\n                return existedSDK.request(payload);\n            }\n            const { blockchainName, switchableNetwork, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            // method that doesn't require user to be connected\n            switch(payload.method){\n                case \"eth_chainId\":\n                    {\n                        return this.chainId;\n                    }\n                case \"net_version\":\n                    {\n                        return this.networkVersion;\n                    }\n                case \"wallet_addEthereumChain\":\n                    {\n                        return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);\n                    }\n                case \"eth_call\":\n                    {\n                        const response = yield this.handleReadRequests(payload);\n                        if (!response || response && !response.result && response.error) {\n                            const errorMessage = ((_c = response === null || response === void 0 ? void 0 : response.error) === null || _c === void 0 ? void 0 : _c.message) ? response.error.message : \"Request failed\";\n                            throw dist.ethErrors.rpc.internal(errorMessage);\n                        }\n                        return response.result;\n                    }\n                case \"wallet_switchEthereumChain\":\n                    {\n                        if (!((_e = (_d = payload === null || payload === void 0 ? void 0 : payload.params) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.chainId)) throw dist.ethErrors.rpc.invalidParams();\n                        const newChainId = payload.params[0].chainId;\n                        if (!getChainAddress(sessionKey, blockchainName)) {\n                            // directly switch network if user is not connected\n                            // TODO: add a confirm switch network dialog\n                            const phasedChainId = parseChainId(newChainId);\n                            if (!switchableNetwork[phasedChainId]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: `Unrecognized chain ID \"${newChainId}\". Try adding the chain using wallet_addEthereumChain first.`\n                                });\n                            }\n                            this.networkVersion = `${phasedChainId}`;\n                            this.chainId = `0x${phasedChainId.toString(16)}`;\n                            this.rpc = switchableNetwork[phasedChainId].rpc_url;\n                            this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                            return null;\n                        }\n                        break;\n                    }\n            }\n            // Method that requires user to be connected\n            if (!getChainAddress(sessionKey, blockchainName)) {\n                const email = (_f = payload === null || payload === void 0 ? void 0 : payload.params) === null || _f === void 0 ? void 0 : _f[0];\n                if (payload.method === \"eth_requestAccounts\" && isEmail(email)) {\n                    yield this.enable(email);\n                } else {\n                    yield this.enable();\n                }\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"eth_requestAccounts\":\n                        yield this.fetchAccounts();\n                    // eslint-disable-next-line\n                    case \"eth_accounts\":\n                        result = getChainAddress(sessionKey, blockchainName);\n                        break;\n                    case \"eth_coinbase\":\n                        {\n                            result = (_g = getChainAddress(sessionKey, blockchainName)) === null || _g === void 0 ? void 0 : _g[0];\n                            break;\n                        }\n                    case \"eth_signTypedData_v3\":\n                    case \"eth_signTypedData\":\n                    case \"eth_signTypedData_v4\":\n                    case \"personal_sign\":\n                    case \"eth_sign\":\n                        {\n                            result = yield this.handleSign(payload);\n                            break;\n                        }\n                    case \"wallet_disconnect\":\n                        {\n                            this.handleDisconnect();\n                            result = null;\n                            break;\n                        }\n                    case \"eth_sendTransaction\":\n                        result = yield this.handleSendTransaction(payload);\n                        break;\n                    case \"blocto_sendBatchTransaction\":\n                        result = yield this.handleSendBatchTransaction(payload);\n                        break;\n                    case \"eth_signTransaction\":\n                    case \"eth_sendRawTransaction\":\n                        {\n                            throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + payload.method);\n                        }\n                    case \"eth_sendUserOperation\":\n                        result = yield this.handleSendUserOperation(payload);\n                        break;\n                    case \"wallet_switchEthereumChain\":\n                        {\n                            if (!((_j = (_h = payload === null || payload === void 0 ? void 0 : payload.params) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.chainId)) {\n                                throw dist.ethErrors.rpc.invalidParams();\n                            }\n                            const oldAccount = (_k = getChainAddress(sessionKey, blockchainName)) === null || _k === void 0 ? void 0 : _k[0];\n                            const oldChainId = this.chainId;\n                            const newChainId = payload.params[0].chainId;\n                            if (!switchableNetwork[parseChainId(newChainId)]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: `Unrecognized chain ID \"${parseChainId(payload.params[0].chainId)}\". Try adding the chain using wallet_addEthereumChain first.`\n                                });\n                            }\n                            this.networkVersion = `${parseChainId(newChainId)}`;\n                            this.chainId = `0x${parseChainId(newChainId).toString(16)}`;\n                            this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                            yield this.enable().then(([newAccount])=>{\n                                var _a;\n                                if (newAccount !== oldAccount) {\n                                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.accountsChanged.forEach((listener)=>listener([\n                                            newAccount\n                                        ]));\n                                }\n                                this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                                result = null;\n                            }).catch((error)=>{\n                                this.networkVersion = `${parseChainId(oldChainId)}`;\n                                this.chainId = `0x${parseChainId(oldChainId).toString(16)}`;\n                                this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                                throw error;\n                            });\n                            break;\n                        }\n                    case \"eth_estimateUserOperationGas\":\n                    case \"eth_getUserOperationByHash\":\n                    case \"eth_getUserOperationReceipt\":\n                    case \"eth_supportedEntryPoints\":\n                        result = yield this.handleBundler(payload);\n                        break;\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw dist.ethErrors.rpc.internal(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n            }\n        });\n    }\n    bloctoApi(url, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const sessionId = ((_a = getAccountStorage(sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            if (!sessionId) {\n                throw dist.ethErrors.provider.unauthorized();\n            }\n            return fetch(`${walletServer}/api/${blockchainName}${url}`, Object.assign({\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }, options)).then((response)=>responseSessionGuard(response, sessionKey, ()=>{\n                    var _a;\n                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n                })).catch((e)=>{\n                if ((e === null || e === void 0 ? void 0 : e.error_code) === \"unsupported_method\") {\n                    throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + e.message);\n                } else {\n                    throw dist.ethErrors.rpc.server({\n                        code: -32005,\n                        message: `Blocto server error: ${e.message}`\n                    });\n                }\n            });\n        });\n    }\n    responseListener(frame, objectKey) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === walletServer && e.data.type === \"ETH:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            resolve(e.data[objectKey]);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.handleDisconnect();\n                            }\n                            reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));\n                        }\n                    }\n                    if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        reject(dist.ethErrors.provider.userRejectedRequest(\"User declined the request\"));\n                    }\n                }));\n        });\n    }\n    setIframe(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (true) {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: \"Blocto SDK only works in browser environment\"\n                });\n            }\n            const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const frame = createFrame(`${walletServer}/${this.appId}/${blockchainName}${url}`);\n            attachFrame(frame);\n            return frame;\n        });\n    }\n    // eip-1102 alias\n    // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    enable(email) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (existedSDK.chainId !== this.chainId) {\n                    yield existedSDK.request({\n                        method: \"wallet_addEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    yield existedSDK.request({\n                        method: \"wallet_switchEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    setChainAddress(sessionKey, blockchainName, [\n                        existedSDK.address\n                    ]);\n                }\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.enable().then(resolve).catch(reject), 10));\n            }\n            const address = getChainAddress(sessionKey, blockchainName);\n            if (address) {\n                return new Promise((resolve)=>{\n                    resolve(address);\n                });\n            }\n            const params = new URLSearchParams();\n            params.set(\"l6n\", window.location.origin);\n            params.set(\"v\", SDK_VERSION);\n            const emailParam = email && isEmail(email) ? `/${email}` : \"\";\n            const loginFrame = yield this.setIframe(`/authn${emailParam}?${params.toString()}`);\n            return new Promise((resolve, reject)=>{\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    var _a;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === \"ETH:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener)=>listener({\n                                    chainId: this.chainId\n                                }));\n                            setAccountStorage(sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [blockchainName]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve([\n                                e.data.addr\n                            ]);\n                        }\n                        if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(dist.ethErrors.provider.userRejectedRequest());\n                        }\n                    }\n                });\n            });\n        });\n    }\n    fetchAccounts() {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const { accounts } = yield this.bloctoApi(`/accounts`);\n            setChainAddress(sessionKey, blockchainName, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json()).catch((e)=>{\n                throw dist.ethErrors.rpc.internal(e);\n            });\n        });\n    }\n    handleSign({ method, params }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let message = \"\";\n            if (Array.isArray(params)) {\n                if (method === \"eth_sign\") {\n                    message = isHexString(params[1]) ? params[1].slice(2) : utf8ToHex(params[1]);\n                } else if (method === \"personal_sign\") {\n                    message = isHexString(params[0]) ? params[0].slice(2) : utf8ToHex(params[0]);\n                } else if ([\n                    \"eth_signTypedData\",\n                    \"eth_signTypedData_v3\",\n                    \"eth_signTypedData_v4\"\n                ].includes(method)) {\n                    message = params[1];\n                    const { domain } = JSON.parse(message);\n                    if (isHexString(domain.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must be a number`);\n                    }\n                    if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must match the active chainId \"${parseChainId(this.chainId)}\"`);\n                    }\n                }\n            }\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { signatureId } = yield this.bloctoApi(`/user-signature`, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    method,\n                    message\n                })\n            });\n            const signFrame = yield this.setIframe(`/user-signature/${signatureId}`);\n            return this.responseListener(signFrame, \"signature\");\n        });\n    }\n    handleSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            if (!isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0])) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            const { authorizationId } = yield this.bloctoApi(`/authz`, {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const authzFrame = yield this.setIframe(`/authz/${authorizationId}`);\n            return this.responseListener(authzFrame, \"txHash\");\n        });\n    }\n    handleSendBatchTransaction(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const extractParams = (params)=>params.map((param)=>\"params\" in param ? param.params[0] // handle passing web3.eth.sendTransaction.request(...) as a parameter with params\n                     : param);\n            const formatParams = extractParams(payload.params);\n            const copyPayload = Object.assign(Object.assign({}, payload), {\n                params: formatParams\n            });\n            if (!isValidTransactions(copyPayload.params)) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            return this.handleSendTransaction(copyPayload);\n        });\n    }\n    handleSendUserOperation(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { authorizationId } = yield this.bloctoApi(`/user-operation`, {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const userOPFrame = yield this.setIframe(`/user-operation/${authorizationId}`);\n            return this.responseListener(userOPFrame, \"userOpHash\");\n        });\n    }\n    handleBundler(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return this.bloctoApi(`/rpc/bundler`, {\n                method: \"POST\",\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            });\n        });\n    }\n    handleDisconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.disconnect();\n            }\n            const { sessionKey, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            removeChainAddress(sessionKey, blockchainName);\n            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n        });\n    }\n    loadSwitchableNetwork(networkList) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // setup switchable list if user set networkList\n            if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {\n                const listToAdd = networkList.map(({ chainId, rpcUrls })=>{\n                    if (!chainId) throw dist.ethErrors.rpc.invalidParams(\"Empty chainId\");\n                    if (!(rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls.length)) throw dist.ethErrors.rpc.invalidParams(\"Empty rpcUrls\");\n                    return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_addToSwitchable).call(this, {\n                        chainId: `${parseChainId(chainId)}`,\n                        rpcUrls\n                    });\n                });\n                return Promise.all(listToAdd).then(()=>null);\n            } else {\n                throw dist.ethErrors.rpc.invalidParams(\"Empty networkList\");\n            }\n        });\n    }\n}\n_EthereumProvider_instances = new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties() {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (!Object.keys(this._blocto.supportNetworkList).length) {\n            yield getEvmSupport().then((result)=>this._blocto.supportNetworkList = result).catch((e)=>{\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Get blocto server failed: ${e.message}`\n                });\n            });\n        }\n        const { chain_id, name, network_type, blocto_service_environment, display_name } = this._blocto.supportNetworkList[this.networkVersion];\n        if (!chain_id) throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${this.networkVersion} might not be supported yet.`);\n        this._blocto = Object.assign(Object.assign({}, this._blocto), {\n            sessionKey: ETH_SESSION_KEY_MAPPING[blocto_service_environment],\n            walletServer: this.injectedWalletServer || ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment],\n            blockchainName: name,\n            networkType: network_type,\n            switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), {\n                [chain_id]: {\n                    name,\n                    display_name,\n                    network_type,\n                    wallet_web_url: this._blocto.walletServer,\n                    rpc_url: this.rpc\n                }\n            })\n        });\n        return this._blocto;\n    });\n}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable({ chainId, rpcUrls }) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { supportNetworkList } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n        const { chain_id, name, display_name, network_type, blocto_service_environment } = supportNetworkList[chainId];\n        const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto.switchableNetwork[chain_id] = {\n            name,\n            display_name,\n            network_type,\n            wallet_web_url,\n            rpc_url: rpcUrls[0]\n        };\n    });\n}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched() {\n    const existedSDK = window.ethereum;\n    if (existedSDK && existedSDK.isBlocto && parseChainId(existedSDK.chainId) !== parseChainId(this.chainId)) {\n        throw dist.ethErrors.provider.chainDisconnected();\n    }\n};\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    function encode(source) {\n        if (source instanceof Uint8Array) ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nconst basex = src;\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar bs58 = basex(ALPHABET);\nvar bs58$1 = /*@__PURE__*/ getDefaultExportFromCjs(bs58);\nlet Solana;\ntry {\n    Solana = require(\"@solana/web3.js\");\n} catch (_a) {\n// prevent crash if there is no @solana/web3.js.\n}\nclass SolanaProvider extends BloctoProvider {\n    constructor({ net = \"mainnet-beta\", server, appId, rpc }){\n        super();\n        invariant(net, \"'net' is required\");\n        invariant(Object.values(SOL_NET).includes(net), \"unsupported net\");\n        this.net = net;\n        this.rpc = rpc || (net === \"mainnet-beta\" ? \"https://free.rpcpool.com\" : `https://api.${net}.solana.com`);\n        this.server = server || SOL_NET_SERVER_MAPPING[this.net] || \"\";\n        this.appId = appId || DEFAULT_APP_ID;\n        this.sessionKey = SOL_SESSION_KEY_MAPPING[this.net];\n        if (!Solana) {\n            throw new Error(\"No @solana/web3.js installed. Please install it to interact with Solana.\");\n        }\n    }\n    request(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.request(payload);\n            }\n            if (!getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                yield this.connect();\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"connect\":\n                        result = yield this.fetchAccounts();\n                        break;\n                    case \"disconnect\":\n                        this.disconnect();\n                        break;\n                    case \"getAccounts\":\n                        result = ((_a = getChainAddress(this.sessionKey, CHAIN.SOLANA)) === null || _a === void 0 ? void 0 : _a.length) ? getChainAddress(this.sessionKey, CHAIN.SOLANA) : yield this.fetchAccounts();\n                        break;\n                    case \"getAccountInfo\":\n                        {\n                            // Format the data as the same format returning from Connection.getAccountInfo from @solana/web3.js\n                            // ref: https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getAccountInfo\n                            const accountInfo = yield this.handleReadRequests(payload);\n                            const [bufferData, encoding] = accountInfo.result.value.data;\n                            result = Object.assign(Object.assign({}, accountInfo.result.value), {\n                                data: Buffer.from(bufferData, encoding),\n                                owner: new Solana.PublicKey(accountInfo.result.value.owner)\n                            });\n                            break;\n                        }\n                    // custom JSON-RPC method\n                    case \"convertToProgramWalletTransaction\":\n                        result = yield this.handleConvertTransaction(payload);\n                        break;\n                    // custom JSON-RPC method\n                    case \"signAndSendTransaction\":\n                        result = yield this.handleSignAndSendTransaction(payload);\n                        break;\n                    // block user from using traditional methods\n                    case \"signTransaction\":\n                    case \"signAllTransactions\":\n                        throw new Error(`Blocto is program wallet, which doesn't support ${payload.method}. Use signAndSendTransaction instead.`);\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw new Error(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                console.error(error);\n                throw error;\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return new Promise((resolve)=>{\n                    existedSDK.on(\"connect\", ()=>{\n                        setChainAddress(this.sessionKey, CHAIN.SOLANA, [\n                            existedSDK.publicKey.toBase58()\n                        ]);\n                        resolve();\n                    });\n                    existedSDK.connect();\n                });\n            }\n            return new Promise((resolve, reject)=>{\n                if (true) {\n                    return reject(\"Currently only supported in browser\");\n                }\n                if (getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                    return resolve();\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/solana/authn?l6n=${location}&v=${SDK_VERSION}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    const e = event;\n                    if (e.origin === this.server) {\n                        if (e.data.type === \"SOL:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            this.eventListeners.connect.forEach((listener)=>listener(this.net));\n                            setAccountStorage(this.sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [CHAIN.SOLANA]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve();\n                        }\n                        if (e.data.type === \"SOL:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(new Error(\"User declined the login request\"));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            this.eventListeners.disconnect.forEach((listener)=>listener(null));\n            removeChainAddress(this.sessionKey, CHAIN.SOLANA);\n        });\n    }\n    fetchAccounts() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(`${this.server}/api/solana/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.SOLANA, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json());\n        });\n    }\n    // solana web3 utility\n    convertToProgramWalletTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.convertToProgramWalletTransaction(transaction);\n            }\n            const message = yield this.request({\n                method: \"convertToProgramWalletTransaction\",\n                params: {\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }\n            });\n            return this.toTransaction(message, []);\n        });\n    }\n    // solana web3 utility\n    signAndSendTransaction(transaction, connection) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.signAndSendTransaction(transaction);\n            }\n            const extra = {};\n            if (connection) {\n                if (connection.commitment) extra.commitment = connection.commitment;\n                // if the connection object passed-in has different rpc endpoint, reconnect to it\n                // eslint-disable-next-line no-underscore-dangle\n                const rpc = connection ? connection._rpcEndpoint : null;\n                if (rpc && rpc !== this.rpc) {\n                    this.rpc = rpc;\n                    this.disconnect();\n                    yield this.connect();\n                }\n            }\n            return this.request({\n                method: \"signAndSendTransaction\",\n                params: Object.assign({\n                    signatures: yield this.collectSignatures(transaction),\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }, extra)\n            });\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    toTransaction(raw, signatures) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const message = Solana.Message.from(Buffer.from(raw, \"hex\"));\n            const transaction = new Solana.Transaction();\n            transaction.recentBlockhash = message.recentBlockhash;\n            if (message.header.numRequiredSignatures > 0) {\n                transaction.feePayer = message.accountKeys[0];\n            }\n            signatures.forEach((signature, index)=>{\n                const sigPubkeyPair = {\n                    signature: signature === Solana.PublicKey.default.toBase58() ? null : bs58$1.decode(signature),\n                    publicKey: message.accountKeys[index]\n                };\n                transaction.signatures.push(sigPubkeyPair);\n            });\n            message.instructions.forEach((instruction)=>{\n                const keys = instruction.accounts.map((account)=>{\n                    const pubkey = message.accountKeys[account];\n                    return {\n                        pubkey,\n                        isSigner: account < message.header.numRequiredSignatures,\n                        isWritable: message.isAccountWritable(account)\n                    };\n                });\n                transaction.instructions.push(new Solana.TransactionInstruction({\n                    keys,\n                    programId: message.accountKeys[instruction.programIdIndex],\n                    data: bs58$1.decode(instruction.data)\n                }));\n            });\n            return transaction;\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    collectSignatures(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return transaction.signatures.reduce((acc, cur)=>{\n                if (cur.signature) {\n                    acc[cur.publicKey.toBase58()] = cur.signature.toString(\"hex\");\n                }\n                return acc;\n            }, {});\n        });\n    }\n    handleConvertTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            return fetch(`${this.server}/api/solana/convertToWalletTx`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n        });\n    }\n    handleSignAndSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { authorizationId } = yield fetch(`${this.server}/api/solana/authz`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/solana/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"SOL:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve(e.data.txHash);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n}\nconst checkMessagePayloadFormat = (payload)=>{\n    var _a, _b;\n    const formattedPayload = Object.assign({}, payload);\n    const { message, nonce, address, application, chainId } = payload;\n    if (typeof message !== \"string\") {\n        formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : \"\";\n    }\n    if (typeof nonce !== \"string\") {\n        formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : \"\";\n    }\n    if (address && typeof address !== \"boolean\") {\n        formattedPayload.address = !!address;\n    }\n    if (application && typeof application !== \"boolean\") {\n        formattedPayload.application = !!application;\n    }\n    if (chainId && typeof chainId !== \"boolean\") {\n        formattedPayload.chainId = !!chainId;\n    }\n    return formattedPayload;\n};\nclass AptosProvider extends BloctoProvider {\n    constructor({ chainId, server, appId }){\n        super();\n        this.publicKey = [];\n        this.authKey = \"\";\n        invariant(chainId, \"'chainId' is required\");\n        invariant(appId, \"It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.\");\n        this.chainId = chainId;\n        this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];\n        this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];\n        this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];\n        const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];\n        this.appId = appId || DEFAULT_APP_ID;\n        this.server = server || defaultServer || \"\";\n    }\n    get publicAccount() {\n        var _a;\n        return {\n            address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,\n            publicKey: this.publicKey.length ? this.publicKey : null,\n            // @todo: provide authkey\n            authKey: null,\n            minKeysRequired: 2\n        };\n    }\n    network() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return {\n                name: this.networkName,\n                api: this.api,\n                chainId: this.chainId.toString()\n            };\n        });\n    }\n    isConnected() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return !!((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code);\n        });\n    }\n    signTransaction(transaction) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signTransaction(transaction);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            throw new Error(\"signTransaction method not supported.\");\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            removeChainAddress(this.sessionKey, CHAIN.APTOS);\n        });\n    }\n    signAndSubmitTransaction(transaction, txOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signAndSubmitTransaction(transaction, txOptions);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { authorizationId } = yield fetch(`${this.server}/api/aptos/authz`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions))\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/aptos/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve({\n                                hash: e.data.txHash\n                            });\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    signMessage(payload) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            const formattedPayload = checkMessagePayloadFormat(payload);\n            if (existedSDK) {\n                return existedSDK.signMessage(formattedPayload);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { signatureId } = yield fetch(`${this.server}/api/aptos/user-signature`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(formattedPayload)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            const url = `${this.server}/${this.appId}/aptos/user-signature/${signatureId}`;\n            const signFrame = createFrame(url);\n            attachFrame(signFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            resolve(e.data);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.connect().then(resolve).catch(reject), 10));\n            }\n            return new Promise((resolve, reject)=>{\n                var _a, _b;\n                if (true) {\n                    return reject(\"Currently only supported in browser\");\n                }\n                if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {\n                    return resolve({\n                        address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,\n                        publicKey: this.publicKey,\n                        authKey: null,\n                        minKeysRequired: 2\n                    });\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/aptos/authn?l6n=${location}&v=${SDK_VERSION}}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>__awaiter(this, void 0, void 0, function*() {\n                        var _c, _d, _e;\n                        const e = event;\n                        if (e.origin === this.server) {\n                            if (e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                setAccountStorage(this.sessionKey, {\n                                    code: e.data.code,\n                                    connected: true,\n                                    accounts: {\n                                        [CHAIN.APTOS]: [\n                                            e.data.addr\n                                        ]\n                                    }\n                                }, e.data.exp);\n                                if ((_c = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _c === void 0 ? void 0 : _c.length) {\n                                    try {\n                                        const { public_keys: publicKeys } = yield fetch(`${this.server}/blocto/aptos/accounts/${(_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d[0]}`).then((response)=>response.json());\n                                        this.publicKey = publicKeys || [];\n                                        resolve({\n                                            address: ((_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]) || \"\",\n                                            publicKey: this.publicKey,\n                                            authKey: null,\n                                            minKeysRequired: 2\n                                        });\n                                    } catch (err) {\n                                        return reject(e);\n                                    }\n                                } else {\n                                    // @todo: better error\n                                    return reject();\n                                }\n                            }\n                            if (e.data.type === \"APTOS:FRAME:CLOSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                reject(new Error(\"User declined the login request\"));\n                            }\n                        }\n                    }));\n            });\n        });\n    }\n    fetchAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(`${this.server}/api/aptos/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);\n            return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || \"\";\n        });\n    }\n}\nclass BloctoSDK {\n    constructor({ appId, ethereum, solana, aptos }){\n        if (ethereum) {\n            this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), {\n                appId\n            }));\n        }\n        if (solana) {\n            this.solana = new SolanaProvider(Object.assign(Object.assign({}, solana), {\n                appId\n            }));\n        }\n        if (aptos) {\n            this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), {\n                appId\n            }));\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2N0by9zZGsvZGlzdC9ibG9jdG8tc2RrLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsNkNBQTZDLEdBQzdDOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSxvREFBb0Q7Ozs7K0JBZ2tKOUJBOzs7ZUFBYkM7OztBQTdqSlQsU0FBU0MsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU08sdUJBQXVCQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BELElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFH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U0FBUztvQkFDTCxvREFBb0Q7b0JBQ3BELG9FQUFvRTtvQkFDcEUsaUNBQWlDLElBQUksQ0FBQ3RqQixLQUFLO29CQUMzQyw2QkFBNkJxakI7Z0JBQ2pDO1lBQ0osR0FBR2xwQixJQUFJLENBQUMsQ0FBQytILFdBQWFELHFCQUFxQkMsVUFBVSxJQUFJLENBQUMyZCxVQUFVO1lBQ3BFL2hCLGdCQUFnQixJQUFJLENBQUMraEIsVUFBVSxFQUFFcmtCLE1BQU15dkIsS0FBSyxFQUFFenRCO1lBQzlDLE9BQU8sQ0FBQ0EsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEtBQUs7UUFDaEY7SUFDSjtBQUNKO0FBRUEsTUFBTXZFO0lBQ0Z5QyxZQUFZLEVBQUVzRSxLQUFLLEVBQUUraEIsUUFBUSxFQUFFNEYsTUFBTSxFQUFFb0UsS0FBSyxFQUFFLENBQUU7UUFDNUMsSUFBSWhLLFVBQVU7WUFDVixJQUFJLENBQUNBLFFBQVEsR0FBRyxJQUFJeEMsaUJBQWlCOWhCLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3FrQixXQUFXO2dCQUFFL2hCO1lBQU07UUFDNUY7UUFDQSxJQUFJMm5CLFFBQVE7WUFDUixJQUFJLENBQUNBLE1BQU0sR0FBRyxJQUFJSCxlQUFlL3BCLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2lxQixTQUFTO2dCQUFFM25CO1lBQU07UUFDdEY7UUFDQSxJQUFJK3JCLE9BQU87WUFDUCxJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJcEIsY0FBY2x0QixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdxdUIsUUFBUTtnQkFBRS9yQjtZQUFNO1FBQ25GO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BibG9jdG8vc2RrL2Rpc3QvYmxvY3RvLXNkay5tb2R1bGUuanM/YzU3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBWZXJzaW9uOiAwLjUuNSAtIEF1Z3VzdCAxNCwgMjAyMyAxMDoyMzo1MiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vLyBpbnN0ZWFkIGludmFyaWFudCBmcm9tIHBhY2thZ2UsIHNpbmNlIGFsbCBlcnJvciB3aWxsIHRocm93IG9uIHByb2R1Y3Rpb25cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQpO1xuICAgIH1cbn1cblxuLy8gbG9jYWwgc3RvcmFnZSB2ZXJzaW9uIG5hbWluZyBydWxlOiBbbWlsZXN0b25lXS5bcGF0Y2hdXG52YXIgS0VZX1NFU1NJT047XG4oZnVuY3Rpb24gKEtFWV9TRVNTSU9OKSB7XG4gICAgS0VZX1NFU1NJT05bXCJwcm9kXCJdID0gXCJCTE9DVE9fU0RLXCI7XG4gICAgS0VZX1NFU1NJT05bXCJkZXZcIl0gPSBcIkJMT0NUT19TREtfREVWXCI7XG4gICAgS0VZX1NFU1NJT05bXCJzdGFnaW5nXCJdID0gXCJCTE9DVE9fU0RLX1NUQUdJTkdcIjtcbn0pKEtFWV9TRVNTSU9OIHx8IChLRVlfU0VTU0lPTiA9IHt9KSk7XG52YXIgQ0hBSU47XG4oZnVuY3Rpb24gKENIQUlOKSB7XG4gICAgQ0hBSU5bXCJFVEhFUkVVTVwiXSA9IFwiZXRoZXJldW1cIjtcbiAgICBDSEFJTltcIlNPTEFOQVwiXSA9IFwic29sYW5hXCI7XG4gICAgQ0hBSU5bXCJBUFRPU1wiXSA9IFwiYXB0b3NcIjtcbn0pKENIQUlOIHx8IChDSEFJTiA9IHt9KSk7XG5cbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba2V5XSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbn1cbmNvbnN0IG1lbW9yeVN0b3JhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5tZW1vcnlTdG9yYWdlIDogbmV3IE1lbW9yeVN0b3JhZ2UoKTtcblxuY29uc3QgaXNTdXBwb3J0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJywgJzEnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJyk7XG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdsb2NhbF9zdG9yYWdlX3N1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAnMSc7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IHN0b3JhZ2UgPSBpc1N1cHBvcnRlZCgpID8gd2luZG93LnNlc3Npb25TdG9yYWdlIDogbWVtb3J5U3RvcmFnZTtcbmNvbnN0IGdldEl0ZW0gPSAoa2V5LCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpKSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5jb25zdCBzZXRJdGVtID0gKGtleSwgdmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShrZXksIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5jb25zdCByZW1vdmVJdGVtID0gKGtleSkgPT4ge1xuICAgIHNldEl0ZW0oa2V5LCAnJyk7IC8vIER1ZSB0byBzb21lIHZlcnNpb25zIG9mIGJyb3dzZXIgYnVnIGNhbid0IHJlbW92ZUl0ZW0gY29ycmVjdGx5LlxuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtrZXlzLktFWV9TRVNTSU9OfSBrZXkgLSBrZXkgdG8gcmV0cmlldmUgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtQcm92aWRlclNlc3Npb24gfCBudWxsfSBQcm92aWRlclNlc3Npb24gfCBudWxsXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCBQcm92aWRlclNlc3Npb24gZnJvbSBzdG9yYWdlLlxuICogSWYgdGhlIGRhdGEgaXMgZXhwaXJlZCwgd2lsbCByZW1vdmUgdGhlIGRhdGEgYW5kIHJldHVybiBudWxsXG4gKi9cbmNvbnN0IGdldEFjY291bnRTdG9yYWdlID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IHJhd0FjY291bnRTdG9yYWdlID0gZ2V0SXRlbShrZXksIG51bGwpO1xuICAgIGlmICghcmF3QWNjb3VudFN0b3JhZ2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIGNvbXBhcmUgdGhlIGV4cGlyeSB0aW1lIG9mIHRoZSBpdGVtIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IHJhd0FjY291bnRTdG9yYWdlLmV4cGlyeSB8fFxuICAgICAgICByYXdBY2NvdW50U3RvcmFnZS52ICE9PSBTREtfVkVSU0lPTikge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGE7XG59O1xuLyoqXG4gIEBwYXJhbSB7a2V5cy5LRVlfU0VTU0lPTn0ga2V5IC0ga2V5IHRvIHN0b3JlIHRoZSBkYXRhXG4gIEBwYXJhbSB7UHJvdmlkZXJTZXNzaW9ufSBkYXRhIC0gT25seSB0aGUgcGFydCBvZiBQcm92aWRlclNlc3Npb24gdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIHtcbiAgICBjb25uZWN0ZWQ/OiBib29sZWFuO1xuICAgIGNvZGU/OiBzdHJpbmcgfCBudWxsO1xuICAgIGFjY291bnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG4gIH1cbiAgQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIGV4cGlyeSB0aW1lIG9mIHRoZSBkYXRhXG4qL1xuY29uc3Qgc2V0QWNjb3VudFN0b3JhZ2UgPSAoa2V5LCBkYXRhLCBleHBpcnkpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCByYXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5KTtcbiAgICBjb25zdCBuZXdBY2NvdW50U3RvcmFnZSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29kZTogKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9hID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogISEoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9iID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSksXG4gICAgICAgICAgICBhY2NvdW50czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2MgPSByYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY291bnRzKSwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmFjY291bnRzKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwaXJ5OiBleHBpcnkgfHxcbiAgICAgICAgICAgIChyYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZXhwaXJ5KSB8fFxuICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBMT0dJTl9QRVJTSVNUSU5HX1RJTUUsXG4gICAgICAgIHY6IFNES19WRVJTSU9OLFxuICAgIH07XG4gICAgc2V0SXRlbShrZXksIG5ld0FjY291bnRTdG9yYWdlKTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgZ2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKChfYSA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSkge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2NvdW50c1tjaGFpbl0pIHx8IG51bGw7XG59O1xuY29uc3Qgc2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4sIGFjY291bnQpID0+IHtcbiAgICBzZXRBY2NvdW50U3RvcmFnZShrZXksIHsgYWNjb3VudHM6IHsgW2NoYWluXTogYWNjb3VudCB9IH0pO1xuICAgIHJldHVybjtcbn07XG5jb25zdCByZW1vdmVDaGFpbkFkZHJlc3MgPSAoa2V5LCBjaGFpbikgPT4ge1xuICAgIHNldEFjY291bnRTdG9yYWdlKGtleSwgeyBhY2NvdW50czogeyBbY2hhaW5dOiB1bmRlZmluZWQgfSB9KTtcbiAgICByZXR1cm47XG59O1xuXG4vKiBldGggc2VyaWVzIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgRVRIX1JQQ19MSVNUID0ge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxpc3Qgb2YgcHVibGljIFJQQyBlbmRwb2ludHMgdGhhdCB3ZSBrbm93biB0byBiZSB3b3JraW5nXG4gICAgLy8gVXNlZCB0byBoZWxwIGRldmVsb3BlcnMgZGlkIG5vdCBzZXQgdXAgdGhlaXIgb3duIFJQQyBlbmRwb2ludHNcbiAgICAvLyBCU0MgbWFpbm5ldFxuICAgIDU2OiAnaHR0cHM6Ly9ic2MtZGF0YXNlZWQxLmJpbmFuY2Uub3JnJyxcbiAgICAvLyBCU0MgdGVzdG5ldFxuICAgIDk3OiAnaHR0cHM6Ly9kYXRhLXNlZWQtcHJlYnNjLTEtczEuYmluYW5jZS5vcmc6ODU0NScsXG4gICAgLy8gUG9seWdvbiBNYWlubmV0XG4gICAgMTM3OiAnaHR0cHM6Ly9ycGMtbWFpbm5ldC5tYXRpY3ZpZ2lsLmNvbS8nLFxuICAgIC8vIFBvbHlnb24gVGVzdG5ldFxuICAgIDgwMDAxOiAnaHR0cHM6Ly9ycGMtbXVtYmFpLm1hdGljLnRvZGF5LycsXG4gICAgLy8gQXZhbGFuY2hlIE1haW5uZXRcbiAgICA0MzExNDogJ2h0dHBzOi8vYXBpLmF2YXgubmV0d29yay9leHQvYmMvQy9ycGMnLFxuICAgIC8vIEF2YWxhbmNoZSBGdWppIFRlc3RuZXRcbiAgICA0MzExMzogJ2h0dHBzOi8vYXBpLmF2YXgtdGVzdC5uZXR3b3JrL2V4dC9iYy9DL3JwYycsXG4gICAgLy8gQXJiaXRydW0gTWFpbm5ldFxuICAgIDQyMTYxOiAnaHR0cHM6Ly9hcmIxLmFyYml0cnVtLmlvL3JwYycsXG4gICAgLy8gQXJiaXRydW0gVGVzdG5ldFxuICAgIDQyMTYxMzogJ2h0dHBzOi8vZW5kcG9pbnRzLm9tbmlhdGVjaC5pby92MS9hcmJpdHJ1bS9nb2VybGkvcHVibGljJyxcbiAgICAvLyBPcHRpbWlzbSBNYWlubmV0XG4gICAgMTA6ICdodHRwczovL21haW5uZXQub3B0aW1pc20uaW8nLFxuICAgIC8vIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0XG4gICAgNDIwOiAnaHR0cHM6Ly9nb2VybGkub3B0aW1pc20uaW8nLFxufTtcbmNvbnN0IEVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIHByb2Q6ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBzdGFnaW5nOiAnaHR0cHM6Ly93YWxsZXQtdjItc3RhZ2luZy5ibG9jdG8uYXBwJyxcbiAgICBkZXY6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG59O1xuY29uc3QgRVRIX1NFU1NJT05fS0VZX01BUFBJTkcgPSB7XG4gICAgcHJvZDogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBzdGFnaW5nOiBLRVlfU0VTU0lPTi5zdGFnaW5nLFxuICAgIGRldjogS0VZX1NFU1NJT04uZGV2LFxufTtcbi8qIGV0aCBzZXJpZXMgY29uc3RhbnRzIGVuZCAqL1xuLyogc29sIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgU09MX05FVCA9IHtcbiAgICBNYWlubmV0QmV0YTogJ21haW5uZXQtYmV0YScsXG4gICAgVGVzdG5ldDogJ3Rlc3RuZXQnLFxuICAgIERldm5ldDogJ2Rldm5ldCcsXG59O1xuY29uc3QgU09MX05FVF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICBbU09MX05FVC5NYWlubmV0QmV0YV06ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBbU09MX05FVC5EZXZuZXRdOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxuICAgIFtTT0xfTkVULlRlc3RuZXRdOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxufTtcbmNvbnN0IFNPTF9TRVNTSU9OX0tFWV9NQVBQSU5HID0ge1xuICAgIFtTT0xfTkVULk1haW5uZXRCZXRhXTogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBbU09MX05FVC5EZXZuZXRdOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgW1NPTF9ORVQuVGVzdG5ldF06IEtFWV9TRVNTSU9OLmRldixcbn07XG4vKiBzb2wgY29uc3RhbnRzIGVuZCAqL1xuLyogYXB0b3MgY29uc3RhbnRzIGJlZ2luICovXG5jb25zdCBBUFRfU0VTU0lPTl9LRVlfTUFQUElORyA9IHtcbiAgICAxOiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgIDI6IEtFWV9TRVNTSU9OLmRldixcbiAgICAzOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgNDogS0VZX1NFU1NJT04uZGV2LFxuICAgIDU6IEtFWV9TRVNTSU9OLnN0YWdpbmcsXG59O1xuY29uc3QgQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIC8vIE1BSU5ORVRcbiAgICAxOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgLy8gVEVTVE5FVFxuICAgIDI6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gREVWTkVUXG4gICAgMzogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBURVNUSU5HXG4gICAgNDogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBQUkVNQUlOTkVUXG4gICAgNTogJ2h0dHBzOi8vd2FsbGV0LXYyLXN0YWdpbmcuYmxvY3RvLmFwcCcsXG59O1xudmFyIFdhbGxldEFkYXB0ZXJOZXR3b3JrO1xuKGZ1bmN0aW9uIChXYWxsZXRBZGFwdGVyTmV0d29yaykge1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiTWFpbm5ldFwiXSA9IFwibWFpbm5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiVGVzdG5ldFwiXSA9IFwidGVzdG5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiRGV2bmV0XCJdID0gXCJkZXZuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RpbmdcIl0gPSBcInRlc3RpbmdcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlByZW1haW5uZXRcIl0gPSBcInByZW1haW5uZXRcIjtcbn0pKFdhbGxldEFkYXB0ZXJOZXR3b3JrIHx8IChXYWxsZXRBZGFwdGVyTmV0d29yayA9IHt9KSk7XG5jb25zdCBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HID0ge1xuICAgIDE6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLk1haW5uZXQsXG4gICAgMjogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdG5ldCxcbiAgICAzOiBXYWxsZXRBZGFwdGVyTmV0d29yay5EZXZuZXQsXG4gICAgNDogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdGluZyxcbiAgICA1OiBXYWxsZXRBZGFwdGVyTmV0d29yay5QcmVtYWlubmV0LFxufTtcbmNvbnN0IEFQVF9DSEFJTl9JRF9SUENfTUFQUElORyA9IHtcbiAgICAxOiAnaHR0cHM6Ly9mdWxsbm9kZS5tYWlubmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDI6ICdodHRwczovL2Z1bGxub2RlLnRlc3RuZXQuYXB0b3NsYWJzLmNvbS92MScsXG4gICAgMzogJ2h0dHBzOi8vZnVsbG5vZGUuZGV2bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDQ6ICcnLFxuICAgIDU6ICdodHRwczovL3ByZW1haW5uZXQuYXB0b3NkZXYuY29tL3YxJyxcbn07XG4vKiBhcHRvcyBjb25zdGFudHMgZW5kICovXG5jb25zdCBFSVAxMTkzX0VWRU5UUyA9IFtcbiAgICAnY29ubmVjdCcsXG4gICAgJ2Rpc2Nvbm5lY3QnLFxuICAgICdtZXNzYWdlJyxcbiAgICAnY2hhaW5DaGFuZ2VkJyxcbiAgICAnYWNjb3VudHNDaGFuZ2VkJyxcbl07XG4vLyBQcmVzZXJ2ZSBsb2dpbiBmb3IgMSBkYXlcbmNvbnN0IExPR0lOX1BFUlNJU1RJTkdfVElNRSA9IDg2NDAwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfQVBQX0lEID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG4vLyBXaWxsIGluamVjdCB0aGUgdmVyc2lvbiBvZiB0aGUgU0RLIGJ5IHJvbGx1cCB2ZXJzaW9uSW5qZWN0b3IgZHVyaW5nIGJ1aWxkIHRpbWVcbmNvbnN0IFNES19WRVJTSU9OID0gJzAuNS41JztcblxuLy8gVGhlIHJvb3QgY2xhc3MgZm9yIGFsbCBwcm92aWRlcnNcbmNsYXNzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc0Jsb2N0byA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuICAgICAgICAvLyBhbGlhcyByZW1vdmVMaXN0ZW5lclxuICAgICAgICB0aGlzLm9mZiA9IHRoaXMucmVtb3ZlTGlzdGVuZXI7XG4gICAgICAgIC8vIGluaXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIEVJUDExOTNfRVZFTlRTLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IERFRkFVTFRfQVBQX0lEO1xuICAgIH1cbiAgICAvLyBpbXBsZW1lbnQgYnkgY2hpbGRyZW5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgfSk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIUVJUDExOTNfRVZFTlRTLmluY2x1ZGVzKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEB0b2RvOiBpbXBsZW1lbnQgaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBvbmNlKCkgeyB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgSUZSQU1FX1NUWUxFID0gJ3dpZHRoOjEwMHZ3O2hlaWdodDoxMDAlO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDt6LWluZGV4OjIxNDc0ODM2NDY7Ym9yZGVyOm5vbmU7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yLXNjaGVtZTpsaWdodDtpbnNldDowcHg7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czphdXRvOyc7XG5mdW5jdGlvbiBjcmVhdGVGcmFtZSh1cmwpIHtcbiAgICBjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcbiAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgSUZSQU1FX1NUWUxFKTtcbiAgICByZXR1cm4gZnJhbWU7XG59XG5mdW5jdGlvbiBhdHRhY2hGcmFtZShmcmFtZSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhbWUpO1xufVxuZnVuY3Rpb24gZGV0YXRjaEZyYW1lKGZyYW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZyYW1lICYmIGZyYW1lLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuICAgIH1cbn1cblxudmFyIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyID0gKGV2ZW50VHlwZSwgaGFuZGxlciwgdGFyZ2V0ID0gd2luZG93KSA9PiB7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgICBjb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGhhbmRsZXIoZSwgcmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xufTtcblxuZnVuY3Rpb24gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIGtleSwgZGlzY29ubmVjdEhhbmRsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlKSB8fCAndW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgZS5lcnJvcl9jb2RlID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmVycm9yX2NvZGU7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGlzRW1haWwgPSAodmFsdWUpID0+IC9cXFMrQFxcUytcXC5cXFMrLy50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4gKHR5cGVvZiB0cmFuc2FjdGlvbiA9PT0gJ29iamVjdCcgJiYgdHJhbnNhY3Rpb24gIT09IG51bGwgJiYgJ2Zyb20nIGluIHRyYW5zYWN0aW9uKTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25zKSA9PiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpICYmIHRyYW5zYWN0aW9ucy5ldmVyeSh0eCA9PiBpc1ZhbGlkVHJhbnNhY3Rpb24odHgpKSk7XG5cbmZ1bmN0aW9uIGdldEV2bVN1cHBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrcyB9ID0geWllbGQgZmV0Y2goJ2h0dHBzOi8vYXBpLmJsb2N0by5hcHAvbmV0d29ya3MvZXZtJykudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IGV2bVN1cHBvcnRNYXAgPSBuZXR3b3Jrcy5yZWR1Y2UoKGEsIHYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGEpLCB7IFt2LmNoYWluX2lkXTogdiB9KSksIHt9KTtcbiAgICAgICAgcmV0dXJuIGV2bVN1cHBvcnRNYXA7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBkaXN0ID0ge307XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpO1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbnZhciBjbGFzc2VzID0ge307XG5cbnZhciBmYXN0U2FmZVN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbnN0cmluZ2lmeVtcImRlZmF1bHRcIl0gPSBzdHJpbmdpZnk7XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeTtcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSc7XG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gJ1tDaXJjdWxhcl0nO1xudmFyIGFyciA9IFtdO1xudmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH07XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgfVxuICBkZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucyk7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpO1xuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7XG4gICAgICAgIHZhbHVlOiByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMTtcbiAgdmFyIGk7XG4gIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gIH1cbiAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDE7XG4gIHZhciBpO1xuICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKS5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICByZXBsYWNlciA9IHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCcgPyByZXBsYWNlciA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NlcywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuY2xhc3Nlcy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBjbGFzc2VzLkV0aGVyZXVtUnBjRXJyb3IgPSB2b2lkIDA7XG52YXIgZmFzdF9zYWZlX3N0cmluZ2lmeV8xID0gZmFzdFNhZmVTdHJpbmdpZnk7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKiBQZXJtaXRzIGFueSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gKi9cbnZhciBFdGhlcmV1bVJwY0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEV0aGVyZXVtUnBjRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXRoZXJldW1ScGNFcnJvcik7XG4gIGZ1bmN0aW9uIEV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoZXJldW1ScGNFcnJvcik7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRXRoZXJldW1ScGNFcnJvciwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0ge1xuICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nXG4gICAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZmFzdF9zYWZlX3N0cmluZ2lmeV8xW1wiZGVmYXVsdFwiXSh0aGlzLnNlcmlhbGl6ZSgpLCBzdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFdGhlcmV1bVJwY0Vycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmNsYXNzZXMuRXRoZXJldW1ScGNFcnJvciA9IEV0aGVyZXVtUnBjRXJyb3I7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxuICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIDEwMDAgPD0gNDk5OSBdIHJhbmdlLlxuICovXG52YXIgRXRoZXJldW1Qcm92aWRlckVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXRoZXJldW1ScGNFcnJvcikge1xuICBfaW5oZXJpdHMoRXRoZXJldW1Qcm92aWRlckVycm9yLCBfRXRoZXJldW1ScGNFcnJvcik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gUHJvdmlkZXIgSlNPTi1SUEMgZXJyb3IuXG4gICAqIGBjb2RlYCBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIDEwMDAgPD0gNDk5OSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgfVxuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFdGhlcmV1bVByb3ZpZGVyRXJyb3IpO1xufShFdGhlcmV1bVJwY0Vycm9yKTtcbmNsYXNzZXMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gRXRoZXJldW1Qcm92aWRlckVycm9yO1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIHV0aWxzID0ge307XG5cbnZhciBlcnJvckNvbnN0YW50cyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JDb25zdGFudHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9yQ29uc3RhbnRzLmVycm9yVmFsdWVzID0gZXJyb3JDb25zdGFudHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbmVycm9yQ29uc3RhbnRzLmVycm9yQ29kZXMgPSB7XG4gIHJwYzoge1xuICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgIHJlc291cmNlTm90Rm91bmQ6IC0zMjAwMSxcbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAtMzIwMDIsXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogLTMyMDA0LFxuICAgIGxpbWl0RXhjZWVkZWQ6IC0zMjAwNSxcbiAgICBwYXJzZTogLTMyNzAwLFxuICAgIGludmFsaWRSZXF1ZXN0OiAtMzI2MDAsXG4gICAgbWV0aG9kTm90Rm91bmQ6IC0zMjYwMSxcbiAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgaW50ZXJuYWw6IC0zMjYwM1xuICB9LFxuICBwcm92aWRlcjoge1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IDQwMDEsXG4gICAgdW5hdXRob3JpemVkOiA0MTAwLFxuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgIGRpc2Nvbm5lY3RlZDogNDkwMCxcbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogNDkwMVxuICB9XG59O1xuZXJyb3JDb25zdGFudHMuZXJyb3JWYWx1ZXMgPSB7XG4gICctMzI3MDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LidcbiAgfSxcbiAgJy0zMjYwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ1RoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuJ1xuICB9LFxuICAnLTMyNjAxJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuJ1xuICB9LFxuICAnLTMyNjAyJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLidcbiAgfSxcbiAgJy0zMjYwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEpTT04tUlBDIGVycm9yLidcbiAgfSxcbiAgJy0zMjAwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dC4nXG4gIH0sXG4gICctMzIwMDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIG5vdCBmb3VuZC4nXG4gIH0sXG4gICctMzIwMDInOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIHVuYXZhaWxhYmxlLidcbiAgfSxcbiAgJy0zMjAwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnVHJhbnNhY3Rpb24gcmVqZWN0ZWQuJ1xuICB9LFxuICAnLTMyMDA0Jzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IHN1cHBvcnRlZC4nXG4gIH0sXG4gICctMzIwMDUnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1JlcXVlc3QgbGltaXQgZXhjZWVkZWQuJ1xuICB9LFxuICAnNDAwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nXG4gIH0sXG4gICc0MTAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci4nXG4gIH0sXG4gICc0MjAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuJ1xuICB9LFxuICAnNDkwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuJ1xuICB9LFxuICAnNDkwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uJ1xuICB9XG59O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuaXNWYWxpZENvZGUgPSBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSB2b2lkIDA7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICB2YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbiAgdmFyIEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbiAgdmFyIEZBTExCQUNLX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC4nO1xuICB2YXIgRkFMTEJBQ0tfRVJST1IgPSB7XG4gICAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSlcbiAgfTtcbiAgZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJztcbiAgLyoqXG4gICAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICAgKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSkge1xuICAgIHZhciBmYWxsYmFja01lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEZBTExCQUNLX01FU1NBR0U7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgICAgaWYgKGhhc0tleShlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG4gIH1cbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBnZXRNZXNzYWdlRnJvbUNvZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gICAqIEEgY29kZSBpcyBvbmx5IHZhbGlkIGlmIGl0IGhhcyBhIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRzLmlzVmFsaWRDb2RlID0gaXNWYWxpZENvZGU7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAgICogTWVyZWx5IGNvcGllcyB0aGUgZ2l2ZW4gZXJyb3IncyB2YWx1ZXMgaWYgaXQgaXMgYWxyZWFkeSBjb21wYXRpYmxlLlxuICAgKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICAgKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLm9yaWdpbmFsRXJyb3IgcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZmFsbGJhY2tFcnJvciA9IF9yZWYuZmFsbGJhY2tFcnJvcixcbiAgICAgIGZhbGxiYWNrRXJyb3IgPSBfcmVmJGZhbGxiYWNrRXJyb3IgPT09IHZvaWQgMCA/IEZBTExCQUNLX0VSUk9SIDogX3JlZiRmYWxsYmFja0Vycm9yLFxuICAgICAgX3JlZiRzaG91bGRJbmNsdWRlU3RhID0gX3JlZi5zaG91bGRJbmNsdWRlU3RhY2ssXG4gICAgICBzaG91bGRJbmNsdWRlU3RhY2sgPSBfcmVmJHNob3VsZEluY2x1ZGVTdGEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzaG91bGRJbmNsdWRlU3RhO1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmYWxsYmFja0Vycm9yIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGZhbGxiYWNrRXJyb3IuY29kZSkgfHwgdHlwZW9mIGZhbGxiYWNrRXJyb3IubWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0ge307XG4gICAgaWYgKGVycm9yICYmIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShlcnJvcikgJiYgaGFzS2V5KGVycm9yLCAnY29kZScpICYmIGlzVmFsaWRDb2RlKGVycm9yLmNvZGUpKSB7XG4gICAgICB2YXIgX2Vycm9yID0gZXJyb3I7XG4gICAgICBzZXJpYWxpemVkLmNvZGUgPSBfZXJyb3IuY29kZTtcbiAgICAgIGlmIChfZXJyb3IubWVzc2FnZSAmJiB0eXBlb2YgX2Vycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IF9lcnJvci5tZXNzYWdlO1xuICAgICAgICBpZiAoaGFzS2V5KF9lcnJvciwgJ2RhdGEnKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IF9lcnJvci5kYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBnZXRNZXNzYWdlRnJvbUNvZGUoc2VyaWFsaXplZC5jb2RlKTtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQuY29kZSA9IGZhbGxiYWNrRXJyb3IuY29kZTtcbiAgICAgIHZhciBtZXNzYWdlID0gKF9hID0gZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogZmFsbGJhY2tFcnJvci5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICBvcmlnaW5hbEVycm9yOiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0YWNrID0gKF9iID0gZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaztcbiAgICBpZiAoc2hvdWxkSW5jbHVkZVN0YWNrICYmIGVycm9yICYmIHN0YWNrICYmIHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHNlcmlhbGl6ZUVycm9yO1xuICAvLyBJbnRlcm5hbFxuICBmdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgJiYgX3R5cGVvZihlcnJvcikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0tleShvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG59KSh1dGlscyk7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICB2YXIgX3MsXG4gICAgICBfZSxcbiAgICAgIF94LFxuICAgICAgX3IsXG4gICAgICBfYXJyID0gW10sXG4gICAgICBfbiA9ICEwLFxuICAgICAgX2QgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgIGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuO1xuICAgICAgICBfbiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSAhMCwgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgZXJyb3JzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvcnMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9ycy5ldGhFcnJvcnMgPSB2b2lkIDA7XG52YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbnZhciB1dGlsc18xID0gdXRpbHM7XG52YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbmVycm9ycy5ldGhFcnJvcnMgPSB7XG4gIHJwYzoge1xuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBQYXJzZSAoLTMyNzAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnZhbGlkUmVxdWVzdDogZnVuY3Rpb24gaW52YWxpZFJlcXVlc3QoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUGFyYW1zICgtMzI2MDIpIGVycm9yLlxuICAgICAqL1xuICAgIGludmFsaWRQYXJhbXM6IGZ1bmN0aW9uIGludmFsaWRQYXJhbXMoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXRob2ROb3RGb3VuZDogZnVuY3Rpb24gbWV0aG9kTm90Rm91bmQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgICAqL1xuICAgIGludGVybmFsOiBmdW5jdGlvbiBpbnRlcm5hbChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgICAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAtMzIwOTkgPD0gLTMyMDA1IF0gcmFuZ2UuXG4gICAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICAgKi9cbiAgICBzZXJ2ZXI6IGZ1bmN0aW9uIHNlcnZlcihvcHRzKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgX3R5cGVvZihvcHRzKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBvcHRzLmNvZGU7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZElucHV0OiBmdW5jdGlvbiBpbnZhbGlkSW5wdXQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRJbnB1dCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAgICovXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogZnVuY3Rpb24gcmVzb3VyY2VOb3RGb3VuZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBVbmF2YWlsYWJsZSAoLTMyMDAyKSBlcnJvci5cbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiBmdW5jdGlvbiByZXNvdXJjZVVuYXZhaWxhYmxlKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFRyYW5zYWN0aW9uIFJlamVjdGVkICgtMzIwMDMpIGVycm9yLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IGZ1bmN0aW9uIHRyYW5zYWN0aW9uUmVqZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAgICovXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiBmdW5jdGlvbiBtZXRob2ROb3RTdXBwb3J0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKi9cbiAgICBsaW1pdEV4Y2VlZGVkOiBmdW5jdGlvbiBsaW1pdEV4Y2VlZGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpO1xuICAgIH1cbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICAgKi9cbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiBmdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiBmdW5jdGlvbiB1bmF1dGhvcml6ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbnN1cHBvcnRlZCBNZXRob2QgKDQyMDApIGVycm9yLlxuICAgICAqL1xuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiBmdW5jdGlvbiB1bnN1cHBvcnRlZE1ldGhvZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gY2hhaW5EaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgICAqL1xuICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKG9wdHMpIHtcbiAgICAgIGlmICghb3B0cyB8fCBfdHlwZW9mKG9wdHMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gb3B0cy5jb2RlLFxuICAgICAgICBtZXNzYWdlID0gb3B0cy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gb3B0cy5kYXRhO1xuICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG4gIH1cbn07XG4vLyBJbnRlcm5hbFxuZnVuY3Rpb24gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICB2YXIgX3BhcnNlT3B0cyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHMyID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0cywgMiksXG4gICAgbWVzc2FnZSA9IF9wYXJzZU9wdHMyWzBdLFxuICAgIGRhdGEgPSBfcGFyc2VPcHRzMlsxXTtcbiAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gIHZhciBfcGFyc2VPcHRzMyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHM0ID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0czMsIDIpLFxuICAgIG1lc3NhZ2UgPSBfcGFyc2VPcHRzNFswXSxcbiAgICBkYXRhID0gX3BhcnNlT3B0czRbMV07XG4gIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcbiAgaWYgKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gYXJnLmRhdGE7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21lc3NhZ2UgfHwgdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSBleHBvcnRzLmV0aEVycm9ycyA9IGV4cG9ydHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbiAgdmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUnBjRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJldW1Qcm92aWRlckVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgdmFyIHV0aWxzXzEgPSB1dGlscztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5zZXJpYWxpemVFcnJvcjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNzYWdlRnJvbUNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGU7XG4gICAgfVxuICB9KTtcbiAgdmFyIGVycm9yc18xID0gZXJyb3JzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJldGhFcnJvcnNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZXJyb3JzXzEuZXRoRXJyb3JzO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlcnJvckNvZGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXM7XG4gICAgfVxuICB9KTtcbn0pKGRpc3QpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG5cbnZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikgO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbmNvbnN0IGlzSGV4U3RyaW5nID0gKGhleCkgPT4gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgJiYgL14weFswLTlBLUZhLWZdKiQvLnRlc3QoaGV4KTtcbmNvbnN0IHV0ZjhUb0hleCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbnZhciBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMsIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZDtcbmZ1bmN0aW9uIHBhcnNlQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjaGFpbklkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFpbklkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGNoYWluSWQsIDEwKTtcbn1cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXIgZXh0ZW5kcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkLCBycGMsIHdhbGxldFNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gJzEnOyAvLyBzYW1lIGFzIGNoYWluSWQgYnV0IGluIGRlY2ltYWxcbiAgICAgICAgLy8gc2V0dXAgY2hhaW5JZFxuICAgICAgICBpbnZhcmlhbnQoY2hhaW5JZCwgXCInY2hhaW5JZCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQoY2hhaW5JZCl9YDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQoY2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgIC8vIHNldHVwIHJwY1xuICAgICAgICB0aGlzLnJwYyA9IHJwYyB8fCBFVEhfUlBDX0xJU1RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgIGludmFyaWFudCh0aGlzLnJwYywgXCIncnBjJyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgLy8gc2V0dXAgaW5qZWN0ZWRXYWxsZXRTZXJ2ZXJcbiAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldFNlcnZlciA9IHdhbGxldFNlcnZlcjtcbiAgICAgICAgLy8gTk9URTogX2Jsb2N0byBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgeWV0IGF0IHRoaXMgcG9pbnRcbiAgICAgICAgLy8gQW55IGZ1bmN0aW9uIHNob3VsZCBjYWxsICNnZXRCbG9jdG9Qcm9wZXJ0aWVzKCkgdG8gZ2V0IHRoZSBmdWxsIF9ibG9jdG8gcHJvcGVydGllc1xuICAgICAgICB0aGlzLl9ibG9jdG8gPSB7XG4gICAgICAgICAgICBzZXNzaW9uS2V5OiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgICAgICAgICAgd2FsbGV0U2VydmVyOiB0aGlzLmluamVjdGVkV2FsbGV0U2VydmVyIHx8ICcnLFxuICAgICAgICAgICAgYmxvY2tjaGFpbk5hbWU6ICcnLFxuICAgICAgICAgICAgbmV0d29ya1R5cGU6ICcnLFxuICAgICAgICAgICAgc3VwcG9ydE5ldHdvcmtMaXN0OiB7fSxcbiAgICAgICAgICAgIHN3aXRjaGFibGVOZXR3b3JrOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2V0aGVyZXVtLXNlbmQtZGVwcmVjYXRlZFxuICAgIHNlbmQobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAxOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZCwgYXJnMiAtIGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIGV0aGVyZXVtLnNlbmQocGF5bG9hZDogSnNvblJwY1JlcXVlc3QsIGNhbGxiYWNrOiBKc29uUnBjQ2FsbGJhY2spOiB2b2lkO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGlzIGV4YWN0bHkgbGlrZSBldGhlcmV1bS5zZW5kQXN5bmMoKVxuICAgICAgICAgICAgICAgIGNhc2UgcGFyYW1zT3JDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAyOiBhcmcxIC0gSlNPTi1SUEMgbWV0aG9kIG5hbWUsIGFyZzIgLSBwYXJhbXMgYXJyYXk7XG4gICAgICAgICAgICAgICAgLy8gZXRoZXJldW0uc2VuZChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogQXJyYXk8dW5rbm93bj4pOiBQcm9taXNlPEpzb25ScGNSZXNwb25zZT47XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaWduYXR1cmUgaXMgbGlrZSBhbiBhc3luYyBldGhlcmV1bS5zZW5kQXN5bmMoKSB3aXRoIG1ldGhvZCBhbmQgcGFyYW1zIGFzIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgSlNPTi1SUEMgcGF5bG9hZCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVvZiBtZXRob2RPclBheWxvYWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyYW1zT3JDYWxsYmFjayk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kT3JQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNPckNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAzOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZChzaG91bGQgYmUgc3luY2hyb25vdXMgbWV0aG9kcylcbiAgICAgICAgICAgICAgICAvLyBldGhlcmV1bS5zZW5kKHBheWxvYWQ6IEpzb25ScGNSZXF1ZXN0KTogdW5rbm93bjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBlbmFibGVzIHlvdSB0byBjYWxsIHNvbWUgdHlwZSBvZiBSUEMgbWV0aG9kcyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2xlZ2FjeS1tZXRob2RzIGltcGxlbWVudGF0aW9uXG4gICAgLy8gd2ViMyB2MS54IEJhdGNoUmVxdWVzdCBzdGlsbCBkZXBlbmRzIG9uIGl0IHNvIHdlIG5lZWQgdG8gaW1wbGVtZW50IGFueXdheSDCr1xcXyjjg4QpXy/Cr1xuICAgIHNlbmRBc3luYyhwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlUmVxdWVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2ViMyB2MS54IGNvbmNhdCBiYXRjaGVkIEpTT04tUlBDIHJlcXVlc3RzIHRvIGFuIGFycmF5LCBoYW5kbGUgaXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdHJhbnNhY3Rpb25zIGFuZCBzZW5kIGJhdGNoIHdpdGggY3VzdG9tIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChyZXF1ZXN0KSA9PiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVxdWVzdCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSByZXF1ZXN0LnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRCYXNlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaGVkUmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdibG9jdG9fc2VuZEJhdGNoVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoUmVzcG9uc2VQcm9taXNlID0gdGhpcy5yZXF1ZXN0KGJhdGNoZWRSZXF1ZXN0UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcGF5bG9hZC5tYXAoKHsgbWV0aG9kLCBwYXJhbXMgfSwgaW5kZXgpID0+IG1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJhdGNoUmVzcG9uc2VQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkQmFzZSArIGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHJlc3BvbnNlIHdoZW4gYWxsIHJlcXVlc3QgYXJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChyZXF1ZXN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZXMpID0+IHJlc29sdmUocmVzcG9uc2VzLm1hcCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWRCYXNlICsgaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHBheWxvYWRbaW5kZXhdLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3BvbnNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzcG9uc2Uuc3RhdHVzICE9PSAnZnVsZmlsbGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgaWQ6IE51bWJlcihwYXlsb2FkLmlkKSB9KSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2sgb3IgcmV0dXJuIHByb21pc2UsIGRlcGRlbmRzIG9uIGNhbGxiYWNrIGFyZyBnaXZlbiBvciBub3RcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IGNhbGxiYWNrKG51bGwsIGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kaW5nIHVzZXJPcGVyYXRpb24gdXNpbmcgQmxvY3RvIFNESy5cbiAgICAgKiBAcGFyYW0ge0lVc2VyT3BlcmF0aW9ufSB1c2VyT3AgLSB1c2VyT3BlcmF0aW9uIG9iamVjdFxuICAgICAqIEByZW1hcmtzIE5vIG5lZWQgdG8gaW5jbHVkZSBub25jZSwgaW5pdENvZGUsIGFuZCBzaWduYXR1cmUgYXMgcGFyYW1ldGVycyB3aGVuIHVzaW5nIEJsb2N0b1NESyB0byBzZW5kIHVzZXJPcGVyYXRpb24uXG4gICAgICogVGhlc2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSB1c2VyT3BlcmF0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBzZW5kVXNlck9wZXJhdGlvbih1c2VyT3ApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kVXNlck9wZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdXNlck9wXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5tZXRob2QpKVxuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCgpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BhcnNlQ2hhaW5JZCgoX2EgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0uY2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGFyc2VDaGFpbklkKChfYiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXS5jaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gKF9jID0gc3dpdGNoYWJsZU5ldHdvcmsgPT09IG51bGwgfHwgc3dpdGNoYWJsZU5ldHdvcmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tjaGFpbk5hbWUsIHN3aXRjaGFibGVOZXR3b3JrLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBtZXRob2QgdGhhdCBkb2Vzbid0IHJlcXVpcmUgdXNlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfY2hhaW5JZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV0X3ZlcnNpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFN3aXRjaGFibGVOZXR3b3JrKChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9jYWxsJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKChfYyA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5lcnJvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKChfZSA9IChfZCA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNoYWluSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgc3dpdGNoIG5ldHdvcmsgaWYgdXNlciBpcyBub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgYSBjb25maXJtIHN3aXRjaCBuZXR3b3JrIGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGhhc2VkQ2hhaW5JZCA9IHBhcnNlQ2hhaW5JZChuZXdDaGFpbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3dpdGNoYWJsZU5ldHdvcmtbcGhhc2VkQ2hhaW5JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtuZXdDaGFpbklkfVwiLiBUcnkgYWRkaW5nIHRoZSBjaGFpbiB1c2luZyB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbiBmaXJzdC5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BoYXNlZENoYWluSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGhhc2VkQ2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbcGhhc2VkQ2hhaW5JZF0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2hhaW5DaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ldGhvZCB0aGF0IHJlcXVpcmVzIHVzZXIgdG8gYmUgY29ubmVjdGVkXG4gICAgICAgICAgICBpZiAoIWdldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IChfZiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfcmVxdWVzdEFjY291bnRzJyAmJiBpc0VtYWlsKGVtYWlsKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZShlbWFpbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5mZXRjaEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfYWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfY29pbmJhc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoX2cgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YV92Myc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwZXJzb25hbF9zaWduJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNpZ24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfZGlzY29ubmVjdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmxvY3RvX3NlbmRCYXRjaFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZEJhdGNoVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIHBheWxvYWQubWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFVzZXJPcGVyYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKChfaiA9IChfaCA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZEFjY291bnQgPSAoX2sgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2tbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRDaGFpbklkID0gdGhpcy5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaGFibGVOZXR3b3JrW3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtwYXJzZUNoYWluSWQocGF5bG9hZC5wYXJhbXNbMF0uY2hhaW5JZCl9XCIuIFRyeSBhZGRpbmcgdGhlIGNoYWluIHVzaW5nIHdhbGxldF9hZGRFdGhlcmV1bUNoYWluIGZpcnN0LmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKG5ld0NoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbdGhpcy5uZXR3b3JrVmVyc2lvbl0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoW25ld0FjY291bnRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdBY2NvdW50ICE9PSBvbGRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50c0NoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKFtuZXdBY2NvdW50XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQob2xkQ2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChvbGRDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZVVzZXJPcGVyYXRpb25HYXMnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfZ2V0VXNlck9wZXJhdGlvbkJ5SGFzaCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9nZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zdXBwb3J0ZWRFbnRyeVBvaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZUJ1bmRsZXIocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgdGhpcy5oYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmxvY3RvQXBpKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXkgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZShzZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt3YWxsZXRTZXJ2ZXJ9L2FwaS8ke2Jsb2NrY2hhaW5OYW1lfSR7dXJsfWAsIE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0gfSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgc2Vzc2lvbktleSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmVycm9yX2NvZGUpID09PSAndW5zdXBwb3J0ZWRfbWV0aG9kJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuc2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IC0zMjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBCbG9jdG8gc2VydmVyIGVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3BvbnNlTGlzdGVuZXIoZnJhbWUsIG9iamVjdEtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YVtvYmplY3RLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChlLmRhdGEuZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVc2VyIGRlY2xpbmVkIHRoZSByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldElmcmFtZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDEwMDEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdCbG9jdG8gU0RLIG9ubHkgd29ya3MgaW4gYnJvd3NlciBlbnZpcm9ubWVudCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gY3JlYXRlRnJhbWUoYCR7d2FsbGV0U2VydmVyfS8ke3RoaXMuYXBwSWR9LyR7YmxvY2tjaGFpbk5hbWV9JHt1cmx9YCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlaXAtMTEwMiBhbGlhc1xuICAgIC8vIERFUFJFQ0FURUQgQVBJOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9ibG9iL21hc3Rlci9FSVBTL2VpcC0xMTAyLm1kXG4gICAgZW5hYmxlKGVtYWlsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXkgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuZXRoZXJldW07XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsuY2hhaW5JZCAhPT0gdGhpcy5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSwgW2V4aXN0ZWRTREsuYWRkcmVzc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc21hbGwgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIHN3aXRjaGVkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBleGlzdGVkU0RLLmVuYWJsZSgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2w2bicsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgndicsIFNES19WRVJTSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGVtYWlsUGFyYW0gPSBlbWFpbCAmJiBpc0VtYWlsKGVtYWlsKSA/IGAvJHtlbWFpbH1gIDogJyc7XG4gICAgICAgICAgICBjb25zdCBsb2dpbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC9hdXRobiR7ZW1haWxQYXJhbX0/JHtwYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2Uoc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Jsb2NrY2hhaW5OYW1lXTogW2UuZGF0YS5hZGRyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlLmRhdGEuZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtlLmRhdGEuYWRkcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2FjY291bnRzYCk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5ycGMsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTaWduKHsgbWV0aG9kLCBwYXJhbXMgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnZXRoX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBpc0hleFN0cmluZyhwYXJhbXNbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1sxXS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1dGY4VG9IZXgocGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAncGVyc29uYWxfc2lnbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGlzSGV4U3RyaW5nKHBhcmFtc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyYW1zWzBdLnNsaWNlKDIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHV0ZjhUb0hleChwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YV92MycsXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YV92NCcsXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZG9tYWluLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgUHJvdmlkZWQgY2hhaW5JZCBcIiR7ZG9tYWluLmNoYWluSWR9XCIgbXVzdCBiZSBhIG51bWJlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUNoYWluSWQoZG9tYWluLmNoYWluSWQpICE9PSBwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFByb3ZpZGVkIGNoYWluSWQgXCIke2RvbWFpbi5jaGFpbklkfVwiIG11c3QgbWF0Y2ggdGhlIGFjdGl2ZSBjaGFpbklkIFwiJHtwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBzaWduYXR1cmVJZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLXNpZ25hdHVyZWAsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbWV0aG9kLCBtZXNzYWdlIH0pIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLXNpZ25hdHVyZS8ke3NpZ25hdHVyZUlkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VMaXN0ZW5lcihzaWduRnJhbWUsICdzaWduYXR1cmUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRyYW5zYWN0aW9uKChfYSA9IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbklkIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2F1dGh6YCwgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpIH0pO1xuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvYXV0aHovJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKGF1dGh6RnJhbWUsICd0eEhhc2gnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RQYXJhbXMgPSAocGFyYW1zKSA9PiBwYXJhbXMubWFwKChwYXJhbSkgPT4gJ3BhcmFtcycgaW4gcGFyYW1cbiAgICAgICAgICAgICAgICA/IHBhcmFtLnBhcmFtc1swXSAvLyBoYW5kbGUgcGFzc2luZyB3ZWIzLmV0aC5zZW5kVHJhbnNhY3Rpb24ucmVxdWVzdCguLi4pIGFzIGEgcGFyYW1ldGVyIHdpdGggcGFyYW1zXG4gICAgICAgICAgICAgICAgOiBwYXJhbSk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRQYXJhbXMgPSBleHRyYWN0UGFyYW1zKHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKSwgeyBwYXJhbXM6IGZvcm1hdFBhcmFtcyB9KTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRyYW5zYWN0aW9ucyhjb3B5UGF5bG9hZC5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbmRUcmFuc2FjdGlvbihjb3B5UGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLW9wZXJhdGlvbmAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJPUEZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLW9wZXJhdGlvbi8ke2F1dGhvcml6YXRpb25JZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIodXNlck9QRnJhbWUsICd1c2VyT3BIYXNoJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVCdW5kbGVyKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2N0b0FwaShgL3JwYy9idW5kbGVyYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBpZDogMSwganNvbnJwYzogJzIuMCcgfSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmV0aGVyZXVtO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJlbW92ZUNoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRTd2l0Y2hhYmxlTmV0d29yayhuZXR3b3JrTGlzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gc2V0dXAgc3dpdGNoYWJsZSBsaXN0IGlmIHVzZXIgc2V0IG5ldHdvcmtMaXN0XG4gICAgICAgICAgICBpZiAobmV0d29ya0xpc3QgPT09IG51bGwgfHwgbmV0d29ya0xpc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ldHdvcmtMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb0FkZCA9IG5ldHdvcmtMaXN0Lm1hcCgoeyBjaGFpbklkLCBycGNVcmxzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IGNoYWluSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnBjVXJscyA9PT0gbnVsbCB8fCBycGNVcmxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBycGNVcmxzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnRW1wdHkgcnBjVXJscycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogYCR7cGFyc2VDaGFpbklkKGNoYWluSWQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdFRvQWRkKS50aGVuKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IG5ldHdvcmtMaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMgPSBmdW5jdGlvbiBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5fYmxvY3RvLnN1cHBvcnROZXR3b3JrTGlzdCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB5aWVsZCBnZXRFdm1TdXBwb3J0KClcbiAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiAodGhpcy5fYmxvY3RvLnN1cHBvcnROZXR3b3JrTGlzdCA9IHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEdldCBibG9jdG8gc2VydmVyIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIG5ldHdvcmtfdHlwZSwgYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnQsIGRpc3BsYXlfbmFtZSwgfSA9IHRoaXMuX2Jsb2N0by5zdXBwb3J0TmV0d29ya0xpc3RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgIGlmICghY2hhaW5faWQpXG4gICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZChgR2V0IHN1cHBvcnQgY2hhaW4gZmFpbGVkOiAke3RoaXMubmV0d29ya1ZlcnNpb259IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgeWV0LmApO1xuICAgICAgICB0aGlzLl9ibG9jdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0byksIHsgc2Vzc2lvbktleTogRVRIX1NFU1NJT05fS0VZX01BUFBJTkdbYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnRdLCB3YWxsZXRTZXJ2ZXI6IHRoaXMuaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIgfHxcbiAgICAgICAgICAgICAgICBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF0sIGJsb2NrY2hhaW5OYW1lOiBuYW1lLCBuZXR3b3JrVHlwZTogbmV0d29ya190eXBlLCBzd2l0Y2hhYmxlTmV0d29yazogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9ibG9jdG8uc3dpdGNoYWJsZU5ldHdvcmspLCB7IFtjaGFpbl9pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldF93ZWJfdXJsOiB0aGlzLl9ibG9jdG8ud2FsbGV0U2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBycGNfdXJsOiB0aGlzLnJwYyxcbiAgICAgICAgICAgICAgICB9IH0pIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY3RvO1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlKHsgY2hhaW5JZCwgcnBjVXJscywgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgc3VwcG9ydE5ldHdvcmtMaXN0IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIGRpc3BsYXlfbmFtZSwgbmV0d29ya190eXBlLCBibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCwgfSA9IHN1cHBvcnROZXR3b3JrTGlzdFtjaGFpbklkXTtcbiAgICAgICAgY29uc3Qgd2FsbGV0X3dlYl91cmwgPSBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF07XG4gICAgICAgIHRoaXMuX2Jsb2N0by5zd2l0Y2hhYmxlTmV0d29ya1tjaGFpbl9pZF0gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgbmV0d29ya190eXBlLFxuICAgICAgICAgICAgd2FsbGV0X3dlYl91cmwsXG4gICAgICAgICAgICBycGNfdXJsOiBycGNVcmxzWzBdLFxuICAgICAgICB9O1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQoKSB7XG4gICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICBpZiAoZXhpc3RlZFNESyAmJlxuICAgICAgICBleGlzdGVkU0RLLmlzQmxvY3RvICYmXG4gICAgICAgIHBhcnNlQ2hhaW5JZChleGlzdGVkU0RLLmNoYWluSWQpICE9PSBwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKSkge1xuICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5cbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSk7XG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpOyAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTsgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgOyBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMDtcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dO1xuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrO1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpO1xuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTsgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCkgfVxuICAgIHZhciBwc3ogPSAwO1xuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDA7IC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMDtcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG52YXIgc3JjID0gYmFzZTtcblxuY29uc3QgYmFzZXggPSBzcmM7XG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcblxudmFyIGJzNTggPSBiYXNleChBTFBIQUJFVCk7XG5cbnZhciBiczU4JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnM1OCk7XG5cbmxldCBTb2xhbmE7XG50cnkge1xuICAgIFNvbGFuYSA9IHJlcXVpcmUoJ0Bzb2xhbmEvd2ViMy5qcycpO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgLy8gcHJldmVudCBjcmFzaCBpZiB0aGVyZSBpcyBubyBAc29sYW5hL3dlYjMuanMuXG59XG5jbGFzcyBTb2xhbmFQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5ldCA9ICdtYWlubmV0LWJldGEnLCBzZXJ2ZXIsIGFwcElkLCBycGMsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaW52YXJpYW50KG5ldCwgXCInbmV0JyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgaW52YXJpYW50KE9iamVjdC52YWx1ZXMoU09MX05FVCkuaW5jbHVkZXMobmV0KSwgJ3Vuc3VwcG9ydGVkIG5ldCcpO1xuICAgICAgICB0aGlzLm5ldCA9IG5ldDtcbiAgICAgICAgdGhpcy5ycGMgPVxuICAgICAgICAgICAgcnBjIHx8XG4gICAgICAgICAgICAgICAgKG5ldCA9PT0gJ21haW5uZXQtYmV0YSdcbiAgICAgICAgICAgICAgICAgICAgPyAnaHR0cHM6Ly9mcmVlLnJwY3Bvb2wuY29tJ1xuICAgICAgICAgICAgICAgICAgICA6IGBodHRwczovL2FwaS4ke25ldH0uc29sYW5hLmNvbWApO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlciB8fCBTT0xfTkVUX1NFUlZFUl9NQVBQSU5HW3RoaXMubmV0XSB8fCAnJztcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgICAgICB0aGlzLnNlc3Npb25LZXkgPSBTT0xfU0VTU0lPTl9LRVlfTUFQUElOR1t0aGlzLm5ldF07XG4gICAgICAgIGlmICghU29sYW5hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEBzb2xhbmEvd2ViMy5qcyBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIGl0IHRvIGludGVyYWN0IHdpdGggU29sYW5hLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LnNvbGFuYTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RlZFNESy5yZXF1ZXN0KHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuZmV0Y2hBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0QWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLlNPTEFOQSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5aWVsZCB0aGlzLmZldGNoQWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRBY2NvdW50SW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgZGF0YSBhcyB0aGUgc2FtZSBmb3JtYXQgcmV0dXJuaW5nIGZyb20gQ29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyBmcm9tIEBzb2xhbmEvd2ViMy5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmOiBodHRwczovL3NvbGFuYS1sYWJzLmdpdGh1Yi5pby9zb2xhbmEtd2ViMy5qcy9jbGFzc2VzL0Nvbm5lY3Rpb24uaHRtbCNnZXRBY2NvdW50SW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtidWZmZXJEYXRhLCBlbmNvZGluZ10gPSBhY2NvdW50SW5mby5yZXN1bHQudmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudEluZm8ucmVzdWx0LnZhbHVlKSwgeyBkYXRhOiBCdWZmZXIuZnJvbShidWZmZXJEYXRhLCBlbmNvZGluZyksIG93bmVyOiBuZXcgU29sYW5hLlB1YmxpY0tleShhY2NvdW50SW5mby5yZXN1bHQudmFsdWUub3duZXIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIEpTT04tUlBDIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb252ZXJ0VG9Qcm9ncmFtV2FsbGV0VHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVDb252ZXJ0VHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIEpTT04tUlBDIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduQW5kU2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBibG9jayB1c2VyIGZyb20gdXNpbmcgdHJhZGl0aW9uYWwgbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduQWxsVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY3RvIGlzIHByb2dyYW0gd2FsbGV0LCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgJHtwYXlsb2FkLm1ldGhvZH0uIFVzZSBzaWduQW5kU2VuZFRyYW5zYWN0aW9uIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLnJlc3VsdCAmJiByZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1JlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ZWRTREsub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLnB1YmxpY0tleS50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0N1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9zb2xhbmEvYXV0aG4/bDZuPSR7bG9jYXRpb259JnY9JHtTREtfVkVSU0lPTn1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdTT0w6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLm5ldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NIQUlOLlNPTEFOQV06IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5kYXRhLmV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgZGVjbGluZWQgdGhlIGxvZ2luIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuc29sYW5hO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIobnVsbCkpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL3NvbGFuYS9hY2NvdW50c2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgdGhpcy5zZXNzaW9uS2V5KSk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5ycGMsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIGNvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuY29udmVydFRvUHJvZ3JhbVdhbGxldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2NvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9UcmFuc2FjdGlvbihtZXNzYWdlLCBbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzb2xhbmEgd2ViMyB1dGlsaXR5XG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jb21taXRtZW50KVxuICAgICAgICAgICAgICAgICAgICBleHRyYS5jb21taXRtZW50ID0gY29ubmVjdGlvbi5jb21taXRtZW50O1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0aW9uIG9iamVjdCBwYXNzZWQtaW4gaGFzIGRpZmZlcmVudCBycGMgZW5kcG9pbnQsIHJlY29ubmVjdCB0byBpdFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJwYyA9IGNvbm5lY3Rpb24gPyBjb25uZWN0aW9uLl9ycGNFbmRwb2ludCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJwYyAmJiBycGMgIT09IHRoaXMucnBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHsgc2lnbmF0dXJlczogeWllbGQgdGhpcy5jb2xsZWN0U2lnbmF0dXJlcyh0cmFuc2FjdGlvbiksIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZygnaGV4JykgfSwgZXh0cmEpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzb2xhbmEgd2ViMyB1dGlsaXR5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICB0b1RyYW5zYWN0aW9uKHJhdywgc2lnbmF0dXJlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFNvbGFuYS5NZXNzYWdlLmZyb20oQnVmZmVyLmZyb20ocmF3LCAnaGV4JykpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgU29sYW5hLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnUHVia2V5UGFpciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUgPT09IFNvbGFuYS5QdWJsaWNLZXkuZGVmYXVsdC50b0Jhc2U1OCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYnM1OCQxLmRlY29kZShzaWduYXR1cmUpLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKChpbnN0cnVjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoKGFjY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmVyOiBhY2NvdW50IDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNXcml0YWJsZTogbWVzc2FnZS5pc0FjY291bnRXcml0YWJsZShhY2NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMucHVzaChuZXcgU29sYW5hLlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBiczU4JDEuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgY29sbGVjdFNpZ25hdHVyZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbY3VyLnB1YmxpY0tleS50b0Jhc2U1OCgpXSA9IGN1ci5zaWduYXR1cmUudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ29udmVydFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL3NvbGFuYS9jb252ZXJ0VG9XYWxsZXRUeGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9zb2xhbmEvYXV0aHpgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9zb2xhbmEvYXV0aHovJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEudHhIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGNoZWNrTWVzc2FnZVBheWxvYWRGb3JtYXQgPSAocGF5bG9hZCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZm9ybWF0dGVkUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgbm9uY2UsIGFkZHJlc3MsIGFwcGxpY2F0aW9uLCBjaGFpbklkIH0gPSBwYXlsb2FkO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5tZXNzYWdlID0gKF9hID0gU3RyaW5nKG1lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub25jZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5ub25jZSA9IChfYiA9IFN0cmluZyhub25jZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYWRkcmVzcyA9ICEhYWRkcmVzcztcbiAgICB9XG4gICAgaWYgKGFwcGxpY2F0aW9uICYmIHR5cGVvZiBhcHBsaWNhdGlvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYXBwbGljYXRpb24gPSAhIWFwcGxpY2F0aW9uO1xuICAgIH1cbiAgICBpZiAoY2hhaW5JZCAmJiB0eXBlb2YgY2hhaW5JZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuY2hhaW5JZCA9ICEhY2hhaW5JZDtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZFBheWxvYWQ7XG59O1xuY2xhc3MgQXB0b3NQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQsIHNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IFtdO1xuICAgICAgICB0aGlzLmF1dGhLZXkgPSAnJztcbiAgICAgICAgaW52YXJpYW50KGNoYWluSWQsIFwiJ2NoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwSWQsICdJdCBpcyBuZWNlc3NhcnkgdG8gaW50ZXJhY3Qgd2l0aCBCbG9jdG8gd2FsbGV0IHZpYSB5b3VyIGFwcCBpZC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZGV2ZWxvcGVycy5ibG9jdG8uYXBwIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMubmV0d29ya05hbWUgPSBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICB0aGlzLmFwaSA9IEFQVF9DSEFJTl9JRF9SUENfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgdGhpcy5zZXNzaW9uS2V5ID0gQVBUX1NFU1NJT05fS0VZX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXJ2ZXIgPSBBUFRfQ0hBSU5fSURfU0VSVkVSX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXIgfHwgZGVmYXVsdFNlcnZlciB8fCAnJztcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0FjY291bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkubGVuZ3RoID8gdGhpcy5wdWJsaWNLZXkgOiBudWxsLFxuICAgICAgICAgICAgLy8gQHRvZG86IHByb3ZpZGUgYXV0aGtleVxuICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduVHJhbnNhY3Rpb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZXhpc3RlZFNESy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9hcHRvcy9hdXRoemAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uKSwgdHhPcHRpb25zKSksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IGNyZWF0ZUZyYW1lKGAke3RoaXMuc2VydmVyfS8ke3RoaXMuYXBwSWR9L2FwdG9zL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGhhc2g6IGUuZGF0YS50eEhhc2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQYXlsb2FkID0gY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdChwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbk1lc3NhZ2UoZm9ybWF0dGVkUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvdXNlci1zaWduYXR1cmVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZm9ybWF0dGVkUGF5bG9hZCksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vYXB0b3MvdXNlci1zaWduYXR1cmUvJHtzaWduYXR1cmVJZH1gO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0gY3JlYXRlRnJhbWUodXJsKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzbWFsbCBkZWxheSB0byBtYWtlIHN1cmUgdGhlIG5ldHdvcmsgaGFzIGJlZW4gc3dpdGNoZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV4aXN0ZWRTREsuY29ubmVjdCgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoKF9iID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9hcHRvcy9hdXRobj9sNm49JHtsb2NhdGlvbn0mdj0ke1NES19WRVJTSU9OfX1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnQVBUT1M6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGUuZGF0YS5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ0hBSU4uQVBUT1NdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2MgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGljX2tleXM6IHB1YmxpY0tleXMgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9ibG9jdG8vYXB0b3MvYWNjb3VudHMvJHsoX2QgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXX1gKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6ICgoX2UgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoS2V5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBiZXR0ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgZGVjbGluZWQgdGhlIGxvZ2luIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWRkcmVzcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvYWNjb3VudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgc2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiAoYWNjb3VudHMgPT09IG51bGwgfHwgYWNjb3VudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjY291bnRzWzBdKSB8fCAnJztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBCbG9jdG9TREsge1xuICAgIGNvbnN0cnVjdG9yKHsgYXBwSWQsIGV0aGVyZXVtLCBzb2xhbmEsIGFwdG9zIH0pIHtcbiAgICAgICAgaWYgKGV0aGVyZXVtKSB7XG4gICAgICAgICAgICB0aGlzLmV0aGVyZXVtID0gbmV3IEV0aGVyZXVtUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldGhlcmV1bSksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2xhbmEpIHtcbiAgICAgICAgICAgIHRoaXMuc29sYW5hID0gbmV3IFNvbGFuYVByb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc29sYW5hKSwgeyBhcHBJZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwdG9zKSB7XG4gICAgICAgICAgICB0aGlzLmFwdG9zID0gbmV3IEFwdG9zUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcHRvcyksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBCbG9jdG9TREsgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImRlZmF1bHQiLCJCbG9jdG9TREsiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsImdldCIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsIm5hbWUiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJLRVlfU0VTU0lPTiIsIkNIQUlOIiwiTWVtb3J5U3RvcmFnZSIsImNvbnN0cnVjdG9yIiwic3RvcmFnZSIsImdldEl0ZW0iLCJrZXkiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm1lbW9yeVN0b3JhZ2UiLCJ3aW5kb3ciLCJpc1N1cHBvcnRlZCIsInNlc3Npb25TdG9yYWdlIiwiZGVmYXVsdFZhbHVlIiwiSlNPTiIsInBhcnNlIiwiU3ludGF4RXJyb3IiLCJzdHJpbmdpZnkiLCJnZXRBY2NvdW50U3RvcmFnZSIsInJhd0FjY291bnRTdG9yYWdlIiwiRGF0ZSIsImdldFRpbWUiLCJleHBpcnkiLCJ2IiwiU0RLX1ZFUlNJT04iLCJkYXRhIiwic2V0QWNjb3VudFN0b3JhZ2UiLCJfYSIsIl9iIiwiX2MiLCJuZXdBY2NvdW50U3RvcmFnZSIsImNvZGUiLCJjb25uZWN0ZWQiLCJhY2NvdW50cyIsIk9iamVjdCIsImFzc2lnbiIsIkxPR0lOX1BFUlNJU1RJTkdfVElNRSIsImdldENoYWluQWRkcmVzcyIsImNoYWluIiwic2V0Q2hhaW5BZGRyZXNzIiwiYWNjb3VudCIsInJlbW92ZUNoYWluQWRkcmVzcyIsInVuZGVmaW5lZCIsIkVUSF9SUENfTElTVCIsIkVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HIiwicHJvZCIsInN0YWdpbmciLCJkZXYiLCJFVEhfU0VTU0lPTl9LRVlfTUFQUElORyIsIlNPTF9ORVQiLCJNYWlubmV0QmV0YSIsIlRlc3RuZXQiLCJEZXZuZXQiLCJTT0xfTkVUX1NFUlZFUl9NQVBQSU5HIiwiU09MX1NFU1NJT05fS0VZX01BUFBJTkciLCJBUFRfU0VTU0lPTl9LRVlfTUFQUElORyIsIkFQVF9DSEFJTl9JRF9TRVJWRVJfTUFQUElORyIsIldhbGxldEFkYXB0ZXJOZXR3b3JrIiwiQVBUX0NIQUlOX0lEX05BTUVfTUFQUElORyIsIk1haW5uZXQiLCJUZXN0aW5nIiwiUHJlbWFpbm5ldCIsIkFQVF9DSEFJTl9JRF9SUENfTUFQUElORyIsIkVJUDExOTNfRVZFTlRTIiwiREVGQVVMVF9BUFBfSUQiLCJCbG9jdG9Qcm92aWRlciIsImlzQmxvY3RvIiwiaXNDb25uZWN0aW5nIiwiZXZlbnRMaXN0ZW5lcnMiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsImZvckVhY2giLCJldmVudCIsImFwcElkIiwicmVxdWVzdCIsInBheWxvYWQiLCJvbiIsImxpc3RlbmVyIiwiaW5jbHVkZXMiLCJwdXNoIiwib25jZSIsImxpc3RlbmVycyIsImluZGV4IiwiZmluZEluZGV4IiwiaXRlbSIsInNwbGljZSIsIklGUkFNRV9TVFlMRSIsImNyZWF0ZUZyYW1lIiwidXJsIiwiZnJhbWUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhdHRhY2hGcmFtZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImRldGF0Y2hGcmFtZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkZ1bmN0aW9uIiwiYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIiLCJldmVudFR5cGUiLCJoYW5kbGVyIiwidGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNwb25zZVNlc3Npb25HdWFyZCIsInJlc3BvbnNlIiwiZGlzY29ubmVjdEhhbmRsZXIiLCJzdGF0dXMiLCJvayIsImpzb24iLCJlcnJvcl9jb2RlIiwiaXNFbWFpbCIsInRlc3QiLCJpc1ZhbGlkVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImlzVmFsaWRUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsInR4IiwiZ2V0RXZtU3VwcG9ydCIsIm5ldHdvcmtzIiwiZmV0Y2giLCJldm1TdXBwb3J0TWFwIiwicmVkdWNlIiwiYSIsImNoYWluX2lkIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiZGlzdCIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJyZXMiLCJTdHJpbmciLCJOdW1iZXIiLCJfdG9Qcm9wZXJ0eUtleSIsImFyZyIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3NldFByb3RvdHlwZU9mIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfZ2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiZm4iLCJ0b1N0cmluZyIsImluZGV4T2YiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiYXJncyIsIkNsYXNzIiwiYXJndW1lbnRzIiwiX3dyYXBOYXRpdmVTdXBlciIsIl9jYWNoZSIsIk1hcCIsInNldCIsIldyYXBwZXIiLCJjbGFzc2VzIiwiZmFzdFNhZmVTdHJpbmdpZnkiLCJzdGFibGUiLCJkZXRlcm1pbmlzdGljU3RyaW5naWZ5Iiwic3RhYmxlU3RyaW5naWZ5IiwiTElNSVRfUkVQTEFDRV9OT0RFIiwiQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFIiwiYXJyIiwicmVwbGFjZXJTdGFjayIsImRlZmF1bHRPcHRpb25zIiwiZGVwdGhMaW1pdCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJlZGdlc0xpbWl0IiwicmVwbGFjZXIiLCJzcGFjZXIiLCJvcHRpb25zIiwiZGVjaXJjIiwicmVwbGFjZUdldHRlclZhbHVlcyIsIl8iLCJwYXJ0IiwicG9wIiwic2V0UmVwbGFjZSIsInJlcGxhY2UiLCJ2YWwiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImtleXMiLCJjb21wYXJlRnVuY3Rpb24iLCJiIiwidG1wIiwiZGV0ZXJtaW5pc3RpY0RlY2lyYyIsInRvSlNPTiIsInNvcnQiLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiTmV3VGFyZ2V0IiwiRXRoZXJldW1Qcm92aWRlckVycm9yIiwiRXRoZXJldW1ScGNFcnJvciIsImZhc3Rfc2FmZV9zdHJpbmdpZnlfMSIsIl9FcnJvciIsIl9zdXBlciIsIl90aGlzIiwiaXNJbnRlZ2VyIiwic2VyaWFsaXplIiwic2VyaWFsaXplZCIsInN0cmluZ2lmeVJlcGxhY2VyIiwiX0V0aGVyZXVtUnBjRXJyb3IiLCJfc3VwZXIyIiwiaXNWYWxpZEV0aFByb3ZpZGVyQ29kZSIsInV0aWxzIiwiZXJyb3JDb25zdGFudHMiLCJlcnJvclZhbHVlcyIsImVycm9yQ29kZXMiLCJycGMiLCJpbnZhbGlkSW5wdXQiLCJyZXNvdXJjZU5vdEZvdW5kIiwicmVzb3VyY2VVbmF2YWlsYWJsZSIsInRyYW5zYWN0aW9uUmVqZWN0ZWQiLCJtZXRob2ROb3RTdXBwb3J0ZWQiLCJsaW1pdEV4Y2VlZGVkIiwiaW52YWxpZFJlcXVlc3QiLCJtZXRob2ROb3RGb3VuZCIsImludmFsaWRQYXJhbXMiLCJpbnRlcm5hbCIsInByb3ZpZGVyIiwidXNlclJlamVjdGVkUmVxdWVzdCIsInVuYXV0aG9yaXplZCIsInVuc3VwcG9ydGVkTWV0aG9kIiwiZGlzY29ubmVjdGVkIiwiY2hhaW5EaXNjb25uZWN0ZWQiLCJzdGFuZGFyZCIsImV4cG9ydHMiLCJzZXJpYWxpemVFcnJvciIsImlzVmFsaWRDb2RlIiwiZ2V0TWVzc2FnZUZyb21Db2RlIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UiLCJlcnJvcl9jb25zdGFudHNfMSIsImNsYXNzZXNfMSIsIkZBTExCQUNLX0VSUk9SX0NPREUiLCJGQUxMQkFDS19NRVNTQUdFIiwiRkFMTEJBQ0tfRVJST1IiLCJmYWxsYmFja01lc3NhZ2UiLCJjb2RlU3RyaW5nIiwiaGFzS2V5IiwiaXNKc29uUnBjU2VydmVyRXJyb3IiLCJfcmVmIiwiX3JlZiRmYWxsYmFja0Vycm9yIiwiZmFsbGJhY2tFcnJvciIsIl9yZWYkc2hvdWxkSW5jbHVkZVN0YSIsInNob3VsZEluY2x1ZGVTdGFjayIsIl9lcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJhc3NpZ25PcmlnaW5hbEVycm9yIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX2kiLCJfcyIsIl9lIiwiX3giLCJfciIsIl9hcnIiLCJfbiIsIl9kIiwiZXJyIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJsZW4iLCJhcnIyIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibWluTGVuIiwibiIsInNsaWNlIiwiZnJvbSIsIl9ub25JdGVyYWJsZVJlc3QiLCJfc2xpY2VkVG9BcnJheSIsImVycm9ycyIsImV0aEVycm9ycyIsInV0aWxzXzEiLCJnZXRFdGhKc29uUnBjRXJyb3IiLCJzZXJ2ZXIiLCJvcHRzIiwiZ2V0RXRoUHJvdmlkZXJFcnJvciIsImN1c3RvbSIsIl9wYXJzZU9wdHMiLCJwYXJzZU9wdHMiLCJfcGFyc2VPcHRzMiIsIl9wYXJzZU9wdHMzIiwiX3BhcnNlT3B0czQiLCJlcnJvcnNfMSIsImdsb2JhbCQxIiwiZ2xvYmFsIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImluaXRlZCIsImluaXQiLCJjaGFyQ29kZUF0IiwidG9CeXRlQXJyYXkiLCJiNjQiLCJqIiwibCIsInBsYWNlSG9sZGVycyIsIkwiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJqb2luIiwiZnJvbUJ5dGVBcnJheSIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsInJlYWQiLCJidWZmZXIiLCJvZmZzZXQiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsIm0iLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJkIiwicyIsIk5hTiIsIkluZmluaXR5IiwiTWF0aCIsInBvdyIsIndyaXRlIiwiYyIsInJ0IiwiYWJzIiwiaXNOYU4iLCJmbG9vciIsImxvZyIsIkxOMiIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiQnVmZmVyIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImtNYXhMZW5ndGgiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0Iiwic3BlY2llcyIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImJ5dGVMZW5ndGgiLCJhY3R1YWwiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJieXRlT2Zmc2V0IiwiaW50ZXJuYWxJc0J1ZmZlciIsImNvcHkiLCJpc25hbiIsInR5cGUiLCJpc0J1ZmZlciIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJ5IiwibWluIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJtYXRjaCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImRpciIsImFycmF5SW5kZXhPZiIsImxhc3RJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwiZnJvbUNoYXJDb2RlIiwicmV0Iiwib3V0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInN1YmFycmF5Iiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJvYmplY3RXcml0ZVVJbnQzMiIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwic3ViIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInRyaW0iLCJ1bml0cyIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwic3JjIiwiZHN0IiwiaXNGYXN0QnVmZmVyIiwiaXNTbG93QnVmZmVyIiwiaXNIZXhTdHJpbmciLCJoZXgiLCJ1dGY4VG9IZXgiLCJfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMiLCJfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzIiwiX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlIiwiX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCIsInBhcnNlQ2hhaW5JZCIsImNoYWluSWQiLCJzdGFydHNXaXRoIiwiRXRoZXJldW1Qcm92aWRlciIsIndhbGxldFNlcnZlciIsImFkZCIsIm5ldHdvcmtWZXJzaW9uIiwiaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIiLCJfYmxvY3RvIiwic2Vzc2lvbktleSIsImJsb2NrY2hhaW5OYW1lIiwibmV0d29ya1R5cGUiLCJzdXBwb3J0TmV0d29ya0xpc3QiLCJzd2l0Y2hhYmxlTmV0d29yayIsInNlbmQiLCJtZXRob2RPclBheWxvYWQiLCJwYXJhbXNPckNhbGxiYWNrIiwic2VuZEFzeW5jIiwianNvbnJwYyIsIm1ldGhvZCIsInBhcmFtcyIsImNhbGxiYWNrIiwiaGFuZGxlUmVxdWVzdCIsImZpbHRlciIsIm1hcCIsImlkQmFzZSIsInJhbmRvbSIsImJhdGNoZWRSZXF1ZXN0UGF5bG9hZCIsImJhdGNoUmVzcG9uc2VQcm9taXNlIiwicmVxdWVzdHMiLCJpZCIsImFsbFNldHRsZWQiLCJyZXNwb25zZXMiLCJyZWFzb24iLCJjYXRjaCIsInNlbmRVc2VyT3BlcmF0aW9uIiwidXNlck9wIiwiX2YiLCJfZyIsIl9oIiwiX2oiLCJfayIsImV4aXN0ZWRTREsiLCJldGhlcmV1bSIsInJwY191cmwiLCJsb2FkU3dpdGNoYWJsZU5ldHdvcmsiLCJoYW5kbGVSZWFkUmVxdWVzdHMiLCJlcnJvck1lc3NhZ2UiLCJuZXdDaGFpbklkIiwicGhhc2VkQ2hhaW5JZCIsImNoYWluQ2hhbmdlZCIsImVtYWlsIiwiZW5hYmxlIiwiZmV0Y2hBY2NvdW50cyIsImhhbmRsZVNpZ24iLCJoYW5kbGVEaXNjb25uZWN0IiwiaGFuZGxlU2VuZFRyYW5zYWN0aW9uIiwiaGFuZGxlU2VuZEJhdGNoVHJhbnNhY3Rpb24iLCJoYW5kbGVTZW5kVXNlck9wZXJhdGlvbiIsIm9sZEFjY291bnQiLCJvbGRDaGFpbklkIiwibmV3QWNjb3VudCIsImFjY291bnRzQ2hhbmdlZCIsImhhbmRsZUJ1bmRsZXIiLCJibG9jdG9BcGkiLCJzZXNzaW9uSWQiLCJoZWFkZXJzIiwiZGlzY29ubmVjdCIsInJlc3BvbnNlTGlzdGVuZXIiLCJvYmplY3RLZXkiLCJvcmlnaW4iLCJlcnJvckNvZGUiLCJzZXRJZnJhbWUiLCJhZGRyZXNzIiwic2V0VGltZW91dCIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwiZW1haWxQYXJhbSIsImxvZ2luRnJhbWUiLCJjb25uZWN0IiwiYWRkciIsImV4cCIsImRvbWFpbiIsInNpZ25hdHVyZUlkIiwic2lnbkZyYW1lIiwiYXV0aG9yaXphdGlvbklkIiwiYXV0aHpGcmFtZSIsImV4dHJhY3RQYXJhbXMiLCJwYXJhbSIsImZvcm1hdFBhcmFtcyIsImNvcHlQYXlsb2FkIiwidXNlck9QRnJhbWUiLCJuZXR3b3JrTGlzdCIsImxpc3RUb0FkZCIsInJwY1VybHMiLCJhbGwiLCJXZWFrU2V0IiwibmV0d29ya190eXBlIiwiYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnQiLCJkaXNwbGF5X25hbWUiLCJ3YWxsZXRfd2ViX3VybCIsImJhc2UiLCJBTFBIQUJFVCIsIkJBU0VfTUFQIiwiY2hhckF0IiwieGMiLCJCQVNFIiwiTEVBREVSIiwiRkFDVE9SIiwiaUZBQ1RPUiIsImVuY29kZSIsInNvdXJjZSIsInplcm9lcyIsInBiZWdpbiIsInBlbmQiLCJiNTgiLCJjYXJyeSIsIml0MSIsIml0MiIsInJlcGVhdCIsImRlY29kZVVuc2FmZSIsInBzeiIsImIyNTYiLCJpdDMiLCJpdDQiLCJ2Y2giLCJkZWNvZGUiLCJiYXNleCIsImJzNTgiLCJiczU4JDEiLCJTb2xhbmEiLCJyZXF1aXJlIiwiU29sYW5hUHJvdmlkZXIiLCJuZXQiLCJ2YWx1ZXMiLCJzb2xhbmEiLCJTT0xBTkEiLCJhY2NvdW50SW5mbyIsImJ1ZmZlckRhdGEiLCJvd25lciIsIlB1YmxpY0tleSIsImhhbmRsZUNvbnZlcnRUcmFuc2FjdGlvbiIsImhhbmRsZVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJjb25zb2xlIiwicHVibGljS2V5IiwidG9CYXNlNTgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb252ZXJ0VG9Qcm9ncmFtV2FsbGV0VHJhbnNhY3Rpb24iLCJzZXJpYWxpemVNZXNzYWdlIiwidG9UcmFuc2FjdGlvbiIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJjb25uZWN0aW9uIiwiZXh0cmEiLCJjb21taXRtZW50IiwiX3JwY0VuZHBvaW50Iiwic2lnbmF0dXJlcyIsImNvbGxlY3RTaWduYXR1cmVzIiwicmF3IiwiTWVzc2FnZSIsIlRyYW5zYWN0aW9uIiwicmVjZW50QmxvY2toYXNoIiwiaGVhZGVyIiwibnVtUmVxdWlyZWRTaWduYXR1cmVzIiwiZmVlUGF5ZXIiLCJhY2NvdW50S2V5cyIsInNpZ25hdHVyZSIsInNpZ1B1YmtleVBhaXIiLCJpbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbiIsInB1YmtleSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImlzQWNjb3VudFdyaXRhYmxlIiwiVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiIsInByb2dyYW1JZCIsInByb2dyYW1JZEluZGV4IiwiYWNjIiwiY3VyIiwidHhIYXNoIiwiY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdCIsImZvcm1hdHRlZFBheWxvYWQiLCJub25jZSIsImFwcGxpY2F0aW9uIiwiQXB0b3NQcm92aWRlciIsImF1dGhLZXkiLCJuZXR3b3JrTmFtZSIsImFwaSIsImRlZmF1bHRTZXJ2ZXIiLCJwdWJsaWNBY2NvdW50IiwiQVBUT1MiLCJtaW5LZXlzUmVxdWlyZWQiLCJuZXR3b3JrIiwiaXNDb25uZWN0ZWQiLCJzaWduVHJhbnNhY3Rpb24iLCJibG9jdG9BcHRvcyIsImhhc0Nvbm5lY3RlZCIsInNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbiIsInR4T3B0aW9ucyIsImhhc2giLCJzaWduTWVzc2FnZSIsInB1YmxpY19rZXlzIiwicHVibGljS2V5cyIsImZldGNoQWRkcmVzcyIsImFwdG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocto/sdk/dist/blocto-sdk.module.js\n");

/***/ })

};
;
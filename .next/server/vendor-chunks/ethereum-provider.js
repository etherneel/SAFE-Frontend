"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-provider";
exports.ids = ["vendor-chunks/ethereum-provider"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereum-provider/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereum-provider/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst events_1 = __importDefault(__webpack_require__(/*! events */ \"events\"));\nconst payload_1 = __webpack_require__(/*! ./payload */ \"(ssr)/./node_modules/ethereum-provider/dist/payload.js\");\nclass Provider extends events_1.default {\n    constructor(connection){\n        super();\n        this.promises = {};\n        this.attemptedSubscriptions = new Set();\n        this.subscriptions = [];\n        this.checkConnectionRunning = false;\n        this.nextId = 1;\n        this.connected = false;\n        this.accounts = [];\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n        this.enable = this.enable.bind(this);\n        this.doSend = this.doSend.bind(this);\n        this.send = this.send.bind(this);\n        this.sendBatch = this.sendBatch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.unsubscribe = this.unsubscribe.bind(this);\n        this.resumeSubscriptions = this.resumeSubscriptions.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        this.sendAsyncBatch = this.sendAsyncBatch.bind(this);\n        this.isConnected = this.isConnected.bind(this);\n        this.close = this.close.bind(this);\n        this.request = this.request.bind(this);\n        this.connection = connection;\n        this.on(\"connect\", this.resumeSubscriptions);\n        this.connection.on(\"connect\", ()=>this.checkConnection(1000));\n        this.connection.on(\"close\", ()=>{\n            this.connected = false;\n            this.attemptedSubscriptions.clear();\n            this.emit(\"close\");\n            this.emit(\"disconnect\");\n        });\n        this.connection.on(\"payload\", (payload)=>{\n            const { id, method, error, result } = payload;\n            if (typeof id !== \"undefined\") {\n                if (this.promises[id]) {\n                    const requestMethod = this.promises[id].method;\n                    if (requestMethod && [\n                        \"eth_accounts\",\n                        \"eth_requestAccounts\"\n                    ].includes(requestMethod)) {\n                        const accounts = result || [];\n                        this.accounts = accounts;\n                        this.selectedAddress = accounts[0];\n                        this.coinbase = accounts[0];\n                    }\n                    payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);\n                    delete this.promises[id];\n                }\n            } else if (method && method.indexOf(\"_subscription\") > -1) {\n                // Events: connect, disconnect, chainChanged, chainsChanged, accountsChanged, assetsChanged, message\n                this.emit(payload.params.subscription, payload.params.result);\n                this.emit(method, payload.params); // Older EIP-1193\n                this.emit(\"message\", {\n                    type: payload.method,\n                    data: {\n                        subscription: payload.params.subscription,\n                        result: payload.params.result\n                    }\n                });\n                this.emit(\"data\", payload); // Backwards Compatibility\n            }\n        });\n        this.on(\"newListener\", (event)=>{\n            if (Object.keys(this.eventHandlers).includes(event)) {\n                if (!this.attemptedSubscription(event) && this.connected) {\n                    this.startSubscription(event);\n                    if (event === \"networkChanged\") {\n                        console.warn(\"The networkChanged event is being deprecated, use chainChanged instead\");\n                    }\n                }\n            }\n        });\n        this.eventHandlers = {\n            networkChanged: (netId)=>{\n                this.networkVersion = typeof netId === \"string\" ? parseInt(netId) : netId;\n                this.emit(\"networkChanged\", this.networkVersion);\n            },\n            chainChanged: (chainId)=>{\n                this.providerChainId = chainId;\n                if (!this.manualChainId) {\n                    this.emit(\"chainChanged\", chainId);\n                }\n            },\n            chainsChanged: (chains)=>{\n                this.emit(\"chainsChanged\", chains);\n            },\n            accountsChanged: (accounts)=>{\n                this.selectedAddress = accounts[0];\n                this.emit(\"accountsChanged\", accounts);\n            },\n            assetsChanged: (assets)=>{\n                this.emit(\"assetsChanged\", assets);\n            }\n        };\n    }\n    get chainId() {\n        return this.manualChainId || this.providerChainId;\n    }\n    async checkConnection(retryTimeout = 4000) {\n        if (this.checkConnectionRunning || this.connected) return;\n        clearTimeout(this.checkConnectionTimer);\n        this.checkConnectionTimer = undefined;\n        this.checkConnectionRunning = true;\n        try {\n            this.networkVersion = await this.doSend(\"net_version\", [], undefined, false);\n            this.providerChainId = await this.doSend(\"eth_chainId\", [], undefined, false);\n            this.connected = true;\n        } catch (e) {\n            this.checkConnectionTimer = setTimeout(()=>this.checkConnection(), retryTimeout);\n            this.connected = false;\n        } finally{\n            this.checkConnectionRunning = false;\n            if (this.connected) {\n                this.emit(\"connect\", {\n                    chainId: this.providerChainId\n                });\n            }\n        }\n    }\n    attemptedSubscription(event) {\n        return this.attemptedSubscriptions.has(event);\n    }\n    setSubscriptionAttempted(event) {\n        this.attemptedSubscriptions.add(event);\n    }\n    async startSubscription(event) {\n        console.debug(`starting subscription for ${event} events`);\n        this.setSubscriptionAttempted(event);\n        try {\n            const eventId = await this.subscribe(\"eth_subscribe\", event);\n            this.on(eventId, this.eventHandlers[event]);\n        } catch (e) {\n            console.warn(`Unable to subscribe to ${event}`, e);\n        }\n    }\n    resumeSubscriptions() {\n        Object.keys(this.eventHandlers).forEach((event)=>{\n            if (this.listenerCount(event) && !this.attemptedSubscription(event)) this.startSubscription(event);\n        });\n    }\n    async enable() {\n        const accounts = await this.doSend(\"eth_accounts\");\n        if (accounts.length > 0) {\n            this.accounts = accounts;\n            this.selectedAddress = accounts[0];\n            this.coinbase = accounts[0];\n            this.emit(\"enable\");\n            return accounts;\n        } else {\n            const err = new Error(\"User Denied Full Provider\");\n            err.code = \"4001\";\n            throw err;\n        }\n    }\n    doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {\n        const sendFn = (resolve, reject)=>{\n            const method = typeof rawPayload === \"object\" ? rawPayload.method : rawPayload;\n            const params = typeof rawPayload === \"object\" ? rawPayload.params : rawParams;\n            const chainTarget = typeof rawPayload === \"object\" && rawPayload.chainId || targetChain;\n            if (!method) {\n                return reject(new Error(\"Method is not a valid string.\"));\n            }\n            try {\n                const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);\n                this.promises[payload.id] = {\n                    resolve: (result)=>resolve(result),\n                    reject,\n                    method: payload.method\n                };\n                this.connection.send(payload);\n            } catch (e) {\n                reject(e);\n            }\n        };\n        if (this.connected || !waitForConnection) {\n            return new Promise(sendFn);\n        }\n        return new Promise((resolve, reject)=>{\n            const resolveSend = ()=>{\n                clearTimeout(disconnectTimer);\n                return resolve(new Promise(sendFn));\n            };\n            const disconnectTimer = setTimeout(()=>{\n                this.off(\"connect\", resolveSend);\n                reject(new Error(\"Not connected\"));\n            }, 5000);\n            this.once(\"connect\", resolveSend);\n        });\n    }\n    async send(methodOrPayload, callbackOrArgs) {\n        if (typeof methodOrPayload === \"string\" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n            const params = callbackOrArgs;\n            return this.doSend(methodOrPayload, params);\n        }\n        if (methodOrPayload && typeof methodOrPayload === \"object\" && typeof callbackOrArgs === \"function\") {\n            // a callback was passed to send(), forward everything to sendAsync()\n            const cb = callbackOrArgs;\n            return this.sendAsync(methodOrPayload, cb);\n        }\n        return this.request(methodOrPayload);\n    }\n    sendBatch(requests) {\n        return Promise.all(requests.map((payload)=>{\n            return this.doSend(payload.method, payload.params);\n        }));\n    }\n    async subscribe(type, method, params = []) {\n        const id = await this.doSend(type, [\n            method,\n            ...params\n        ]);\n        this.subscriptions.push(id);\n        return id;\n    }\n    async unsubscribe(type, id) {\n        const success = await this.doSend(type, [\n            id\n        ]);\n        if (success) {\n            this.subscriptions = this.subscriptions.filter((_id)=>_id !== id); // Remove subscription\n            this.removeAllListeners(id); // Remove listeners\n            return success;\n        }\n    }\n    async sendAsync(rawPayload, cb) {\n        if (!cb || typeof cb !== \"function\") return new Error(\"Invalid or undefined callback provided to sendAsync\");\n        if (!rawPayload) return cb(new Error(\"Invalid Payload\"));\n        // sendAsync can be called with an array for batch requests used by web3.js 0.x\n        // this is not part of EIP-1193's backwards compatibility but we still want to support it\n        if (Array.isArray(rawPayload)) {\n            const payloads = rawPayload.map((p)=>({\n                    ...p,\n                    jsonrpc: \"2.0\"\n                }));\n            const callback = cb;\n            return this.sendAsyncBatch(payloads, callback);\n        } else {\n            const payload = {\n                ...rawPayload,\n                jsonrpc: \"2.0\"\n            };\n            const callback = cb;\n            try {\n                const result = await this.doSend(payload.method, payload.params);\n                callback(null, {\n                    id: payload.id,\n                    jsonrpc: payload.jsonrpc,\n                    result\n                });\n            } catch (e) {\n                callback(e);\n            }\n        }\n    }\n    async sendAsyncBatch(payloads, cb) {\n        try {\n            const results = await this.sendBatch(payloads);\n            const result = results.map((entry, index)=>{\n                return {\n                    id: payloads[index].id,\n                    jsonrpc: payloads[index].jsonrpc,\n                    result: entry\n                };\n            });\n            cb(null, result);\n        } catch (e) {\n            cb(e);\n        }\n    }\n    isConnected() {\n        return this.connected;\n    }\n    close() {\n        if (this.connection && this.connection.close) this.connection.close();\n        this.off(\"connect\", this.resumeSubscriptions);\n        this.connected = false;\n        const error = new Error(\"Provider closed, subscription lost, please subscribe again.\");\n        this.subscriptions.forEach((id)=>this.emit(id, error)); // Send Error objects to any open subscriptions\n        this.subscriptions = []; // Clear subscriptions\n        this.manualChainId = undefined;\n        this.providerChainId = undefined;\n        this.networkVersion = undefined;\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n    }\n    async request(payload) {\n        return this.doSend(payload.method, payload.params, payload.chainId);\n    }\n    setChain(chainId) {\n        if (typeof chainId === \"number\") chainId = \"0x\" + chainId.toString(16);\n        const chainChanged = chainId !== this.chainId;\n        this.manualChainId = chainId;\n        if (chainChanged) {\n            this.emit(\"chainChanged\", this.chainId);\n        }\n    }\n}\nexports[\"default\"] = Provider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxXQUFXUCxnQkFBZ0JRLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pELE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLHlFQUFXO0FBQ3JDLE1BQU1FLGlCQUFpQkgsU0FBU0ksT0FBTztJQUNuQ0MsWUFBWUMsVUFBVSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO1FBQ2pCLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsSUFBSUM7UUFDbEMsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLHNCQUFzQixHQUFHO1FBQzlCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUNDLGVBQWUsR0FBR0M7UUFDdkIsSUFBSSxDQUFDQyxRQUFRLEdBQUdEO1FBQ2hCLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDRSxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUNGLElBQUksQ0FBQyxJQUFJO1FBQy9CLElBQUksQ0FBQ0csU0FBUyxHQUFHLElBQUksQ0FBQ0Es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Q0FBQztRQUN0QyxNQUFNMUQsZUFBZ0JDLFlBQVksSUFBSSxDQUFDQSxPQUFPO1FBQzlDLElBQUksQ0FBQ0UsYUFBYSxHQUFHRjtRQUNyQixJQUFJRCxjQUFjO1lBQ2QsSUFBSSxDQUFDMUIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMyQixPQUFPO1FBQzFDO0lBQ0o7QUFDSjtBQUNBL0Qsa0JBQWUsR0FBR0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1wcm92aWRlci9kaXN0L2luZGV4LmpzPzZjYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldmVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXZlbnRzXCIpKTtcbmNvbnN0IHBheWxvYWRfMSA9IHJlcXVpcmUoXCIuL3BheWxvYWRcIik7XG5jbGFzcyBQcm92aWRlciBleHRlbmRzIGV2ZW50c18xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wcm9taXNlcyA9IHt9O1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFN1YnNjcmlwdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvaW5iYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IHRoaXMuZW5hYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9TZW5kID0gdGhpcy5kb1NlbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZEJhdGNoID0gdGhpcy5zZW5kQmF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy51bnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc3VtZVN1YnNjcmlwdGlvbnMgPSB0aGlzLnJlc3VtZVN1YnNjcmlwdGlvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kQXN5bmMgPSB0aGlzLnNlbmRBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRBc3luY0JhdGNoID0gdGhpcy5zZW5kQXN5bmNCYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdGhpcy5pc0Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5vbignY29ubmVjdCcsIHRoaXMucmVzdW1lU3Vic2NyaXB0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbignY29ubmVjdCcsICgpID0+IHRoaXMuY2hlY2tDb25uZWN0aW9uKDEwMDApKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRlZFN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdwYXlsb2FkJywgcGF5bG9hZCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBtZXRob2QsIGVycm9yLCByZXN1bHQgfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb21pc2VzW2lkXSkgeyAvLyBGdWxmaWxsIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IHRoaXMucHJvbWlzZXNbaWRdLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXRob2QgJiYgWydldGhfYWNjb3VudHMnLCAnZXRoX3JlcXVlc3RBY2NvdW50cyddLmluY2x1ZGVzKHJlcXVlc3RNZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHJlc3VsdCB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvaW5iYXNlID0gYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5lcnJvciA/IHRoaXMucHJvbWlzZXNbaWRdLnJlamVjdChlcnJvcikgOiB0aGlzLnByb21pc2VzW2lkXS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgJiYgbWV0aG9kLmluZGV4T2YoJ19zdWJzY3JpcHRpb24nKSA+IC0xKSB7IC8vIEVtaXQgc3Vic2NyaXB0aW9uIHJlc3VsdFxuICAgICAgICAgICAgICAgIC8vIEV2ZW50czogY29ubmVjdCwgZGlzY29ubmVjdCwgY2hhaW5DaGFuZ2VkLCBjaGFpbnNDaGFuZ2VkLCBhY2NvdW50c0NoYW5nZWQsIGFzc2V0c0NoYW5nZWQsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQocGF5bG9hZC5wYXJhbXMuc3Vic2NyaXB0aW9uLCBwYXlsb2FkLnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChtZXRob2QsIHBheWxvYWQucGFyYW1zKTsgLy8gT2xkZXIgRUlQLTExOTNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHBheWxvYWQubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb246IHBheWxvYWQucGFyYW1zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcGF5bG9hZC5wYXJhbXMucmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYXlsb2FkKTsgLy8gQmFja3dhcmRzIENvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ25ld0xpc3RlbmVyJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZXZlbnRIYW5kbGVycykuaW5jbHVkZXMoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dGVtcHRlZFN1YnNjcmlwdGlvbihldmVudCkgJiYgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFN1YnNjcmlwdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ25ldHdvcmtDaGFuZ2VkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgbmV0d29ya0NoYW5nZWQgZXZlbnQgaXMgYmVpbmcgZGVwcmVjYXRlZCwgdXNlIGNoYWluQ2hhbmdlZCBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBuZXR3b3JrQ2hhbmdlZDogbmV0SWQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSAodHlwZW9mIG5ldElkID09PSAnc3RyaW5nJykgPyBwYXJzZUludChuZXRJZCkgOiBuZXRJZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ25ldHdvcmtDaGFuZ2VkJywgdGhpcy5uZXR3b3JrVmVyc2lvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhaW5DaGFuZ2VkOiBjaGFpbklkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyQ2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hbnVhbENoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFpbkNoYW5nZWQnLCBjaGFpbklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhaW5zQ2hhbmdlZDogY2hhaW5zID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYWluc0NoYW5nZWQnLCBjaGFpbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZDogKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3NldHNDaGFuZ2VkOiBhc3NldHMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYXNzZXRzQ2hhbmdlZCcsIGFzc2V0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBjaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxDaGFpbklkIHx8IHRoaXMucHJvdmlkZXJDaGFpbklkO1xuICAgIH1cbiAgICBhc3luYyBjaGVja0Nvbm5lY3Rpb24ocmV0cnlUaW1lb3V0ID0gNDAwMCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0Nvbm5lY3Rpb25SdW5uaW5nIHx8IHRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jaGVja0Nvbm5lY3Rpb25UaW1lcik7XG4gICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYXdhaXQgdGhpcy5kb1NlbmQoJ25ldF92ZXJzaW9uJywgW10sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlckNoYWluSWQgPSBhd2FpdCB0aGlzLmRvU2VuZCgnZXRoX2NoYWluSWQnLCBbXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY2hlY2tDb25uZWN0aW9uKCksIHJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCB7IGNoYWluSWQ6IHRoaXMucHJvdmlkZXJDaGFpbklkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGVtcHRlZFN1YnNjcmlwdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zLmhhcyhldmVudCk7XG4gICAgfVxuICAgIHNldFN1YnNjcmlwdGlvbkF0dGVtcHRlZChldmVudCkge1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFN1YnNjcmlwdGlvbnMuYWRkKGV2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnRTdWJzY3JpcHRpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1Zyhgc3RhcnRpbmcgc3Vic2NyaXB0aW9uIGZvciAke2V2ZW50fSBldmVudHNgKTtcbiAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb25BdHRlbXB0ZWQoZXZlbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRJZCA9IGF3YWl0ICh0aGlzLnN1YnNjcmliZSgnZXRoX3N1YnNjcmliZScsIGV2ZW50KSk7XG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50SWQsIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuYWJsZSB0byBzdWJzY3JpYmUgdG8gJHtldmVudH1gLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWVTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmV2ZW50SGFuZGxlcnMpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudCkgJiYgIXRoaXMuYXR0ZW1wdGVkU3Vic2NyaXB0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3Vic2NyaXB0aW9uKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGVuYWJsZSgpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmRvU2VuZCgnZXRoX2FjY291bnRzJyk7XG4gICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmFjY291bnRzID0gYWNjb3VudHM7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jb2luYmFzZSA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmFibGUnKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignVXNlciBEZW5pZWQgRnVsbCBQcm92aWRlcicpO1xuICAgICAgICAgICAgZXJyLmNvZGUgPSAnNDAwMSc7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9TZW5kKHJhd1BheWxvYWQsIHJhd1BhcmFtcyA9IFtdLCB0YXJnZXRDaGFpbiA9IHRoaXMubWFudWFsQ2hhaW5JZCwgd2FpdEZvckNvbm5lY3Rpb24gPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHNlbmRGbiA9IChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9ICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ29iamVjdCcpID8gcmF3UGF5bG9hZC5tZXRob2QgOiByYXdQYXlsb2FkO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gKHR5cGVvZiByYXdQYXlsb2FkID09PSAnb2JqZWN0JykgPyByYXdQYXlsb2FkLnBhcmFtcyA6IHJhd1BhcmFtcztcbiAgICAgICAgICAgIGNvbnN0IGNoYWluVGFyZ2V0ID0gKCh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIHJhd1BheWxvYWQuY2hhaW5JZCkgfHwgdGFyZ2V0Q2hhaW47XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNZXRob2QgaXMgbm90IGEgdmFsaWQgc3RyaW5nLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgwLCBwYXlsb2FkXzEuY3JlYXRlKShtZXRob2QsIHBhcmFtcywgdGhpcy5uZXh0SWQrKywgY2hhaW5UYXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZXNbcGF5bG9hZC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IChyZXN1bHQpID0+IHJlc29sdmUocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHBheWxvYWQubWV0aG9kXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQgfHwgIXdhaXRGb3JDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2Uoc2VuZEZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVNlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRpc2Nvbm5lY3RUaW1lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobmV3IFByb21pc2Uoc2VuZEZuKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGlzY29ubmVjdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2Nvbm5lY3QnLCByZXNvbHZlU2VuZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpKTtcbiAgICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICAgICAgdGhpcy5vbmNlKCdjb25uZWN0JywgcmVzb2x2ZVNlbmQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2RPclBheWxvYWQsIGNhbGxiYWNrT3JBcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kT3JQYXlsb2FkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgKCFjYWxsYmFja09yQXJncyB8fCBBcnJheS5pc0FycmF5KGNhbGxiYWNrT3JBcmdzKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNhbGxiYWNrT3JBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9TZW5kKG1ldGhvZE9yUGF5bG9hZCwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kT3JQYXlsb2FkICYmXG4gICAgICAgICAgICB0eXBlb2YgbWV0aG9kT3JQYXlsb2FkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhbGxiYWNrT3JBcmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgdG8gc2VuZCgpLCBmb3J3YXJkIGV2ZXJ5dGhpbmcgdG8gc2VuZEFzeW5jKClcbiAgICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tPckFyZ3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMobWV0aG9kT3JQYXlsb2FkLCBjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXRob2RPclBheWxvYWQpO1xuICAgIH1cbiAgICBzZW5kQmF0Y2gocmVxdWVzdHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlcXVlc3RzLm1hcChwYXlsb2FkID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvU2VuZChwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZSh0eXBlLCBtZXRob2QsIHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYXdhaXQgdGhpcy5kb1NlbmQodHlwZSwgW21ldGhvZCwgLi4ucGFyYW1zXSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKGlkKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZSh0eXBlLCBpZCkge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5kb1NlbmQodHlwZSwgW2lkXSk7XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZmlsdGVyKF9pZCA9PiBfaWQgIT09IGlkKTsgLy8gUmVtb3ZlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoaWQpOyAvLyBSZW1vdmUgbGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kQXN5bmMocmF3UGF5bG9hZCwgY2IpIHtcbiAgICAgICAgaWYgKCFjYiB8fCB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIG9yIHVuZGVmaW5lZCBjYWxsYmFjayBwcm92aWRlZCB0byBzZW5kQXN5bmMnKTtcbiAgICAgICAgaWYgKCFyYXdQYXlsb2FkKVxuICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignSW52YWxpZCBQYXlsb2FkJykpO1xuICAgICAgICAvLyBzZW5kQXN5bmMgY2FuIGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IGZvciBiYXRjaCByZXF1ZXN0cyB1c2VkIGJ5IHdlYjMuanMgMC54XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHBhcnQgb2YgRUlQLTExOTMncyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBidXQgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0IGl0XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1BheWxvYWQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHJhd1BheWxvYWQubWFwKHAgPT4gKHsgLi4ucCwganNvbnJwYzogJzIuMCcgfSkpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luY0JhdGNoKHBheWxvYWRzLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyAuLi5yYXdQYXlsb2FkLCBqc29ucnBjOiAnMi4wJyB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1NlbmQocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGlkOiBwYXlsb2FkLmlkLCBqc29ucnBjOiBwYXlsb2FkLmpzb25ycGMsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEFzeW5jQmF0Y2gocGF5bG9hZHMsIGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZW5kQmF0Y2gocGF5bG9hZHMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cy5tYXAoKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiBwYXlsb2Fkc1tpbmRleF0uaWQsIGpzb25ycGM6IHBheWxvYWRzW2luZGV4XS5qc29ucnBjLCByZXN1bHQ6IGVudHJ5IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNiKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uICYmIHRoaXMuY29ubmVjdGlvbi5jbG9zZSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9mZignY29ubmVjdCcsIHRoaXMucmVzdW1lU3Vic2NyaXB0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQcm92aWRlciBjbG9zZWQsIHN1YnNjcmlwdGlvbiBsb3N0LCBwbGVhc2Ugc3Vic2NyaWJlIGFnYWluLicpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChpZCA9PiB0aGlzLmVtaXQoaWQsIGVycm9yKSk7IC8vIFNlbmQgRXJyb3Igb2JqZWN0cyB0byBhbnkgb3BlbiBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdOyAvLyBDbGVhciBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMubWFudWFsQ2hhaW5JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wcm92aWRlckNoYWluSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvaW5iYXNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9TZW5kKHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcywgcGF5bG9hZC5jaGFpbklkKTtcbiAgICB9XG4gICAgc2V0Q2hhaW4oY2hhaW5JZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgY2hhaW5JZCA9ICcweCcgKyBjaGFpbklkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY29uc3QgY2hhaW5DaGFuZ2VkID0gKGNoYWluSWQgIT09IHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIHRoaXMubWFudWFsQ2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhaW5DaGFuZ2VkJywgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV2ZW50c18xIiwicmVxdWlyZSIsInBheWxvYWRfMSIsIlByb3ZpZGVyIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsInByb21pc2VzIiwiYXR0ZW1wdGVkU3Vic2NyaXB0aW9ucyIsIlNldCIsInN1YnNjcmlwdGlvbnMiLCJjaGVja0Nvbm5lY3Rpb25SdW5uaW5nIiwibmV4dElkIiwiY29ubmVjdGVkIiwiYWNjb3VudHMiLCJzZWxlY3RlZEFkZHJlc3MiLCJ1bmRlZmluZWQiLCJjb2luYmFzZSIsImVuYWJsZSIsImJpbmQiLCJkb1NlbmQiLCJzZW5kIiwic2VuZEJhdGNoIiwic3Vic2NyaWJlIiwidW5zdWJzY3JpYmUiLCJyZXN1bWVTdWJzY3JpcHRpb25zIiwic2VuZEFzeW5jIiwic2VuZEFzeW5jQmF0Y2giLCJpc0Nvbm5lY3RlZCIsImNsb3NlIiwicmVxdWVzdCIsIm9uIiwiY2hlY2tDb25uZWN0aW9uIiwiY2xlYXIiLCJlbWl0IiwicGF5bG9hZCIsImlkIiwibWV0aG9kIiwiZXJyb3IiLCJyZXN1bHQiLCJyZXF1ZXN0TWV0aG9kIiwiaW5jbHVkZXMiLCJyZWplY3QiLCJyZXNvbHZlIiwiaW5kZXhPZiIsInBhcmFtcyIsInN1YnNjcmlwdGlvbiIsInR5cGUiLCJkYXRhIiwiZXZlbnQiLCJrZXlzIiwiZXZlbnRIYW5kbGVycyIsImF0dGVtcHRlZFN1YnNjcmlwdGlvbiIsInN0YXJ0U3Vic2NyaXB0aW9uIiwiY29uc29sZSIsIndhcm4iLCJuZXR3b3JrQ2hhbmdlZCIsIm5ldElkIiwibmV0d29ya1ZlcnNpb24iLCJwYXJzZUludCIsImNoYWluQ2hhbmdlZCIsImNoYWluSWQiLCJwcm92aWRlckNoYWluSWQiLCJtYW51YWxDaGFpbklkIiwiY2hhaW5zQ2hhbmdlZCIsImNoYWlucyIsImFjY291bnRzQ2hhbmdlZCIsImFzc2V0c0NoYW5nZWQiLCJhc3NldHMiLCJyZXRyeVRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjaGVja0Nvbm5lY3Rpb25UaW1lciIsImUiLCJzZXRUaW1lb3V0IiwiaGFzIiwic2V0U3Vic2NyaXB0aW9uQXR0ZW1wdGVkIiwiYWRkIiwiZGVidWciLCJldmVudElkIiwiZm9yRWFjaCIsImxpc3RlbmVyQ291bnQiLCJsZW5ndGgiLCJlcnIiLCJFcnJvciIsImNvZGUiLCJyYXdQYXlsb2FkIiwicmF3UGFyYW1zIiwidGFyZ2V0Q2hhaW4iLCJ3YWl0Rm9yQ29ubmVjdGlvbiIsInNlbmRGbiIsImNoYWluVGFyZ2V0IiwiY3JlYXRlIiwiUHJvbWlzZSIsInJlc29sdmVTZW5kIiwiZGlzY29ubmVjdFRpbWVyIiwib2ZmIiwib25jZSIsIm1ldGhvZE9yUGF5bG9hZCIsImNhbGxiYWNrT3JBcmdzIiwiQXJyYXkiLCJpc0FycmF5IiwiY2IiLCJyZXF1ZXN0cyIsImFsbCIsIm1hcCIsInB1c2giLCJzdWNjZXNzIiwiZmlsdGVyIiwiX2lkIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicGF5bG9hZHMiLCJwIiwianNvbnJwYyIsImNhbGxiYWNrIiwicmVzdWx0cyIsImVudHJ5IiwiaW5kZXgiLCJzZXRDaGFpbiIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-provider/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-provider/dist/payload.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereum-provider/dist/payload.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.create = void 0;\nfunction create(method, params = [], id, targetChain) {\n    const payload = {\n        id,\n        method,\n        params,\n        jsonrpc: \"2.0\"\n    };\n    if (targetChain) {\n        payload.chainId = targetChain;\n    }\n    if (payload.method === \"eth_sendTransaction\") {\n        const mismatchedChain = isChainMismatch(payload);\n        if (mismatchedChain) {\n            throw new Error(`Payload chainId (${mismatchedChain}) inconsistent with specified target chainId: ${targetChain}`);\n        }\n        return updatePayloadChain(payload);\n    }\n    return payload;\n}\nexports.create = create;\nfunction isChainMismatch(payload) {\n    if (payload.method !== \"eth_sendTransaction\") return false;\n    const tx = payload.params[0] || {};\n    const chainId = tx.chainId;\n    return \"chainId\" in tx && parseInt(chainId) !== parseInt(payload.chainId || chainId);\n}\nfunction updatePayloadChain(payload) {\n    const tx = payload.params[0] || {};\n    return {\n        ...payload,\n        params: [\n            {\n                ...tx,\n                chainId: tx.chainId || payload.chainId\n            },\n            ...payload.params.slice(1)\n        ]\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9wYXlsb2FkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixTQUFTRSxPQUFPQyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLFdBQVc7SUFDaEQsTUFBTUMsVUFBVTtRQUNaRjtRQUFJRjtRQUFRQztRQUFRSSxTQUFTO0lBQ2pDO0lBQ0EsSUFBSUYsYUFBYTtRQUNiQyxRQUFRRSxPQUFPLEdBQUdIO0lBQ3RCO0lBQ0EsSUFBSUMsUUFBUUosTUFBTSxLQUFLLHVCQUF1QjtRQUMxQyxNQUFNTyxrQkFBa0JDLGdCQUFnQko7UUFDeEMsSUFBSUcsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFRixnQkFBZ0IsOENBQThDLEVBQUVKLFlBQVksQ0FBQztRQUNySDtRQUNBLE9BQU9PLG1CQUFtQk47SUFDOUI7SUFDQSxPQUFPQTtBQUNYO0FBQ0FQLGNBQWMsR0FBR0U7QUFDakIsU0FBU1MsZ0JBQWdCSixPQUFPO0lBQzVCLElBQUlBLFFBQVFKLE1BQU0sS0FBSyx1QkFDbkIsT0FBTztJQUNYLE1BQU1XLEtBQUtQLFFBQVFILE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQztJQUNqQyxNQUFNSyxVQUFVSyxHQUFHTCxPQUFPO0lBQzFCLE9BQU8sYUFBY0ssTUFBT0MsU0FBU04sYUFBYU0sU0FBU1IsUUFBUUUsT0FBTyxJQUFJQTtBQUNsRjtBQUNBLFNBQVNJLG1CQUFtQk4sT0FBTztJQUMvQixNQUFNTyxLQUFLUCxRQUFRSCxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDakMsT0FBTztRQUFFLEdBQUdHLE9BQU87UUFBRUgsUUFBUTtZQUFDO2dCQUFFLEdBQUdVLEVBQUU7Z0JBQUVMLFNBQVNLLEdBQUdMLE9BQU8sSUFBSUYsUUFBUUUsT0FBTztZQUFDO2VBQU1GLFFBQVFILE1BQU0sQ0FBQ1ksS0FBSyxDQUFDO1NBQUc7SUFBQztBQUNqSCIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLXByb3ZpZGVyL2Rpc3QvcGF5bG9hZC5qcz8wY2NmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBjcmVhdGUobWV0aG9kLCBwYXJhbXMgPSBbXSwgaWQsIHRhcmdldENoYWluKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQsIG1ldGhvZCwgcGFyYW1zLCBqc29ucnBjOiAnMi4wJ1xuICAgIH07XG4gICAgaWYgKHRhcmdldENoYWluKSB7XG4gICAgICAgIHBheWxvYWQuY2hhaW5JZCA9IHRhcmdldENoYWluO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICBjb25zdCBtaXNtYXRjaGVkQ2hhaW4gPSBpc0NoYWluTWlzbWF0Y2gocGF5bG9hZCk7XG4gICAgICAgIGlmIChtaXNtYXRjaGVkQ2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGF5bG9hZCBjaGFpbklkICgke21pc21hdGNoZWRDaGFpbn0pIGluY29uc2lzdGVudCB3aXRoIHNwZWNpZmllZCB0YXJnZXQgY2hhaW5JZDogJHt0YXJnZXRDaGFpbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlUGF5bG9hZENoYWluKHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZnVuY3Rpb24gaXNDaGFpbk1pc21hdGNoKHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC5tZXRob2QgIT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHR4ID0gcGF5bG9hZC5wYXJhbXNbMF0gfHwge307XG4gICAgY29uc3QgY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgcmV0dXJuICgnY2hhaW5JZCcgaW4gdHgpICYmIHBhcnNlSW50KGNoYWluSWQpICE9PSBwYXJzZUludChwYXlsb2FkLmNoYWluSWQgfHwgY2hhaW5JZCk7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXlsb2FkQ2hhaW4ocGF5bG9hZCkge1xuICAgIGNvbnN0IHR4ID0gcGF5bG9hZC5wYXJhbXNbMF0gfHwge307XG4gICAgcmV0dXJuIHsgLi4ucGF5bG9hZCwgcGFyYW1zOiBbeyAuLi50eCwgY2hhaW5JZDogdHguY2hhaW5JZCB8fCBwYXlsb2FkLmNoYWluSWQgfSwgLi4ucGF5bG9hZC5wYXJhbXMuc2xpY2UoMSldIH07XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGUiLCJtZXRob2QiLCJwYXJhbXMiLCJpZCIsInRhcmdldENoYWluIiwicGF5bG9hZCIsImpzb25ycGMiLCJjaGFpbklkIiwibWlzbWF0Y2hlZENoYWluIiwiaXNDaGFpbk1pc21hdGNoIiwiRXJyb3IiLCJ1cGRhdGVQYXlsb2FkQ2hhaW4iLCJ0eCIsInBhcnNlSW50Iiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-provider/dist/payload.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micro-ftch";
exports.ids = ["vendor-chunks/micro-ftch"];
exports.modules = {

/***/ "(ssr)/./node_modules/micro-ftch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micro-ftch/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256){\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode){\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === \"text\" || type === \"json\") {\n        try {\n            let text = new TextDecoder(\"utf8\", {\n                fatal: true\n            }).decode(b);\n            if (type === \"text\") return text;\n            try {\n                return JSON.parse(text);\n            } catch (err) {\n                if (type === \"json\") throw err;\n                return text;\n            }\n        } catch (err) {\n            if (type === \"text\" || type === \"json\") throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = {\n        ...DEFAULT_OPT,\n        ..._options\n    };\n    const http = __webpack_require__(/*! http */ \"http\");\n    const https = __webpack_require__(/*! https */ \"https\");\n    const zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const { promisify } = __webpack_require__(/*! util */ \"util\");\n    const { resolve: urlResolve } = __webpack_require__(/*! url */ \"url\");\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || \"GET\",\n        headers: {\n            \"Accept-Encoding\": \"gzip, deflate, br\"\n        }\n    };\n    const compactFP = (s)=>s.replace(/:| /g, \"\").toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i)=>compactFP(i)).sort()\n        ].join();\n        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === \"json\") opts.headers[\"Content-Type\"] = \"application/json\";\n    if (options.data) {\n        if (!options.method) opts.method = \"POST\";\n        opts.body = options.type === \"json\" ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = {\n        ...opts.headers,\n        ...options.headers\n    };\n    if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n    const handleRes = async (res)=>{\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers[\"location\"]) {\n            if (options._redirectCount == 10) throw new Error(\"Request failed. Too much redirects.\");\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers[\"location\"]), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers[\"content-encoding\"];\n        if (encoding === \"br\") bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === \"gzip\" || encoding === \"deflate\") bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full) return {\n            headers: res.headers,\n            status,\n            body\n        };\n        return body;\n    };\n    return new Promise((resolve, reject)=>{\n        const handleError = async (err)=>{\n            if (err && err.code === \"DEPTH_ZERO_SELF_SIGNED_CERT\") {\n                try {\n                    await fetchNode(url, {\n                        ...options,\n                        sslAllowSelfSigned: true,\n                        sslPinnedCertificates: []\n                    });\n                } catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res)=>{\n            res.on(\"error\", handleError);\n            (async ()=>{\n                try {\n                    resolve(await handleRes(res));\n                } catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on(\"error\", handleError);\n        const pinned = options.sslPinnedCertificates?.map((i)=>compactFP(i));\n        const mfetchSecureConnect = (socket)=>{\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || \"\");\n            if (!fp256 && socket.isSessionReused()) return;\n            if (pinned.includes(fp256)) return;\n            req.emit(\"error\", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on(\"socket\", (socket)=>{\n                const hasListeners = socket.listeners(\"secureConnect\").map((i)=>(i.name || \"\").replace(\"bound \", \"\")).includes(\"mfetchSecureConnect\");\n                if (hasListeners) return;\n                socket.on(\"secureConnect\", mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive) req.setNoDelay(true);\n        if (opts.body) req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set([\n    \"Accept\",\n    \"Accept-Language\",\n    \"Content-Language\",\n    \"Content-Type\"\n].map((i)=>i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set([\n    \"Accept-Charset\",\n    \"Accept-Encoding\",\n    \"Access-Control-Request-Headers\",\n    \"Access-Control-Request-Method\",\n    \"Connection\",\n    \"Content-Length\",\n    \"Cookie\",\n    \"Cookie2\",\n    \"Date\",\n    \"DNT\",\n    \"Expect\",\n    \"Host\",\n    \"Keep-Alive\",\n    \"Origin\",\n    \"Referer\",\n    \"TE\",\n    \"Trailer\",\n    \"Transfer-Encoding\",\n    \"Upgrade\",\n    \"Via\"\n].map((i)=>i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = {\n        ...DEFAULT_OPT,\n        ..._options\n    };\n    const headers = new Headers();\n    if (options.type === \"json\") headers.set(\"Content-Type\", \"application/json\");\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set(\"Authorization\", `Basic ${auth}`);\n        parsed.username = \"\";\n        parsed.password = \"\";\n    }\n    url = \"\" + parsed;\n    for(let k in options.headers){\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n    }\n    let opts = {\n        headers,\n        redirect: options.redirect ? \"follow\" : \"manual\"\n    };\n    if (!options.referrer) opts.referrerPolicy = \"no-referrer\";\n    if (options.cors) opts.mode = \"cors\";\n    if (options.data) {\n        if (!options.method) opts.method = \"POST\";\n        opts.body = options.type === \"json\" ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full) return {\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        body\n    };\n    return body;\n}\nconst IS_NODE = !!(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports[\"default\"] = fetchUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLHdCQUF3QixHQUFHLEtBQUs7QUFDakUsTUFBTUksY0FBY04sT0FBT08sTUFBTSxDQUFDO0lBQzlCQyxVQUFVO0lBQ1ZDLGtCQUFrQjtJQUNsQkMsU0FBUyxDQUFDO0lBQ1ZDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsb0JBQW9CO0lBQ3BCQyxnQkFBZ0I7QUFDcEI7QUFDQSxNQUFNWCx5QkFBeUJZO0lBQzNCQyxZQUFZQyxHQUFHLEVBQUVDLGNBQWMsQ0FBRTtRQUM3QixLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDQyxjQUFjLEdBQUdBO0lBQzFCO0FBQ0o7QUFDQWxCLHdCQUF3QixHQUFHRztBQUMzQixNQUFNRCwrQkFBK0JhO0lBQ2pDQyxZQUFZRyxVQUFVLENBQUU7UUFDcEIsS0FBSyxDQUFDLENBQUMsNkJBQTZCLEVBQUVBLFdBQVcsQ0FBQztRQUNsRCxJQUFJLENBQUNBLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBbkIsOEJBQThCLEdBQUdFO0FBQ2pDLFNBQVNrQixXQUFXQyxDQUFDLEVBQUVDLElBQUk7SUFDdkIsSUFBSSxDQUFDQSxRQUFRQSxTQUFTLFVBQVVBLFNBQVMsUUFBUTtRQUM3QyxJQUFJO1lBQ0EsSUFBSUMsT0FBTyxJQUFJQyxZQUFZLFFBQVE7Z0JBQUVDLE9BQU87WUFBSyxHQUFHQyxNQUFNLENBQUNMO1lBQzNELElBQUlDLFNBQVMsUUFDVCxPQUFPQztZQUNYLElBQUk7Z0JBQ0EsT0FBT0ksS0FBS0MsS0FBSyxDQUFDTDtZQUN0QixFQUNBLE9BQU9NLEtBQUs7Z0JBQ1IsSUFBSVAsU0FBUyxRQUNULE1BQU1PO2dCQUNWLE9BQU9OO1lBQ1g7UUFDSixFQUNBLE9BQU9NLEtBQUs7WUFDUixJ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O0lBQzFCLElBQUlwRixRQUFRdkIsSUFBSSxFQUNaaUMsS0FBSzJFLElBQUksR0FBRztJQUNoQixJQUFJckYsUUFBUTRCLElBQUksRUFBRTtRQUNkLElBQUksQ0FBQzVCLFFBQVFXLE1BQU0sRUFDZkQsS0FBS0MsTUFBTSxHQUFHO1FBQ2xCRCxLQUFLbUIsSUFBSSxHQUFHN0IsUUFBUVosSUFBSSxLQUFLLFNBQVNLLEtBQUtxQyxTQUFTLENBQUM5QixRQUFRNEIsSUFBSSxJQUFJNUIsUUFBUTRCLElBQUk7SUFDckY7SUFDQSxNQUFNSyxNQUFNLE1BQU1xRCxNQUFNeEYsS0FBS1k7SUFDN0IsSUFBSVYsUUFBUTNCLGdCQUFnQixJQUFJNEQsSUFBSUMsTUFBTSxLQUFLbEMsUUFBUTNCLGdCQUFnQixFQUNuRSxNQUFNLElBQUlMLHVCQUF1QmlFLElBQUlDLE1BQU07SUFDL0MsTUFBTUwsT0FBTzNDLFdBQVcsSUFBSXFHLFdBQVcsTUFBTXRELElBQUl1RCxXQUFXLEtBQUt4RixRQUFRWixJQUFJO0lBQzdFLElBQUlZLFFBQVF6QixJQUFJLEVBQ1osT0FBTztRQUFFRCxTQUFTVixPQUFPNkgsV0FBVyxDQUFDeEQsSUFBSTNELE9BQU8sQ0FBQ29ILE9BQU87UUFBS3hELFFBQVFELElBQUlDLE1BQU07UUFBRUw7SUFBSztJQUMxRixPQUFPQTtBQUNYO0FBQ0EsTUFBTThELFVBQVUsQ0FBQyxDQUFFLFFBQU9DLFdBQVcsWUFDakNBLFFBQVFDLFFBQVEsSUFDaEJELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxJQUNyQkYsUUFBUUMsUUFBUSxDQUFDRSxFQUFFO0FBQ3ZCLFNBQVNDLFNBQVNsRyxHQUFHLEVBQUVFLE9BQU87SUFDMUIsTUFBTWlHLEtBQUtOLFVBQVU5RixZQUFZNEU7SUFDakMsT0FBT3dCLEdBQUduRyxLQUFLRTtBQUNuQjtBQUNBbEMsa0JBQWUsR0FBR2tJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcz8wYzgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkU3RhdHVzQ29kZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2VydEVycm9yID0gdm9pZCAwO1xuY29uc3QgREVGQVVMVF9PUFQgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWRpcmVjdDogdHJ1ZSxcbiAgICBleHBlY3RTdGF0dXNDb2RlOiAyMDAsXG4gICAgaGVhZGVyczoge30sXG4gICAgZnVsbDogZmFsc2UsXG4gICAga2VlcEFsaXZlOiB0cnVlLFxuICAgIGNvcnM6IGZhbHNlLFxuICAgIHJlZmVycmVyOiBmYWxzZSxcbiAgICBzc2xBbGxvd1NlbGZTaWduZWQ6IGZhbHNlLFxuICAgIF9yZWRpcmVjdENvdW50OiAwLFxufSk7XG5jbGFzcyBJbnZhbGlkQ2VydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZywgZmluZ2VycHJpbnQyNTYpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maW5nZXJwcmludDI1NiA9IGZpbmdlcnByaW50MjU2O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENlcnRFcnJvciA9IEludmFsaWRDZXJ0RXJyb3I7XG5jbGFzcyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIoYFJlcXVlc3QgRmFpbGVkLiBTdGF0dXMgQ29kZTogJHtzdGF0dXNDb2RlfWApO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFN0YXR1c0NvZGVFcnJvciA9IEludmFsaWRTdGF0dXNDb2RlRXJyb3I7XG5mdW5jdGlvbiBkZXRlY3RUeXBlKGIsIHR5cGUpIHtcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdqc29uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShiKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnanNvbicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdqc29uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG5sZXQgYWdlbnRzID0ge307XG5mdW5jdGlvbiBmZXRjaE5vZGUodXJsLCBfb3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zID0geyAuLi5ERUZBVUxUX09QVCwgLi4uX29wdGlvbnMgfTtcbiAgICBjb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbiAgICBjb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuICAgIGNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG4gICAgY29uc3QgeyByZXNvbHZlOiB1cmxSZXNvbHZlIH0gPSByZXF1aXJlKCd1cmwnKTtcbiAgICBjb25zdCBpc1NlY3VyZSA9ICEhL15odHRwcy8udGVzdCh1cmwpO1xuICAgIGxldCBvcHRzID0ge1xuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInIH0sXG4gICAgfTtcbiAgICBjb25zdCBjb21wYWN0RlAgPSAocykgPT4gcy5yZXBsYWNlKC86fCAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbnN0IGFnZW50T3B0ID0ge1xuICAgICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgICAga2VlcEFsaXZlTXNlY3M6IDMwICogMTAwMCxcbiAgICAgICAgICAgIG1heEZyZWVTb2NrZXRzOiAxMDI0LFxuICAgICAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnM6IDEwMjQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFnZW50S2V5ID0gW1xuICAgICAgICAgICAgaXNTZWN1cmUsXG4gICAgICAgICAgICBpc1NlY3VyZSAmJiBvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcz8ubWFwKChpKSA9PiBjb21wYWN0RlAoaSkpLnNvcnQoKSxcbiAgICAgICAgXS5qb2luKCk7XG4gICAgICAgIG9wdHMuYWdlbnQgPVxuICAgICAgICAgICAgYWdlbnRzW2FnZW50S2V5XSB8fCAoYWdlbnRzW2FnZW50S2V5XSA9IG5ldyAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLkFnZW50KGFnZW50T3B0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdqc29uJylcbiAgICAgICAgb3B0cy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXRob2QpXG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgb3B0cy5ib2R5ID0gb3B0aW9ucy50eXBlID09PSAnanNvbicgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpIDogb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBvcHRzLmhlYWRlcnMgPSB7IC4uLm9wdHMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgaWYgKG9wdGlvbnMuc3NsQWxsb3dTZWxmU2lnbmVkKVxuICAgICAgICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZVJlcyA9IGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0ICYmIDMwMCA8PSBzdGF0dXMgJiYgc3RhdHVzIDwgNDAwICYmIHJlcy5oZWFkZXJzWydsb2NhdGlvbiddKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5fcmVkaXJlY3RDb3VudCA9PSAxMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkLiBUb28gbXVjaCByZWRpcmVjdHMuJyk7XG4gICAgICAgICAgICBvcHRpb25zLl9yZWRpcmVjdENvdW50ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmV0Y2hOb2RlKHVybFJlc29sdmUodXJsLCByZXMuaGVhZGVyc1snbG9jYXRpb24nXSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUgJiYgc3RhdHVzICE9PSBvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZiA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlcylcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGNodW5rKTtcbiAgICAgICAgbGV0IGJ5dGVzID0gQnVmZmVyLmNvbmNhdChidWYpO1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2JyJylcbiAgICAgICAgICAgIGJ5dGVzID0gYXdhaXQgcHJvbWlzaWZ5KHpsaWIuYnJvdGxpRGVjb21wcmVzcykoYnl0ZXMpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdnemlwJyB8fCBlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKVxuICAgICAgICAgICAgYnl0ZXMgPSBhd2FpdCBwcm9taXNpZnkoemxpYi51bnppcCkoYnl0ZXMpO1xuICAgICAgICBjb25zdCBib2R5ID0gZGV0ZWN0VHlwZShieXRlcywgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHJlcy5oZWFkZXJzLCBzdGF0dXMsIGJvZHkgfTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdERVBUSF9aRVJPX1NFTEZfU0lHTkVEX0NFUlQnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2hOb2RlKHVybCwgeyAuLi5vcHRpb25zLCBzc2xBbGxvd1NlbGZTaWduZWQ6IHRydWUsIHNzbFBpbm5lZENlcnRpZmljYXRlczogW10gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUuZmluZ2VycHJpbnQyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBJbnZhbGlkQ2VydEVycm9yKGBTZWxmLXNpZ25lZCBTU0wgY2VydGlmaWNhdGU6ICR7ZS5maW5nZXJwcmludDI1Nn1gLCBlLmZpbmdlcnByaW50MjU2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXEgPSAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QodXJsLCBvcHRzLCAocmVzKSA9PiB7XG4gICAgICAgICAgICByZXMub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IGhhbmRsZVJlcyhyZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgIGNvbnN0IHBpbm5lZCA9IG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzPy5tYXAoKGkpID0+IGNvbXBhY3RGUChpKSk7XG4gICAgICAgIGNvbnN0IG1mZXRjaFNlY3VyZUNvbm5lY3QgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcDI1NiA9IGNvbXBhY3RGUChzb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk/LmZpbmdlcnByaW50MjU2IHx8ICcnKTtcbiAgICAgICAgICAgIGlmICghZnAyNTYgJiYgc29ja2V0LmlzU2Vzc2lvblJldXNlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwaW5uZWQuaW5jbHVkZXMoZnAyNTYpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJlcS5lbWl0KCdlcnJvcicsIG5ldyBJbnZhbGlkQ2VydEVycm9yKGBJbnZhbGlkIFNTTCBjZXJ0aWZpY2F0ZTogJHtmcDI1Nn0gRXhwZWN0ZWQ6ICR7cGlubmVkfWAsIGZwMjU2KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxLmFib3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcykge1xuICAgICAgICAgICAgcmVxLm9uKCdzb2NrZXQnLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTGlzdGVuZXJzID0gc29ja2V0XG4gICAgICAgICAgICAgICAgICAgIC5saXN0ZW5lcnMoJ3NlY3VyZUNvbm5lY3QnKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChpKSA9PiAoaS5uYW1lIHx8ICcnKS5yZXBsYWNlKCdib3VuZCAnLCAnJykpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcygnbWZldGNoU2VjdXJlQ29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oJ3NlY3VyZUNvbm5lY3QnLCBtZmV0Y2hTZWN1cmVDb25uZWN0LmJpbmQobnVsbCwgc29ja2V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUpXG4gICAgICAgICAgICByZXEuc2V0Tm9EZWxheSh0cnVlKTtcbiAgICAgICAgaWYgKG9wdHMuYm9keSlcbiAgICAgICAgICAgIHJlcS53cml0ZShvcHRzLmJvZHkpO1xuICAgICAgICByZXEuZW5kKCk7XG4gICAgfSk7XG59XG5jb25zdCBTQUZFX0hFQURFUlMgPSBuZXcgU2V0KFsnQWNjZXB0JywgJ0FjY2VwdC1MYW5ndWFnZScsICdDb250ZW50LUxhbmd1YWdlJywgJ0NvbnRlbnQtVHlwZSddLm1hcCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpKSk7XG5jb25zdCBGT1JCSURERU5fSEVBREVSUyA9IG5ldyBTZXQoWydBY2NlcHQtQ2hhcnNldCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJywgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kJyxcbiAgICAnQ29ubmVjdGlvbicsICdDb250ZW50LUxlbmd0aCcsICdDb29raWUnLCAnQ29va2llMicsICdEYXRlJywgJ0ROVCcsICdFeHBlY3QnLCAnSG9zdCcsICdLZWVwLUFsaXZlJywgJ09yaWdpbicsICdSZWZlcmVyJywgJ1RFJywgJ1RyYWlsZXInLFxuICAgICdUcmFuc2Zlci1FbmNvZGluZycsICdVcGdyYWRlJywgJ1ZpYSddLm1hcCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpKSk7XG5hc3luYyBmdW5jdGlvbiBmZXRjaEJyb3dzZXIodXJsLCBfb3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zID0geyAuLi5ERUZBVUxUX09QVCwgLi4uX29wdGlvbnMgfTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnanNvbicpXG4gICAgICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGxldCBwYXJzZWQgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHBhcnNlZC51c2VybmFtZSkge1xuICAgICAgICBjb25zdCBhdXRoID0gYnRvYShgJHtwYXJzZWQudXNlcm5hbWV9OiR7cGFyc2VkLnBhc3N3b3JkfWApO1xuICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2F1dGh9YCk7XG4gICAgICAgIHBhcnNlZC51c2VybmFtZSA9ICcnO1xuICAgICAgICBwYXJzZWQucGFzc3dvcmQgPSAnJztcbiAgICB9XG4gICAgdXJsID0gJycgKyBwYXJzZWQ7XG4gICAgZm9yIChsZXQgayBpbiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGsudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFNBRkVfSEVBREVSUy5oYXMobmFtZSkgfHwgKG9wdGlvbnMuY29ycyAmJiAhRk9SQklEREVOX0hFQURFUlMuaGFzKG5hbWUpKSlcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KGssIG9wdGlvbnMuaGVhZGVyc1trXSk7XG4gICAgfVxuICAgIGxldCBvcHRzID0geyBoZWFkZXJzLCByZWRpcmVjdDogb3B0aW9ucy5yZWRpcmVjdCA/ICdmb2xsb3cnIDogJ21hbnVhbCcgfTtcbiAgICBpZiAoIW9wdGlvbnMucmVmZXJyZXIpXG4gICAgICAgIG9wdHMucmVmZXJyZXJQb2xpY3kgPSAnbm8tcmVmZXJyZXInO1xuICAgIGlmIChvcHRpb25zLmNvcnMpXG4gICAgICAgIG9wdHMubW9kZSA9ICdjb3JzJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXRob2QpXG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgb3B0cy5ib2R5ID0gb3B0aW9ucy50eXBlID09PSAnanNvbicgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpIDogb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdHMpO1xuICAgIGlmIChvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUgJiYgcmVzLnN0YXR1cyAhPT0gb3B0aW9ucy5leHBlY3RTdGF0dXNDb2RlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXR1c0NvZGVFcnJvcihyZXMuc3RhdHVzKTtcbiAgICBjb25zdCBib2R5ID0gZGV0ZWN0VHlwZShuZXcgVWludDhBcnJheShhd2FpdCByZXMuYXJyYXlCdWZmZXIoKSksIG9wdGlvbnMudHlwZSk7XG4gICAgaWYgKG9wdGlvbnMuZnVsbClcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlcy5oZWFkZXJzLmVudHJpZXMoKSksIHN0YXR1czogcmVzLnN0YXR1cywgYm9keSB9O1xuICAgIHJldHVybiBib2R5O1xufVxuY29uc3QgSVNfTk9ERSA9ICEhKHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucyAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMudjgpO1xuZnVuY3Rpb24gZmV0Y2hVcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm4gPSBJU19OT0RFID8gZmV0Y2hOb2RlIDogZmV0Y2hCcm93c2VyO1xuICAgIHJldHVybiBmbih1cmwsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hVcmw7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkU3RhdHVzQ29kZUVycm9yIiwiSW52YWxpZENlcnRFcnJvciIsIkRFRkFVTFRfT1BUIiwiZnJlZXplIiwicmVkaXJlY3QiLCJleHBlY3RTdGF0dXNDb2RlIiwiaGVhZGVycyIsImZ1bGwiLCJrZWVwQWxpdmUiLCJjb3JzIiwicmVmZXJyZXIiLCJzc2xBbGxvd1NlbGZTaWduZWQiLCJfcmVkaXJlY3RDb3VudCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtc2ciLCJmaW5nZXJwcmludDI1NiIsInN0YXR1c0NvZGUiLCJkZXRlY3RUeXBlIiwiYiIsInR5cGUiLCJ0ZXh0IiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsIkpTT04iLCJwYXJzZSIsImVyciIsImFnZW50cyIsImZldGNoTm9kZSIsInVybCIsIl9vcHRpb25zIiwib3B0aW9ucyIsImh0dHAiLCJyZXF1aXJlIiwiaHR0cHMiLCJ6bGliIiwicHJvbWlzaWZ5IiwicmVzb2x2ZSIsInVybFJlc29sdmUiLCJpc1NlY3VyZSIsInRlc3QiLCJvcHRzIiwibWV0aG9kIiwiY29tcGFjdEZQIiwicyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImFnZW50T3B0Iiwia2VlcEFsaXZlTXNlY3MiLCJtYXhGcmVlU29ja2V0cyIsIm1heENhY2hlZFNlc3Npb25zIiwiYWdlbnRLZXkiLCJzc2xQaW5uZWRDZXJ0aWZpY2F0ZXMiLCJtYXAiLCJpIiwic29ydCIsImpvaW4iLCJhZ2VudCIsIkFnZW50IiwiZGF0YSIsImJvZHkiLCJzdHJpbmdpZnkiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJoYW5kbGVSZXMiLCJyZXMiLCJzdGF0dXMiLCJyZXN1bWUiLCJidWYiLCJjaHVuayIsInB1c2giLCJieXRlcyIsIkJ1ZmZlciIsImNvbmNhdCIsImVuY29kaW5nIiwiYnJvdGxpRGVjb21wcmVzcyIsInVuemlwIiwiUHJvbWlzZSIsInJlamVjdCIsImhhbmRsZUVycm9yIiwiY29kZSIsImUiLCJyZXEiLCJyZXF1ZXN0Iiwib24iLCJlcnJvciIsInBpbm5lZCIsIm1mZXRjaFNlY3VyZUNvbm5lY3QiLCJzb2NrZXQiLCJmcDI1NiIsImdldFBlZXJDZXJ0aWZpY2F0ZSIsImlzU2Vzc2lvblJldXNlZCIsImluY2x1ZGVzIiwiZW1pdCIsImFib3J0IiwiaGFzTGlzdGVuZXJzIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmQiLCJzZXROb0RlbGF5Iiwid3JpdGUiLCJlbmQiLCJTQUZFX0hFQURFUlMiLCJTZXQiLCJGT1JCSURERU5fSEVBREVSUyIsImZldGNoQnJvd3NlciIsIkhlYWRlcnMiLCJzZXQiLCJwYXJzZWQiLCJVUkwiLCJ1c2VybmFtZSIsImF1dGgiLCJidG9hIiwicGFzc3dvcmQiLCJrIiwiaGFzIiwicmVmZXJyZXJQb2xpY3kiLCJtb2RlIiwiZmV0Y2giLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJJU19OT0RFIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsInY4IiwiZmV0Y2hVcmwiLCJmbiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micro-ftch/index.js\n");

/***/ })

};
;
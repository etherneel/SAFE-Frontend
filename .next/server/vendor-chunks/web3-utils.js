"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-utils";
exports.ids = ["vendor-chunks/web3-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-utils/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/web3-utils/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file utils.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar ethjsUnit = __webpack_require__(/*! ethjs-unit */ \"(ssr)/./node_modules/ethjs-unit/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/lib/utils.js\");\nvar soliditySha3 = __webpack_require__(/*! ./soliditySha3.js */ \"(ssr)/./node_modules/web3-utils/lib/soliditySha3.js\");\nvar randombytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/randombytes/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/**\n * Fires an error in an event emitter and callback and returns the eventemitter\n *\n * @method _fireError\n * @param {Object} error a string, a error, or an object with {message, data}\n * @param {Object} emitter\n * @param {Function} reject\n * @param {Function} callback\n * @param {any} optionalData\n * @return {Object} the emitter\n */ var _fireError = function(error, emitter, reject, callback, optionalData) {\n    /*jshint maxcomplexity: 10 */ // add data if given\n    if (!!error && typeof error === \"object\" && !(error instanceof Error) && error.data) {\n        if (!!error.data && typeof error.data === \"object\" || Array.isArray(error.data)) {\n            error.data = JSON.stringify(error.data, null, 2);\n        }\n        error = error.message + \"\\n\" + error.data;\n    }\n    if (typeof error === \"string\") {\n        error = new Error(error);\n    }\n    if (typeof callback === \"function\") {\n        callback(error, optionalData);\n    }\n    if (typeof reject === \"function\") {\n        // suppress uncatched error if an error listener is present\n        // OR suppress uncatched error if an callback listener is present\n        if (emitter && typeof emitter.listeners === \"function\" && emitter.listeners(\"error\").length || typeof callback === \"function\") {\n            emitter.catch(function() {});\n        }\n        // reject later, to be able to return emitter\n        setTimeout(function() {\n            reject(error);\n        }, 1);\n    }\n    if (emitter && typeof emitter.emit === \"function\") {\n        // emit later, to be able to return emitter\n        setTimeout(function() {\n            emitter.emit(\"error\", error, optionalData);\n            emitter.removeAllListeners();\n        }, 1);\n    }\n    return emitter;\n};\n/**\n * Should be used to create full function/event name from json abi\n *\n * @method _jsonInterfaceMethodToString\n * @param {Object} json\n * @return {String} full function/event name\n */ var _jsonInterfaceMethodToString = function(json) {\n    if (!!json && typeof json === \"object\" && json.name && json.name.indexOf(\"(\") !== -1) {\n        return json.name;\n    }\n    return json.name + \"(\" + _flattenTypes(false, json.inputs).join(\",\") + \")\";\n};\n/**\n * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings\n *\n * @method _flattenTypes\n * @param {bool} includeTuple\n * @param {Object} puts\n * @return {Array} parameters as strings\n */ var _flattenTypes = function(includeTuple, puts) {\n    // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n    var types = [];\n    puts.forEach(function(param) {\n        if (typeof param.components === \"object\") {\n            if (param.type.substring(0, 5) !== \"tuple\") {\n                throw new Error(\"components found but type is not tuple; report on GitHub\");\n            }\n            var suffix = \"\";\n            var arrayBracket = param.type.indexOf(\"[\");\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = _flattenTypes(includeTuple, param.components);\n            // console.log(\"result should have things: \" + result)\n            if (Array.isArray(result) && includeTuple) {\n                // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n                types.push(\"tuple(\" + result.join(\",\") + \")\" + suffix);\n            } else if (!includeTuple) {\n                // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n                types.push(\"(\" + result.join(\",\") + \")\" + suffix);\n            } else {\n                // console.log(\"its a single type within a tuple: \" + result.types)\n                types.push(\"(\" + result + \")\");\n            }\n        } else {\n            // console.log(\"its a type and not directly in a tuple: \" + param.type)\n            types.push(param.type);\n        }\n    });\n    return types;\n};\n/**\n * Returns a random hex string by the given bytes size\n *\n * @param {Number} size\n * @returns {string}\n */ var randomHex = function(size) {\n    return \"0x\" + randombytes(size).toString(\"hex\");\n};\n/**\n * Should be called to get ascii from it's hex representation\n *\n * @method hexToAscii\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */ var hexToAscii = function(hex) {\n    if (!utils.isHexStrict(hex)) throw new Error(\"The parameter must be a valid HEX string.\");\n    var str = \"\";\n    var i = 0, l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") {\n        i = 2;\n    }\n    for(; i < l; i += 2){\n        var code = parseInt(hex.slice(i, i + 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @method asciiToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */ var asciiToHex = function(str) {\n    if (!str) return \"0x00\";\n    var hex = \"\";\n    for(var i = 0; i < str.length; i++){\n        var code = str.charCodeAt(i);\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\" + n : n;\n    }\n    return \"0x\" + hex;\n};\n/**\n * Returns value of unit in Wei\n *\n * @method getUnitValue\n * @param {String} unit the unit to convert to, default ether\n * @returns {BN} value of the unit (in Wei)\n * @throws error if the unit is not correct:w\n */ var getUnitValue = function(unit) {\n    unit = unit ? unit.toLowerCase() : \"ether\";\n    if (!ethjsUnit.unitMap[unit]) {\n        throw new Error('This unit \"' + unit + \"\\\" doesn't exist, please use the one of the following units\" + JSON.stringify(ethjsUnit.unitMap, null, 2));\n    }\n    return unit;\n};\n/**\n * Takes a number of wei and converts it to any other ether unit.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method fromWei\n * @param {Number|String} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert to, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */ var fromWei = function(number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === \"string\")) {\n        throw new Error(\"Please pass numbers as strings or BN objects to avoid precision errors.\");\n    }\n    return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);\n};\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method toWei\n * @param {Number|String|BN} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert from, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */ var toWei = function(number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === \"string\")) {\n        throw new Error(\"Please pass numbers as strings or BN objects to avoid precision errors.\");\n    }\n    return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);\n};\n/**\n * Converts to a checksum address\n *\n * @method toChecksumAddress\n * @param {String} address the given HEX address\n * @return {String}\n */ var toChecksumAddress = function(address) {\n    if (typeof address === \"undefined\") return \"\";\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) throw new Error('Given address \"' + address + '\" is not a valid Ethereum address.');\n    address = address.toLowerCase().replace(/^0x/i, \"\");\n    var addressHash = utils.sha3(address).replace(/^0x/i, \"\");\n    var checksumAddress = \"0x\";\n    for(var i = 0; i < address.length; i++){\n        // If ith character is 8 to f then make it uppercase\n        if (parseInt(addressHash[i], 16) > 7) {\n            checksumAddress += address[i].toUpperCase();\n        } else {\n            checksumAddress += address[i];\n        }\n    }\n    return checksumAddress;\n};\n/**\n * Returns -1 if a<b, 1 if a>b; 0 if a == b.\n * For more details on this type of function, see\n * developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * Block tag `safe` and `block number` combination param is not supported\n * @method compareBlockNumbers\n *\n * @param {String|Number|BN} a\n *\n * @param {String|Number|BN} b\n *\n * @returns {Number} -1, 0, or 1\n */ var compareBlockNumbers = function(a, b) {\n    // Increasing order: (genesis = earliest), safe, (finalized ~ latest), pending\n    // safe vs block-num cant be compared as block number provided can be on left or right side of safe tag, until safe tag block number is extracted and compared\n    if (a === b) {\n        return 0;\n    } else if ((\"genesis\" === a || \"earliest\" === a || 0 === a) && (\"genesis\" === b || \"earliest\" === b || 0 === b)) {\n        return 0;\n    } else if (\"genesis\" === a || \"earliest\" === a || a === 0) {\n        // b !== a, thus a < b\n        return -1;\n    } else if (\"genesis\" === b || \"earliest\" === b || b === 0) {\n        // b !== a, thus a > b\n        return 1;\n    } else if (a === \"latest\" || a === \"finalized\") {\n        if (b === \"pending\") {\n            return -1;\n        } else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return 1;\n        }\n    } else if (b === \"latest\" || b === \"finalized\") {\n        if (a === \"pending\") {\n            return 1;\n        } else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return -1;\n        }\n    } else if (a === \"pending\") {\n        // b (== OR <) \"latest\", thus a > b\n        return 1;\n    } else if (b === \"pending\") {\n        return -1;\n    } else if (a === \"safe\" || b === \"safe\") {\n        // either a or b is \"safe\" and the other one did not fall into any of the conditions above, so the other one is a number\n        return undefined;\n    } else {\n        let bnA = new BN(a);\n        let bnB = new BN(b);\n        if (bnA.lt(bnB)) {\n            return -1;\n        } else if (bnA.eq(bnB)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n};\nmodule.exports = {\n    _fireError: _fireError,\n    _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,\n    _flattenTypes: _flattenTypes,\n    // extractDisplayName: extractDisplayName,\n    // extractTypeName: extractTypeName,\n    randomHex: randomHex,\n    BN: utils.BN,\n    isBN: utils.isBN,\n    isBigNumber: utils.isBigNumber,\n    isHex: utils.isHex,\n    isHexStrict: utils.isHexStrict,\n    sha3: utils.sha3,\n    sha3Raw: utils.sha3Raw,\n    keccak256: utils.sha3,\n    soliditySha3: soliditySha3.soliditySha3,\n    soliditySha3Raw: soliditySha3.soliditySha3Raw,\n    encodePacked: soliditySha3.encodePacked,\n    isAddress: utils.isAddress,\n    checkAddressChecksum: utils.checkAddressChecksum,\n    toChecksumAddress: toChecksumAddress,\n    toHex: utils.toHex,\n    toBN: utils.toBN,\n    bytesToHex: utils.bytesToHex,\n    hexToBytes: utils.hexToBytes,\n    hexToNumberString: utils.hexToNumberString,\n    hexToNumber: utils.hexToNumber,\n    toDecimal: utils.hexToNumber,\n    numberToHex: utils.numberToHex,\n    fromDecimal: utils.numberToHex,\n    hexToUtf8: utils.hexToUtf8,\n    hexToString: utils.hexToUtf8,\n    toUtf8: utils.hexToUtf8,\n    stripHexPrefix: utils.stripHexPrefix,\n    utf8ToHex: utils.utf8ToHex,\n    stringToHex: utils.utf8ToHex,\n    fromUtf8: utils.utf8ToHex,\n    hexToAscii: hexToAscii,\n    toAscii: hexToAscii,\n    asciiToHex: asciiToHex,\n    fromAscii: asciiToHex,\n    unitMap: ethjsUnit.unitMap,\n    toWei: toWei,\n    fromWei: fromWei,\n    padLeft: utils.leftPad,\n    leftPad: utils.leftPad,\n    padRight: utils.rightPad,\n    rightPad: utils.rightPad,\n    toTwosComplement: utils.toTwosComplement,\n    isBloom: utils.isBloom,\n    isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,\n    isContractAddressInBloom: utils.isContractAddressInBloom,\n    isTopic: utils.isTopic,\n    isTopicInBloom: utils.isTopicInBloom,\n    isInBloom: utils.isInBloom,\n    compareBlockNumbers: compareBlockNumbers,\n    toNumber: utils.toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7Ozs7O0NBS0M7QUFDRCxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUN4QixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxlQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQztBQUMxQixJQUFJSSxLQUFLSixtQkFBT0EsQ0FBQztBQUNqQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSUssYUFBYSxTQUFVQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFlBQVk7SUFDckUsMkJBQTJCLEdBQzNCLG9CQUFvQjtJQUNwQixJQUFJLENBQUMsQ0FBQ0osU0FBUyxPQUFPQSxVQUFVLFlBQVksQ0FBRUEsQ0FBQUEsaUJBQWlCSyxLQUFJLEtBQU1MLE1BQU1NLElBQUksRUFBRTtRQUNqRixJQUFJLENBQUMsQ0FBQ04sTUFBTU0sSUFBSSxJQUFJLE9BQU9OLE1BQU1NLElBQUksS0FBSyxZQUFZQyxNQUFNQyxPQUFPLENBQUNSLE1BQU1NLElBQUksR0FBRztZQUM3RU4sTUFBTU0sSUFBSSxHQUFHRyxLQUFLQyxTQUFTLENBQUNWLE1BQU1NLElBQUksRUFBRSxNQUFNO1FBQ2xEO1FBQ0FOLFFBQVFBLE1BQU1XLE9BQU8sR0FBRyxPQUFPWCxNQUFNTSxJQUFJO0lBQzdDO0lBQ0EsSUFBSSxPQUFPTixVQUFVLFVBQVU7UUFDM0JBLFFBQVEsSUFBSUssTUFBTUw7SUFDdEI7SUFDQSxJQUFJLE9BQU9HLGFBQWEsWUFBWTtRQUNoQ0EsU0FBU0gsT0FBT0k7SUFDcEI7SUFDQSxJQUFJLE9BQU9GLFdBQVcsWUFBWTtRQUM5QiwyREFBMkQ7UUFDM0QsaUVBQWlFO1FBQ2pFLElBQUlELFdBQ0MsT0FBT0EsUUFBUVcsU0FBUyxLQUFLLGNBQzFCWCxRQUFR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aEgsTUFBTWdILE9BQU87SUFDdEJDLFVBQVVqSCxNQUFNa0gsUUFBUTtJQUN4QkEsVUFBVWxILE1BQU1rSCxRQUFRO0lBQ3hCQyxrQkFBa0JuSCxNQUFNbUgsZ0JBQWdCO0lBQ3hDQyxTQUFTcEgsTUFBTW9ILE9BQU87SUFDdEJDLDhCQUE4QnJILE1BQU1xSCw0QkFBNEI7SUFDaEVDLDBCQUEwQnRILE1BQU1zSCx3QkFBd0I7SUFDeERDLFNBQVN2SCxNQUFNdUgsT0FBTztJQUN0QkMsZ0JBQWdCeEgsTUFBTXdILGNBQWM7SUFDcENDLFdBQVd6SCxNQUFNeUgsU0FBUztJQUMxQjlDLHFCQUFxQkE7SUFDckIrQyxVQUFVMUgsTUFBTTBILFFBQVE7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9pbmRleC5qcz8xN2E2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSB1dGlscy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG52YXIgZXRoanNVbml0ID0gcmVxdWlyZSgnZXRoanMtdW5pdCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xudmFyIHNvbGlkaXR5U2hhMyA9IHJlcXVpcmUoJy4vc29saWRpdHlTaGEzLmpzJyk7XG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbi8qKlxuICogRmlyZXMgYW4gZXJyb3IgaW4gYW4gZXZlbnQgZW1pdHRlciBhbmQgY2FsbGJhY2sgYW5kIHJldHVybnMgdGhlIGV2ZW50ZW1pdHRlclxuICpcbiAqIEBtZXRob2QgX2ZpcmVFcnJvclxuICogQHBhcmFtIHtPYmplY3R9IGVycm9yIGEgc3RyaW5nLCBhIGVycm9yLCBvciBhbiBvYmplY3Qgd2l0aCB7bWVzc2FnZSwgZGF0YX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbWl0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9uYWxEYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBlbWl0dGVyXG4gKi9cbnZhciBfZmlyZUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlbWl0dGVyLCByZWplY3QsIGNhbGxiYWNrLCBvcHRpb25hbERhdGEpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xuICAgIC8vIGFkZCBkYXRhIGlmIGdpdmVuXG4gICAgaWYgKCEhZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgaWYgKCEhZXJyb3IuZGF0YSAmJiB0eXBlb2YgZXJyb3IuZGF0YSA9PT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShlcnJvci5kYXRhKSkge1xuICAgICAgICAgICAgZXJyb3IuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGVycm9yLmRhdGEsIG51bGwsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyb3IubWVzc2FnZSArIFwiXFxuXCIgKyBlcnJvci5kYXRhO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIG9wdGlvbmFsRGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHByZXNzIHVuY2F0Y2hlZCBlcnJvciBpZiBhbiBlcnJvciBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgIC8vIE9SIHN1cHByZXNzIHVuY2F0Y2hlZCBlcnJvciBpZiBhbiBjYWxsYmFjayBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgIGlmIChlbWl0dGVyICYmXG4gICAgICAgICAgICAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgZW1pdHRlci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWplY3QgbGF0ZXIsIHRvIGJlIGFibGUgdG8gcmV0dXJuIGVtaXR0ZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG4gICAgaWYgKGVtaXR0ZXIgJiYgdHlwZW9mIGVtaXR0ZXIuZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBlbWl0IGxhdGVyLCB0byBiZSBhYmxlIHRvIHJldHVybiBlbWl0dGVyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycm9yLCBvcHRpb25hbERhdGEpO1xuICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuICAgIHJldHVybiBlbWl0dGVyO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCBfanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHJldHVybiB7U3RyaW5nfSBmdWxsIGZ1bmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmICghIWpzb24gJiYgdHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmIGpzb24ubmFtZSAmJiBqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4ganNvbi5uYW1lICsgJygnICsgX2ZsYXR0ZW5UeXBlcyhmYWxzZSwganNvbi5pbnB1dHMpLmpvaW4oJywnKSArICcpJztcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZsYXR0ZW4ganNvbiBhYmkgaW5wdXRzL291dHB1dHMgaW50byBhbiBhcnJheSBvZiB0eXBlLXJlcHJlc2VudGluZy1zdHJpbmdzXG4gKlxuICogQG1ldGhvZCBfZmxhdHRlblR5cGVzXG4gKiBAcGFyYW0ge2Jvb2x9IGluY2x1ZGVUdXBsZVxuICogQHBhcmFtIHtPYmplY3R9IHB1dHNcbiAqIEByZXR1cm4ge0FycmF5fSBwYXJhbWV0ZXJzIGFzIHN0cmluZ3NcbiAqL1xudmFyIF9mbGF0dGVuVHlwZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVR1cGxlLCBwdXRzKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJlbnRlcmVkIF9mbGF0dGVuVHlwZXMuIGlucHV0cy9vdXRwdXRzOiBcIiArIHB1dHMpXG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgcHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtLmNvbXBvbmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZS5zdWJzdHJpbmcoMCwgNSkgIT09ICd0dXBsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudHMgZm91bmQgYnV0IHR5cGUgaXMgbm90IHR1cGxlOyByZXBvcnQgb24gR2l0SHViJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gJyc7XG4gICAgICAgICAgICB2YXIgYXJyYXlCcmFja2V0ID0gcGFyYW0udHlwZS5pbmRleE9mKCdbJyk7XG4gICAgICAgICAgICBpZiAoYXJyYXlCcmFja2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBwYXJhbS50eXBlLnN1YnN0cmluZyhhcnJheUJyYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9mbGF0dGVuVHlwZXMoaW5jbHVkZVR1cGxlLCBwYXJhbS5jb21wb25lbnRzKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzdWx0IHNob3VsZCBoYXZlIHRoaW5nczogXCIgKyByZXN1bHQpXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIGluY2x1ZGVUdXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW5jbHVkZSB0dXBsZSB3b3JkLCBhbmQgaXRzIGFuIGFycmF5LiBqb2luaW5nLi4uOiBcIiArIHJlc3VsdC50eXBlcylcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCd0dXBsZSgnICsgcmVzdWx0LmpvaW4oJywnKSArICcpJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaW5jbHVkZVR1cGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb24ndCBpbmNsdWRlIHR1cGxlLCBidXQgaXRzIGFuIGFycmF5LiBqb2luaW5nLi4uOiBcIiArIHJlc3VsdClcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCcoJyArIHJlc3VsdC5qb2luKCcsJykgKyAnKScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpdHMgYSBzaW5nbGUgdHlwZSB3aXRoaW4gYSB0dXBsZTogXCIgKyByZXN1bHQudHlwZXMpXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgnKCcgKyByZXN1bHQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpdHMgYSB0eXBlIGFuZCBub3QgZGlyZWN0bHkgaW4gYSB0dXBsZTogXCIgKyBwYXJhbS50eXBlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChwYXJhbS50eXBlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlcztcbn07XG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaGV4IHN0cmluZyBieSB0aGUgZ2l2ZW4gYnl0ZXMgc2l6ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgcmFuZG9tSGV4ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gJzB4JyArIHJhbmRvbWJ5dGVzKHNpemUpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGhleFRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIGhleFRvQXNjaWkgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgaWYgKCF1dGlscy5pc0hleFN0cmljdChoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhIHZhbGlkIEhFWCBzdHJpbmcuJyk7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwLCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBpID0gMjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBhc2NpaVRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbnZhciBhc2NpaVRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGV4O1xufTtcbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VW5pdFZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJucyB7Qk59IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFVuaXRWYWx1ZSA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdW5pdCA9IHVuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiAnZXRoZXInO1xuICAgIGlmICghZXRoanNVbml0LnVuaXRNYXBbdW5pdF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHVuaXQgXCInICsgdW5pdCArICdcIiBkb2VzblxcJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KGV0aGpzVW5pdC51bml0TWFwLCBudWxsLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiB1bml0O1xufTtcbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2Ygd2VpIGFuZCBjb252ZXJ0cyBpdCB0byBhbnkgb3RoZXIgZXRoZXIgdW5pdC5cbiAqXG4gKiBQb3NzaWJsZSB1bml0cyBhcmU6XG4gKiAgIFNJIFNob3J0ICAgU0kgRnVsbCAgICAgICAgRWZmaWd5ICAgICAgIE90aGVyXG4gKiAtIGt3ZWkgICAgICAgZmVtdG9ldGhlciAgICAgYmFiYmFnZVxuICogLSBtd2VpICAgICAgIHBpY29ldGhlciAgICAgIGxvdmVsYWNlXG4gKiAtIGd3ZWkgICAgICAgbmFub2V0aGVyICAgICAgc2hhbm5vbiAgICAgIG5hbm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWxsaWV0aGVyICAgICBmaW5uZXkgICAgICAgbWlsbGlcbiAqIC0gZXRoZXIgICAgICAtLSAgICAgICAgICAgICAtLVxuICogLSBrZXRoZXIgICAgICAgICAgICAgICAgICAgIC0tICAgICAgICAgICBncmFuZFxuICogLSBtZXRoZXJcbiAqIC0gZ2V0aGVyXG4gKiAtIHRldGhlclxuICpcbiAqIEBtZXRob2QgZnJvbVdlaVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCB0bywgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJOIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiAqL1xudmFyIGZyb21XZWkgPSBmdW5jdGlvbiAobnVtYmVyLCB1bml0KSB7XG4gICAgdW5pdCA9IGdldFVuaXRWYWx1ZSh1bml0KTtcbiAgICBpZiAoIXV0aWxzLmlzQk4obnVtYmVyKSAmJiAhKHR5cGVvZiBudW1iZXIgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIG51bWJlcnMgYXMgc3RyaW5ncyBvciBCTiBvYmplY3RzIHRvIGF2b2lkIHByZWNpc2lvbiBlcnJvcnMuJyk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5pc0JOKG51bWJlcikgPyBldGhqc1VuaXQuZnJvbVdlaShudW1iZXIsIHVuaXQpIDogZXRoanNVbml0LmZyb21XZWkobnVtYmVyLCB1bml0KS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiBhIHVuaXQgYW5kIGNvbnZlcnRzIGl0IHRvIHdlaS5cbiAqXG4gKiBQb3NzaWJsZSB1bml0cyBhcmU6XG4gKiAgIFNJIFNob3J0ICAgU0kgRnVsbCAgICAgICAgRWZmaWd5ICAgICAgIE90aGVyXG4gKiAtIGt3ZWkgICAgICAgZmVtdG9ldGhlciAgICAgYmFiYmFnZVxuICogLSBtd2VpICAgICAgIHBpY29ldGhlciAgICAgIGxvdmVsYWNlXG4gKiAtIGd3ZWkgICAgICAgbmFub2V0aGVyICAgICAgc2hhbm5vbiAgICAgIG5hbm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWxsaWV0aGVyICAgICBmaW5uZXkgICAgICAgbWlsbGlcbiAqIC0gZXRoZXIgICAgICAtLSAgICAgICAgICAgICAtLVxuICogLSBrZXRoZXIgICAgICAgICAgICAgICAgICAgIC0tICAgICAgICAgICBncmFuZFxuICogLSBtZXRoZXJcbiAqIC0gZ2V0aGVyXG4gKiAtIHRldGhlclxuICpcbiAqIEBtZXRob2QgdG9XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgZnJvbSwgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJOIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiAqL1xudmFyIHRvV2VpID0gZnVuY3Rpb24gKG51bWJlciwgdW5pdCkge1xuICAgIHVuaXQgPSBnZXRVbml0VmFsdWUodW5pdCk7XG4gICAgaWYgKCF1dGlscy5pc0JOKG51bWJlcikgJiYgISh0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBudW1iZXJzIGFzIHN0cmluZ3Mgb3IgQk4gb2JqZWN0cyB0byBhdm9pZCBwcmVjaXNpb24gZXJyb3JzLicpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuaXNCTihudW1iZXIpID8gZXRoanNVbml0LnRvV2VpKG51bWJlciwgdW5pdCkgOiBldGhqc1VuaXQudG9XZWkobnVtYmVyLCB1bml0KS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0byBhIGNoZWNrc3VtIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRvQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gYWRkcmVzcyBcIicgKyBhZGRyZXNzICsgJ1wiIGlzIG5vdCBhIHZhbGlkIEV0aGVyZXVtIGFkZHJlc3MuJyk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBhZGRyZXNzSGFzaCA9IHV0aWxzLnNoYTMoYWRkcmVzcykucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA4IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzO1xufTtcbi8qKlxuICogUmV0dXJucyAtMSBpZiBhPGIsIDEgaWYgYT5iOyAwIGlmIGEgPT0gYi5cbiAqIEZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0eXBlIG9mIGZ1bmN0aW9uLCBzZWVcbiAqIGRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0XG4gKiBCbG9jayB0YWcgYHNhZmVgIGFuZCBgYmxvY2sgbnVtYmVyYCBjb21iaW5hdGlvbiBwYXJhbSBpcyBub3Qgc3VwcG9ydGVkXG4gKiBAbWV0aG9kIGNvbXBhcmVCbG9ja051bWJlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGJcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtMSwgMCwgb3IgMVxuICovXG52YXIgY29tcGFyZUJsb2NrTnVtYmVycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gSW5jcmVhc2luZyBvcmRlcjogKGdlbmVzaXMgPSBlYXJsaWVzdCksIHNhZmUsIChmaW5hbGl6ZWQgfiBsYXRlc3QpLCBwZW5kaW5nXG4gICAgLy8gc2FmZSB2cyBibG9jay1udW0gY2FudCBiZSBjb21wYXJlZCBhcyBibG9jayBudW1iZXIgcHJvdmlkZWQgY2FuIGJlIG9uIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiBzYWZlIHRhZywgdW50aWwgc2FmZSB0YWcgYmxvY2sgbnVtYmVyIGlzIGV4dHJhY3RlZCBhbmQgY29tcGFyZWRcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKFwiZ2VuZXNpc1wiID09PSBhIHx8IFwiZWFybGllc3RcIiA9PT0gYSB8fCAwID09PSBhKSAmJiAoXCJnZW5lc2lzXCIgPT09IGIgfHwgXCJlYXJsaWVzdFwiID09PSBiIHx8IDAgPT09IGIpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImdlbmVzaXNcIiA9PT0gYSB8fCBcImVhcmxpZXN0XCIgPT09IGEgfHwgYSA9PT0gMCkge1xuICAgICAgICAvLyBiICE9PSBhLCB0aHVzIGEgPCBiXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJnZW5lc2lzXCIgPT09IGIgfHwgXCJlYXJsaWVzdFwiID09PSBiIHx8IGIgPT09IDApIHtcbiAgICAgICAgLy8gYiAhPT0gYSwgdGh1cyBhID4gYlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gXCJsYXRlc3RcIiB8fCBhID09PSBcImZpbmFsaXplZFwiKSB7XG4gICAgICAgIGlmIChiID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYiAhPT0gKFwicGVuZGluZ1wiIE9SIFwibGF0ZXN0XCIpLCB0aHVzIGEgPiBiXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBcImxhdGVzdFwiIHx8IGIgPT09IFwiZmluYWxpemVkXCIpIHtcbiAgICAgICAgaWYgKGEgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGIgIT09IChcInBlbmRpbmdcIiBPUiBcImxhdGVzdFwiKSwgdGh1cyBhID4gYlxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIC8vIGIgKD09IE9SIDwpIFwibGF0ZXN0XCIsIHRodXMgYSA+IGJcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gXCJzYWZlXCIgfHwgYiA9PT0gXCJzYWZlXCIpIHtcbiAgICAgICAgLy8gZWl0aGVyIGEgb3IgYiBpcyBcInNhZmVcIiBhbmQgdGhlIG90aGVyIG9uZSBkaWQgbm90IGZhbGwgaW50byBhbnkgb2YgdGhlIGNvbmRpdGlvbnMgYWJvdmUsIHNvIHRoZSBvdGhlciBvbmUgaXMgYSBudW1iZXJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBibkEgPSBuZXcgQk4oYSk7XG4gICAgICAgIGxldCBibkIgPSBuZXcgQk4oYik7XG4gICAgICAgIGlmIChibkEubHQoYm5CKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJuQS5lcShibkIpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIF9maXJlRXJyb3I6IF9maXJlRXJyb3IsXG4gICAgX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZzogX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyxcbiAgICBfZmxhdHRlblR5cGVzOiBfZmxhdHRlblR5cGVzLFxuICAgIC8vIGV4dHJhY3REaXNwbGF5TmFtZTogZXh0cmFjdERpc3BsYXlOYW1lLFxuICAgIC8vIGV4dHJhY3RUeXBlTmFtZTogZXh0cmFjdFR5cGVOYW1lLFxuICAgIHJhbmRvbUhleDogcmFuZG9tSGV4LFxuICAgIEJOOiB1dGlscy5CTixcbiAgICBpc0JOOiB1dGlscy5pc0JOLFxuICAgIGlzQmlnTnVtYmVyOiB1dGlscy5pc0JpZ051bWJlcixcbiAgICBpc0hleDogdXRpbHMuaXNIZXgsXG4gICAgaXNIZXhTdHJpY3Q6IHV0aWxzLmlzSGV4U3RyaWN0LFxuICAgIHNoYTM6IHV0aWxzLnNoYTMsXG4gICAgc2hhM1JhdzogdXRpbHMuc2hhM1JhdyxcbiAgICBrZWNjYWsyNTY6IHV0aWxzLnNoYTMsXG4gICAgc29saWRpdHlTaGEzOiBzb2xpZGl0eVNoYTMuc29saWRpdHlTaGEzLFxuICAgIHNvbGlkaXR5U2hhM1Jhdzogc29saWRpdHlTaGEzLnNvbGlkaXR5U2hhM1JhdyxcbiAgICBlbmNvZGVQYWNrZWQ6IHNvbGlkaXR5U2hhMy5lbmNvZGVQYWNrZWQsXG4gICAgaXNBZGRyZXNzOiB1dGlscy5pc0FkZHJlc3MsXG4gICAgY2hlY2tBZGRyZXNzQ2hlY2tzdW06IHV0aWxzLmNoZWNrQWRkcmVzc0NoZWNrc3VtLFxuICAgIHRvQ2hlY2tzdW1BZGRyZXNzOiB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgICB0b0hleDogdXRpbHMudG9IZXgsXG4gICAgdG9CTjogdXRpbHMudG9CTixcbiAgICBieXRlc1RvSGV4OiB1dGlscy5ieXRlc1RvSGV4LFxuICAgIGhleFRvQnl0ZXM6IHV0aWxzLmhleFRvQnl0ZXMsXG4gICAgaGV4VG9OdW1iZXJTdHJpbmc6IHV0aWxzLmhleFRvTnVtYmVyU3RyaW5nLFxuICAgIGhleFRvTnVtYmVyOiB1dGlscy5oZXhUb051bWJlcixcbiAgICB0b0RlY2ltYWw6IHV0aWxzLmhleFRvTnVtYmVyLFxuICAgIG51bWJlclRvSGV4OiB1dGlscy5udW1iZXJUb0hleCxcbiAgICBmcm9tRGVjaW1hbDogdXRpbHMubnVtYmVyVG9IZXgsXG4gICAgaGV4VG9VdGY4OiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgaGV4VG9TdHJpbmc6IHV0aWxzLmhleFRvVXRmOCxcbiAgICB0b1V0Zjg6IHV0aWxzLmhleFRvVXRmOCxcbiAgICBzdHJpcEhleFByZWZpeDogdXRpbHMuc3RyaXBIZXhQcmVmaXgsXG4gICAgdXRmOFRvSGV4OiB1dGlscy51dGY4VG9IZXgsXG4gICAgc3RyaW5nVG9IZXg6IHV0aWxzLnV0ZjhUb0hleCxcbiAgICBmcm9tVXRmODogdXRpbHMudXRmOFRvSGV4LFxuICAgIGhleFRvQXNjaWk6IGhleFRvQXNjaWksXG4gICAgdG9Bc2NpaTogaGV4VG9Bc2NpaSxcbiAgICBhc2NpaVRvSGV4OiBhc2NpaVRvSGV4LFxuICAgIGZyb21Bc2NpaTogYXNjaWlUb0hleCxcbiAgICB1bml0TWFwOiBldGhqc1VuaXQudW5pdE1hcCxcbiAgICB0b1dlaTogdG9XZWksXG4gICAgZnJvbVdlaTogZnJvbVdlaSxcbiAgICBwYWRMZWZ0OiB1dGlscy5sZWZ0UGFkLFxuICAgIGxlZnRQYWQ6IHV0aWxzLmxlZnRQYWQsXG4gICAgcGFkUmlnaHQ6IHV0aWxzLnJpZ2h0UGFkLFxuICAgIHJpZ2h0UGFkOiB1dGlscy5yaWdodFBhZCxcbiAgICB0b1R3b3NDb21wbGVtZW50OiB1dGlscy50b1R3b3NDb21wbGVtZW50LFxuICAgIGlzQmxvb206IHV0aWxzLmlzQmxvb20sXG4gICAgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTogdXRpbHMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSxcbiAgICBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb206IHV0aWxzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSxcbiAgICBpc1RvcGljOiB1dGlscy5pc1RvcGljLFxuICAgIGlzVG9waWNJbkJsb29tOiB1dGlscy5pc1RvcGljSW5CbG9vbSxcbiAgICBpc0luQmxvb206IHV0aWxzLmlzSW5CbG9vbSxcbiAgICBjb21wYXJlQmxvY2tOdW1iZXJzOiBjb21wYXJlQmxvY2tOdW1iZXJzLFxuICAgIHRvTnVtYmVyOiB1dGlscy50b051bWJlclxufTtcbiJdLCJuYW1lcyI6WyJldGhqc1VuaXQiLCJyZXF1aXJlIiwidXRpbHMiLCJzb2xpZGl0eVNoYTMiLCJyYW5kb21ieXRlcyIsIkJOIiwiX2ZpcmVFcnJvciIsImVycm9yIiwiZW1pdHRlciIsInJlamVjdCIsImNhbGxiYWNrIiwib3B0aW9uYWxEYXRhIiwiRXJyb3IiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJjYXRjaCIsInNldFRpbWVvdXQiLCJlbWl0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyIsImpzb24iLCJuYW1lIiwiaW5kZXhPZiIsIl9mbGF0dGVuVHlwZXMiLCJpbnB1dHMiLCJqb2luIiwiaW5jbHVkZVR1cGxlIiwicHV0cyIsInR5cGVzIiwiZm9yRWFjaCIsInBhcmFtIiwiY29tcG9uZW50cyIsInR5cGUiLCJzdWJzdHJpbmciLCJzdWZmaXgiLCJhcnJheUJyYWNrZXQiLCJyZXN1bHQiLCJwdXNoIiwicmFuZG9tSGV4Iiwic2l6ZSIsInRvU3RyaW5nIiwiaGV4VG9Bc2NpaSIsImhleCIsImlzSGV4U3RyaWN0Iiwic3RyIiwiaSIsImwiLCJjb2RlIiwicGFyc2VJbnQiLCJzbGljZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFzY2lpVG9IZXgiLCJjaGFyQ29kZUF0IiwibiIsImdldFVuaXRWYWx1ZSIsInVuaXQiLCJ0b0xvd2VyQ2FzZSIsInVuaXRNYXAiLCJmcm9tV2VpIiwibnVtYmVyIiwiaXNCTiIsInRvV2VpIiwidG9DaGVja3N1bUFkZHJlc3MiLCJhZGRyZXNzIiwidGVzdCIsInJlcGxhY2UiLCJhZGRyZXNzSGFzaCIsInNoYTMiLCJjaGVja3N1bUFkZHJlc3MiLCJ0b1VwcGVyQ2FzZSIsImNvbXBhcmVCbG9ja051bWJlcnMiLCJhIiwiYiIsInVuZGVmaW5lZCIsImJuQSIsImJuQiIsImx0IiwiZXEiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNCaWdOdW1iZXIiLCJpc0hleCIsInNoYTNSYXciLCJrZWNjYWsyNTYiLCJzb2xpZGl0eVNoYTNSYXciLCJlbmNvZGVQYWNrZWQiLCJpc0FkZHJlc3MiLCJjaGVja0FkZHJlc3NDaGVja3N1bSIsInRvSGV4IiwidG9CTiIsImJ5dGVzVG9IZXgiLCJoZXhUb0J5dGVzIiwiaGV4VG9OdW1iZXJTdHJpbmciLCJoZXhUb051bWJlciIsInRvRGVjaW1hbCIsIm51bWJlclRvSGV4IiwiZnJvbURlY2ltYWwiLCJoZXhUb1V0ZjgiLCJoZXhUb1N0cmluZyIsInRvVXRmOCIsInN0cmlwSGV4UHJlZml4IiwidXRmOFRvSGV4Iiwic3RyaW5nVG9IZXgiLCJmcm9tVXRmOCIsInRvQXNjaWkiLCJmcm9tQXNjaWkiLCJwYWRMZWZ0IiwibGVmdFBhZCIsInBhZFJpZ2h0IiwicmlnaHRQYWQiLCJ0b1R3b3NDb21wbGVtZW50IiwiaXNCbG9vbSIsImlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20iLCJpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20iLCJpc1RvcGljIiwiaXNUb3BpY0luQmxvb20iLCJpc0luQmxvb20iLCJ0b051bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/lib/soliditySha3.js":
/*!*****************************************************!*\
  !*** ./node_modules/web3-utils/lib/soliditySha3.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file soliditySha3.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/lib/utils.js\");\nvar _elementaryName = function(name) {\n    /*jshint maxcomplexity:false */ if (name.startsWith(\"int[\")) {\n        return \"int256\" + name.slice(3);\n    } else if (name === \"int\") {\n        return \"int256\";\n    } else if (name.startsWith(\"uint[\")) {\n        return \"uint256\" + name.slice(4);\n    } else if (name === \"uint\") {\n        return \"uint256\";\n    } else if (name.startsWith(\"fixed[\")) {\n        return \"fixed128x128\" + name.slice(5);\n    } else if (name === \"fixed\") {\n        return \"fixed128x128\";\n    } else if (name.startsWith(\"ufixed[\")) {\n        return \"ufixed128x128\" + name.slice(6);\n    } else if (name === \"ufixed\") {\n        return \"ufixed128x128\";\n    }\n    return name;\n};\n// Parse N from type<N>\nvar _parseTypeN = function(type) {\n    var typesize = /^\\D+(\\d+).*$/.exec(type);\n    return typesize ? parseInt(typesize[1], 10) : null;\n};\n// Parse N from type[<N>]\nvar _parseTypeNArray = function(type) {\n    var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n    return arraySize ? parseInt(arraySize[1], 10) : null;\n};\nvar _parseNumber = function(arg) {\n    var type = typeof arg;\n    if (type === \"string\") {\n        if (utils.isHexStrict(arg)) {\n            return new BN(arg.replace(/0x/i, \"\"), 16);\n        } else {\n            return new BN(arg, 10);\n        }\n    } else if (type === \"number\") {\n        return new BN(arg);\n    } else if (utils.isBigNumber(arg)) {\n        return new BN(arg.toString(10));\n    } else if (utils.isBN(arg)) {\n        return arg;\n    } else {\n        throw new Error(arg + \" is not a number\");\n    }\n};\nvar _solidityPack = function(type, value, arraySize) {\n    /*jshint maxcomplexity:false */ var size, num;\n    type = _elementaryName(type);\n    if (type === \"bytes\") {\n        if (value.replace(/^0x/i, \"\").length % 2 !== 0) {\n            throw new Error(\"Invalid bytes characters \" + value.length);\n        }\n        return value;\n    } else if (type === \"string\") {\n        return utils.utf8ToHex(value);\n    } else if (type === \"bool\") {\n        return value ? \"01\" : \"00\";\n    } else if (type.startsWith(\"address\")) {\n        if (arraySize) {\n            size = 64;\n        } else {\n            size = 40;\n        }\n        if (!utils.isAddress(value)) {\n            throw new Error(value + \" is not a valid address, or the checksum is invalid.\");\n        }\n        return utils.leftPad(value.toLowerCase(), size);\n    }\n    size = _parseTypeN(type);\n    if (type.startsWith(\"bytes\")) {\n        if (!size) {\n            throw new Error(\"bytes[] not yet supported in solidity\");\n        }\n        // must be 32 byte slices when in an array\n        if (arraySize) {\n            size = 32;\n        }\n        if (size < 1 || size > 32 || size < value.replace(/^0x/i, \"\").length / 2) {\n            throw new Error(\"Invalid bytes\" + size + \" for \" + value);\n        }\n        return utils.rightPad(value, size * 2);\n    } else if (type.startsWith(\"uint\")) {\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid uint\" + size + \" size\");\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied uint exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            throw new Error(\"Supplied uint \" + num.toString() + \" is negative\");\n        }\n        return size ? utils.leftPad(num.toString(\"hex\"), size / 8 * 2) : num;\n    } else if (type.startsWith(\"int\")) {\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid int\" + size + \" size\");\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied int exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            return num.toTwos(size).toString(\"hex\");\n        } else {\n            return size ? utils.leftPad(num.toString(\"hex\"), size / 8 * 2) : num;\n        }\n    } else {\n        // FIXME: support all other types\n        throw new Error(\"Unsupported or invalid type: \" + type);\n    }\n};\nvar _processSolidityEncodePackedArgs = function(arg) {\n    /*jshint maxcomplexity:false */ if (Array.isArray(arg)) {\n        throw new Error(\"Autodetection of array types is not supported.\");\n    }\n    var type, value = \"\";\n    var hexArg, arraySize;\n    // if type is given\n    if (!!arg && typeof arg === \"object\" && (arg.hasOwnProperty(\"v\") || arg.hasOwnProperty(\"t\") || arg.hasOwnProperty(\"value\") || arg.hasOwnProperty(\"type\"))) {\n        type = arg.hasOwnProperty(\"t\") ? arg.t : arg.type;\n        value = arg.hasOwnProperty(\"v\") ? arg.v : arg.value;\n    // otherwise try to guess the type\n    } else {\n        type = utils.toHex(arg, true);\n        value = utils.toHex(arg);\n        if (!type.startsWith(\"int\") && !type.startsWith(\"uint\")) {\n            type = \"bytes\";\n        }\n    }\n    if ((type.startsWith(\"int\") || type.startsWith(\"uint\")) && typeof value === \"string\" && !/^(-)?0x/i.test(value)) {\n        value = new BN(value);\n    }\n    // get the array size\n    if (Array.isArray(value)) {\n        arraySize = _parseTypeNArray(type);\n        if (arraySize && value.length !== arraySize) {\n            throw new Error(type + \" is not matching the given array \" + JSON.stringify(value));\n        } else {\n            arraySize = value.length;\n        }\n    }\n    if (Array.isArray(value)) {\n        hexArg = value.map(function(val) {\n            return _solidityPack(type, val, arraySize).toString(\"hex\").replace(\"0x\", \"\");\n        });\n        return hexArg.join(\"\");\n    } else {\n        hexArg = _solidityPack(type, value, arraySize);\n        return hexArg.toString(\"hex\").replace(\"0x\", \"\");\n    }\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */ var soliditySha3 = function() {\n    /*jshint maxcomplexity:false */ var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    // console.log(args, hexArgs);\n    // console.log('0x'+ hexArgs.join(''));\n    return utils.sha3(\"0x\" + hexArgs.join(\"\"));\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256 but does return the hash of value `null` instead of `null`\n *\n * @method soliditySha3Raw\n * @return {Object} the sha3\n */ var soliditySha3Raw = function() {\n    return utils.sha3Raw(\"0x\" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(\"\"));\n};\n/**\n * Encode packed args to hex\n *\n * @method encodePacked\n * @return {String} the hex encoded arguments\n */ var encodePacked = function() {\n    /*jshint maxcomplexity:false */ var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    return \"0x\" + hexArgs.join(\"\").toLowerCase();\n};\nmodule.exports = {\n    soliditySha3: soliditySha3,\n    soliditySha3Raw: soliditySha3Raw,\n    encodePacked: encodePacked\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvc29saWRpdHlTaGEzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7O0NBSUM7QUFDRCxJQUFJQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNqQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxrQkFBa0IsU0FBVUMsSUFBSTtJQUNoQyw2QkFBNkIsR0FDN0IsSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFNBQVM7UUFDekIsT0FBTyxXQUFXRCxLQUFLRSxLQUFLLENBQUM7SUFDakMsT0FDSyxJQUFJRixTQUFTLE9BQU87UUFDckIsT0FBTztJQUNYLE9BQ0ssSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFVBQVU7UUFDL0IsT0FBTyxZQUFZRCxLQUFLRSxLQUFLLENBQUM7SUFDbEMsT0FDSyxJQUFJRixTQUFTLFFBQVE7UUFDdEIsT0FBTztJQUNYLE9BQ0ssSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFdBQVc7UUFDaEMsT0FBTyxpQkFBaUJELEtBQUtFLEtBQUssQ0FBQztJQUN2QyxPQUNLLElBQUlGLFNBQVMsU0FBUztRQUN2QixPQUFPO0lBQ1gsT0FDSyxJQUFJQSxLQUFLQyxVQUFVLENBQUMsWUFBWTtRQUNqQyxPQUFPLGtCQUFrQkQsS0FBS0UsS0FBSyxDQUFDO0lBQ3hDLE9BQ0ssSUFBSUYsU0FBUyxVQUFVO1FBQ3hCLE9BQU87SUFDWDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSx1QkFBdUI7QUFDdkIsSUFBSUcsY0FBYyxTQUFVQyxJQUFJO0lBQzVCLElBQUlDLFdBQVcsZUFBZUMsSUFBSSxDQUFDRjtJQUNuQyxPQUFPQyxXQUFXRSxTQUFTRixRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU07QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekIsSUFBSUcsbUJBQW1CLFNBQVVKLElBQUk7SUFDakMsSUFBSUssWUFBWSxvQkFBb0JILElBQUksQ0FBQ0Y7SUFDekMsT0FBT0ssWUFB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QUlDLFVBQVVKLEtBQUtKLEdBQUcsQ0FBQ1g7SUFDdkIsOEJBQThCO0lBQzlCLHVDQUF1QztJQUN2QyxPQUFPakMsTUFBTXFELElBQUksQ0FBQyxPQUFPRCxRQUFRTixJQUFJLENBQUM7QUFDMUM7QUFDQTs7Ozs7Q0FLQyxHQUNELElBQUlRLGtCQUFrQjtJQUNsQixPQUFPdEQsTUFBTXVELE9BQU8sQ0FBQyxPQUFPckIsTUFBTWUsU0FBUyxDQUFDN0MsS0FBSyxDQUFDOEMsSUFBSSxDQUFDQyxXQUFXUCxHQUFHLENBQUNYLGtDQUFrQ2EsSUFBSSxDQUFDO0FBQ2pIO0FBQ0E7Ozs7O0NBS0MsR0FDRCxJQUFJVSxlQUFlO0lBQ2YsNkJBQTZCLEdBQzdCLElBQUlSLE9BQU9kLE1BQU1lLFNBQVMsQ0FBQzdDLEtBQUssQ0FBQzhDLElBQUksQ0FBQ0M7SUFDdEMsSUFBSUMsVUFBVUosS0FBS0osR0FBRyxDQUFDWDtJQUN2QixPQUFPLE9BQU9tQixRQUFRTixJQUFJLENBQUMsSUFBSWxCLFdBQVc7QUFDOUM7QUFDQTZCLE9BQU9DLE9BQU8sR0FBRztJQUNiWCxjQUFjQTtJQUNkTyxpQkFBaUJBO0lBQ2pCRSxjQUFjQTtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL3NvbGlkaXR5U2hhMy5qcz9kYTgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBzb2xpZGl0eVNoYTMuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBfZWxlbWVudGFyeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdpbnRbJykpIHtcbiAgICAgICAgcmV0dXJuICdpbnQyNTYnICsgbmFtZS5zbGljZSgzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdpbnQyNTYnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VpbnRbJykpIHtcbiAgICAgICAgcmV0dXJuICd1aW50MjU2JyArIG5hbWUuc2xpY2UoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1aW50Jykge1xuICAgICAgICByZXR1cm4gJ3VpbnQyNTYnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkWycpKSB7XG4gICAgICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3VmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuLy8gUGFyc2UgTiBmcm9tIHR5cGU8Tj5cbnZhciBfcGFyc2VUeXBlTiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHR5cGVzaXplID0gL15cXEQrKFxcZCspLiokLy5leGVjKHR5cGUpO1xuICAgIHJldHVybiB0eXBlc2l6ZSA/IHBhcnNlSW50KHR5cGVzaXplWzFdLCAxMCkgOiBudWxsO1xufTtcbi8vIFBhcnNlIE4gZnJvbSB0eXBlWzxOPl1cbnZhciBfcGFyc2VUeXBlTkFycmF5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgYXJyYXlTaXplID0gL15cXEQrXFxkKlxcWyhcXGQrKVxcXSQvLmV4ZWModHlwZSk7XG4gICAgcmV0dXJuIGFycmF5U2l6ZSA/IHBhcnNlSW50KGFycmF5U2l6ZVsxXSwgMTApIDogbnVsbDtcbn07XG52YXIgX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzSGV4U3RyaWN0KGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oYXJnLnJlcGxhY2UoLzB4L2ksICcnKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcsIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IEJOKGFyZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzLmlzQmlnTnVtYmVyKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcudG9TdHJpbmcoMTApKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHMuaXNCTihhcmcpKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJnICsgJyBpcyBub3QgYSBudW1iZXInKTtcbiAgICB9XG59O1xudmFyIF9zb2xpZGl0eVBhY2sgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIGFycmF5U2l6ZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICB2YXIgc2l6ZSwgbnVtO1xuICAgIHR5cGUgPSBfZWxlbWVudGFyeU5hbWUodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnJlcGxhY2UoL14weC9pLCAnJykubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzIGNoYXJhY3RlcnMgJyArIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXRpbHMudXRmOFRvSGV4KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/ICcwMScgOiAnMDAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2FkZHJlc3MnKSkge1xuICAgICAgICBpZiAoYXJyYXlTaXplKSB7XG4gICAgICAgICAgICBzaXplID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gNDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlscy5pc0FkZHJlc3ModmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWUgKyAnIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3MsIG9yIHRoZSBjaGVja3N1bSBpcyBpbnZhbGlkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5sZWZ0UGFkKHZhbHVlLnRvTG93ZXJDYXNlKCksIHNpemUpO1xuICAgIH1cbiAgICBzaXplID0gX3BhcnNlVHlwZU4odHlwZSk7XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnl0ZXNbXSBub3QgeWV0IHN1cHBvcnRlZCBpbiBzb2xpZGl0eScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11c3QgYmUgMzIgYnl0ZSBzbGljZXMgd2hlbiBpbiBhbiBhcnJheVxuICAgICAgICBpZiAoYXJyYXlTaXplKSB7XG4gICAgICAgICAgICBzaXplID0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiAzMiB8fCBzaXplIDwgdmFsdWUucmVwbGFjZSgvXjB4L2ksICcnKS5sZW5ndGggLyAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXMnICsgc2l6ZSArICcgZm9yICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLnJpZ2h0UGFkKHZhbHVlLCBzaXplICogMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdWludCcgKyBzaXplICsgJyBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gX3BhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bS5sdChuZXcgQk4oMCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgJyArIG51bS50b1N0cmluZygpICsgJyBpcyBuZWdhdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplID8gdXRpbHMubGVmdFBhZChudW0udG9TdHJpbmcoJ2hleCcpLCBzaXplIC8gOCAqIDIpIDogbnVtO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50JyArIHNpemUgKyAnIHNpemUnKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBfcGFyc2VOdW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0ubHQobmV3IEJOKDApKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bS50b1R3b3Moc2l6ZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUgPyB1dGlscy5sZWZ0UGFkKG51bS50b1N0cmluZygnaGV4JyksIHNpemUgLyA4ICogMikgOiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IGFsbCBvdGhlciB0eXBlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbn07XG52YXIgX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvZGV0ZWN0aW9uIG9mIGFycmF5IHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciB0eXBlLCB2YWx1ZSA9ICcnO1xuICAgIHZhciBoZXhBcmcsIGFycmF5U2l6ZTtcbiAgICAvLyBpZiB0eXBlIGlzIGdpdmVuXG4gICAgaWYgKCEhYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIChhcmcuaGFzT3duUHJvcGVydHkoJ3YnKSB8fCBhcmcuaGFzT3duUHJvcGVydHkoJ3QnKSB8fCBhcmcuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgYXJnLmhhc093blByb3BlcnR5KCd0eXBlJykpKSB7XG4gICAgICAgIHR5cGUgPSBhcmcuaGFzT3duUHJvcGVydHkoJ3QnKSA/IGFyZy50IDogYXJnLnR5cGU7XG4gICAgICAgIHZhbHVlID0gYXJnLmhhc093blByb3BlcnR5KCd2JykgPyBhcmcudiA6IGFyZy52YWx1ZTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRyeSB0byBndWVzcyB0aGUgdHlwZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLnRvSGV4KGFyZywgdHJ1ZSk7XG4gICAgICAgIHZhbHVlID0gdXRpbHMudG9IZXgoYXJnKTtcbiAgICAgICAgaWYgKCF0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpICYmICF0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdieXRlcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpIHx8IHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEvXigtKT8weC9pLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IEJOKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gZ2V0IHRoZSBhcnJheSBzaXplXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFycmF5U2l6ZSA9IF9wYXJzZVR5cGVOQXJyYXkodHlwZSk7XG4gICAgICAgIGlmIChhcnJheVNpemUgJiYgdmFsdWUubGVuZ3RoICE9PSBhcnJheVNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgJyBpcyBub3QgbWF0Y2hpbmcgdGhlIGdpdmVuIGFycmF5ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlTaXplID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBoZXhBcmcgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zb2xpZGl0eVBhY2sodHlwZSwgdmFsLCBhcnJheVNpemUpLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZXhBcmcuam9pbignJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZXhBcmcgPSBfc29saWRpdHlQYWNrKHR5cGUsIHZhbHVlLCBhcnJheVNpemUpO1xuICAgICAgICByZXR1cm4gaGV4QXJnLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICB9XG59O1xuLyoqXG4gKiBIYXNoZXMgc29saWRpdHkgdmFsdWVzIHRvIGEgc2hhMyBoYXNoIHVzaW5nIGtlY2NhayAyNTZcbiAqXG4gKiBAbWV0aG9kIHNvbGlkaXR5U2hhM1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2hhM1xuICovXG52YXIgc29saWRpdHlTaGEzID0gZnVuY3Rpb24gKCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGhleEFyZ3MgPSBhcmdzLm1hcChfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncyk7XG4gICAgLy8gY29uc29sZS5sb2coYXJncywgaGV4QXJncyk7XG4gICAgLy8gY29uc29sZS5sb2coJzB4JysgaGV4QXJncy5qb2luKCcnKSk7XG4gICAgcmV0dXJuIHV0aWxzLnNoYTMoJzB4JyArIGhleEFyZ3Muam9pbignJykpO1xufTtcbi8qKlxuICogSGFzaGVzIHNvbGlkaXR5IHZhbHVlcyB0byBhIHNoYTMgaGFzaCB1c2luZyBrZWNjYWsgMjU2IGJ1dCBkb2VzIHJldHVybiB0aGUgaGFzaCBvZiB2YWx1ZSBgbnVsbGAgaW5zdGVhZCBvZiBgbnVsbGBcbiAqXG4gKiBAbWV0aG9kIHNvbGlkaXR5U2hhM1Jhd1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2hhM1xuICovXG52YXIgc29saWRpdHlTaGEzUmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5zaGEzUmF3KCcweCcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncykuam9pbignJykpO1xufTtcbi8qKlxuICogRW5jb2RlIHBhY2tlZCBhcmdzIHRvIGhleFxuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFja2VkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBoZXggZW5jb2RlZCBhcmd1bWVudHNcbiAqL1xudmFyIGVuY29kZVBhY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBoZXhBcmdzID0gYXJncy5tYXAoX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MpO1xuICAgIHJldHVybiAnMHgnICsgaGV4QXJncy5qb2luKCcnKS50b0xvd2VyQ2FzZSgpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNvbGlkaXR5U2hhMzogc29saWRpdHlTaGEzLFxuICAgIHNvbGlkaXR5U2hhM1Jhdzogc29saWRpdHlTaGEzUmF3LFxuICAgIGVuY29kZVBhY2tlZDogZW5jb2RlUGFja2VkXG59O1xuIl0sIm5hbWVzIjpbIkJOIiwicmVxdWlyZSIsInV0aWxzIiwiX2VsZW1lbnRhcnlOYW1lIiwibmFtZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsIl9wYXJzZVR5cGVOIiwidHlwZSIsInR5cGVzaXplIiwiZXhlYyIsInBhcnNlSW50IiwiX3BhcnNlVHlwZU5BcnJheSIsImFycmF5U2l6ZSIsIl9wYXJzZU51bWJlciIsImFyZyIsImlzSGV4U3RyaWN0IiwicmVwbGFjZSIsImlzQmlnTnVtYmVyIiwidG9TdHJpbmciLCJpc0JOIiwiRXJyb3IiLCJfc29saWRpdHlQYWNrIiwidmFsdWUiLCJzaXplIiwibnVtIiwibGVuZ3RoIiwidXRmOFRvSGV4IiwiaXNBZGRyZXNzIiwibGVmdFBhZCIsInRvTG93ZXJDYXNlIiwicmlnaHRQYWQiLCJiaXRMZW5ndGgiLCJsdCIsInRvVHdvcyIsIl9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzIiwiQXJyYXkiLCJpc0FycmF5IiwiaGV4QXJnIiwiaGFzT3duUHJvcGVydHkiLCJ0IiwidiIsInRvSGV4IiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYXAiLCJ2YWwiLCJqb2luIiwic29saWRpdHlTaGEzIiwiYXJncyIsInByb3RvdHlwZSIsImNhbGwiLCJhcmd1bWVudHMiLCJoZXhBcmdzIiwic2hhMyIsInNvbGlkaXR5U2hhM1JhdyIsInNoYTNSYXciLCJlbmNvZGVQYWNrZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/lib/soliditySha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/web3-utils/lib/utils.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar numberToBN = __webpack_require__(/*! number-to-bn */ \"(ssr)/./node_modules/number-to-bn/src/index.js\");\nvar utf8 = __webpack_require__(/*! utf8 */ \"(ssr)/./node_modules/utf8/utf8.js\");\nvar ethereumjsUtil = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nvar ethereumBloomFilters = __webpack_require__(/*! ethereum-bloom-filters */ \"(ssr)/./node_modules/ethereum-bloom-filters/dist/index.js\");\nvar { keccak256 } = __webpack_require__(/*! ethereum-cryptography/keccak.js */ \"(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js\");\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */ var isBN = function(object) {\n    return BN.isBN(object);\n};\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */ var isBigNumber = function(object) {\n    return object && object.constructor && object.constructor.name === \"BigNumber\";\n};\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */ var toBN = function(number) {\n    try {\n        return numberToBN.apply(null, arguments);\n    } catch (e) {\n        throw new Error(e + ' Given value: \"' + number + '\"');\n    }\n};\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */ var toTwosComplement = function(number) {\n    return \"0x\" + toBN(number).toTwos(256).toString(16, 64);\n};\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */ var isAddress = function(address) {\n    // check if it has the basic requirements of an address\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n    // If it's ALL lowercase or ALL upppercase\n    } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    // Otherwise check each case\n    } else {\n        return checkAddressChecksum(address);\n    }\n};\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */ var checkAddressChecksum = function(address) {\n    // Check each case\n    address = address.replace(/^0x/i, \"\");\n    var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, \"\");\n    for(var i = 0; i < 40; i++){\n        // the nth letter should be uppercase if the nth digit of casemap is 1\n        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */ var leftPad = function(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === \"number\";\n    string = string.toString(16).replace(/^0x/i, \"\");\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + new Array(padding).join(sign ? sign : \"0\") + string;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */ var rightPad = function(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === \"number\";\n    string = string.toString(16).replace(/^0x/i, \"\");\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + string + new Array(padding).join(sign ? sign : \"0\");\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */ var utf8ToHex = function(str) {\n    str = utf8.encode(str);\n    var hex = \"\";\n    // remove \\u0000 padding from either side\n    str = str.replace(/^(?:\\u0000)*/, \"\");\n    str = str.split(\"\").reverse().join(\"\");\n    str = str.replace(/^(?:\\u0000)*/, \"\");\n    str = str.split(\"\").reverse().join(\"\");\n    for(var i = 0; i < str.length; i++){\n        var code = str.charCodeAt(i);\n        // if (code !== 0) {\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\" + n : n;\n    // }\n    }\n    return \"0x\" + hex;\n};\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */ var hexToUtf8 = function(hex) {\n    if (!isHexStrict(hex)) throw new Error('The parameter \"' + hex + '\" must be a valid HEX string.');\n    var str = \"\";\n    var code = 0;\n    hex = hex.replace(/^0x/i, \"\");\n    // remove 00 padding from either side\n    hex = hex.replace(/^(?:00)*/, \"\");\n    hex = hex.split(\"\").reverse().join(\"\");\n    hex = hex.replace(/^(?:00)*/, \"\");\n    hex = hex.split(\"\").reverse().join(\"\");\n    var l = hex.length;\n    for(var i = 0; i < l; i += 2){\n        code = parseInt(hex.slice(i, i + 2), 16);\n        // if (code !== 0) {\n        str += String.fromCharCode(code);\n    // }\n    }\n    return utf8.decode(str);\n};\n/**\n * Converts value to it's number representation.\n * However, if the value is larger than the maximum safe integer, returns the value as a string.\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */ var hexToNumber = function(value, bigIntOnOverflow = false) {\n    if (!value) {\n        return value;\n    }\n    if (typeof value === \"string\" && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    const n = toBN(value);\n    if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {\n        return BigInt(n);\n    }\n    return n.toNumber();\n};\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */ var hexToNumberString = function(value) {\n    if (!value) return value;\n    if (typeof value === \"string\" && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    return toBN(value).toString(10);\n};\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */ var numberToHex = function(value) {\n    if (value === null || value === undefined) {\n        return value;\n    }\n    if (!isFinite(value) && !isHexStrict(value)) {\n        throw new Error('Given input \"' + value + '\" is not a number.');\n    }\n    var number = toBN(value);\n    var result = number.toString(16);\n    return number.lt(new BN(0)) ? \"-0x\" + result.slice(1) : \"0x\" + result;\n};\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */ var bytesToHex = function(bytes) {\n    for(var hex = [], i = 0; i < bytes.length; i++){\n        /* jshint ignore:start */ hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n    /* jshint ignore:end */ }\n    return \"0x\" + hex.join(\"\");\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */ var hexToBytes = function(hex) {\n    hex = hex.toString(16);\n    if (!isHexStrict(hex)) {\n        throw new Error('Given value \"' + hex + '\" is not a valid hex string.');\n    }\n    hex = hex.replace(/^0x/i, \"\");\n    for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.slice(c, c + 2), 16));\n    return bytes;\n};\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object|Buffer} value\n * @param {Boolean} returnType\n * @return {String}\n */ var toHex = function(value, returnType) {\n    /*jshint maxcomplexity: false */ if (isAddress(value)) {\n        return returnType ? \"address\" : \"0x\" + value.toLowerCase().replace(/^0x/i, \"\");\n    }\n    if (typeof value === \"boolean\") {\n        return returnType ? \"bool\" : value ? \"0x01\" : \"0x00\";\n    }\n    if (Buffer.isBuffer(value)) {\n        return \"0x\" + value.toString(\"hex\");\n    }\n    if (typeof value === \"object\" && !!value && !isBigNumber(value) && !isBN(value)) {\n        return returnType ? \"string\" : utf8ToHex(JSON.stringify(value));\n    }\n    // if its a negative number, pass it through numberToHex\n    if (typeof value === \"string\") {\n        if (value.indexOf(\"-0x\") === 0 || value.indexOf(\"-0X\") === 0) {\n            return returnType ? \"int256\" : numberToHex(value);\n        } else if (value.indexOf(\"0x\") === 0 || value.indexOf(\"0X\") === 0) {\n            return returnType ? \"bytes\" : value;\n        } else if (!isFinite(value)) {\n            return returnType ? \"string\" : utf8ToHex(value);\n        }\n    }\n    return returnType ? value < 0 ? \"int256\" : \"uint256\" : numberToHex(value);\n};\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */ var isHexStrict = function(hex) {\n    return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */ var isHex = function(hex) {\n    return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n};\n/**\n * Remove 0x prefix from string\n *\n * @method stripHexPrefix\n * @param {String} str to be checked\n * @returns {String}\n */ var stripHexPrefix = function(str) {\n    if (str !== 0 && isHex(str)) return str.replace(/^(-)?0x/i, \"$1\");\n    return str;\n};\n/**\n * Returns true if given string is a valid Ethereum block header bloom.\n *\n * @method isBloom\n * @param {String} bloom encoded bloom filter\n * @return {Boolean}\n */ var isBloom = function(bloom) {\n    return ethereumBloomFilters.isBloom(bloom);\n};\n/**\n * Returns true if the ethereum users address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} ethereumAddress encoded bloom filter\n * @param {String} bloom ethereum addresss\n * @return {Boolean}\n */ var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {\n    return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);\n};\n/**\n * Returns true if the contract address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} contractAddress contract addresss\n * @return {Boolean}\n */ var isContractAddressInBloom = function(bloom, contractAddress) {\n    return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);\n};\n/**\n * Returns true if given string is a valid log topic.\n *\n * @method isTopic\n * @param {String} topic encoded topic\n * @return {Boolean}\n */ var isTopic = function(topic) {\n    return ethereumBloomFilters.isTopic(topic);\n};\n/**\n * Returns true if the topic is part of the given bloom\n * note: false positives are possible.\n *\n * @method isTopicInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} topic encoded topic\n * @return {Boolean}\n */ var isTopicInBloom = function(bloom, topic) {\n    return ethereumBloomFilters.isTopicInBloom(bloom, topic);\n};\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n *\n * @method isInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String | Uint8Array} topic encoded value\n * @return {Boolean}\n */ var isInBloom = function(bloom, topic) {\n    return ethereumBloomFilters.isInBloom(bloom, topic);\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */ var SHA3_NULL_S = \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\nvar sha3 = function(value) {\n    if (isBN(value)) {\n        value = value.toString();\n    }\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n        value = ethereumjsUtil.toBuffer(value);\n    } else if (typeof value === \"string\") {\n        // Assume value is an arbitrary string\n        value = Buffer.from(value, \"utf-8\");\n    }\n    var returnValue = ethereumjsUtil.bufferToHex(keccak256(value));\n    if (returnValue === SHA3_NULL_S) {\n        return null;\n    } else {\n        return returnValue;\n    }\n};\n// expose the under the hood keccak256\nsha3._Hash = keccak256;\n/**\n * @method sha3Raw\n *\n * @param value\n *\n * @returns {string}\n */ var sha3Raw = function(value) {\n    value = sha3(value);\n    if (value === null) {\n        return SHA3_NULL_S;\n    }\n    return value;\n};\n/**\n * Auto converts any given value into it's hex representation,\n * then converts hex to number.\n *\n * @method toNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */ var toNumber = function(value, bigIntOnOverflow = false) {\n    return typeof value === \"number\" ? value : hexToNumber(toHex(value), bigIntOnOverflow);\n};\n// 1.x currently accepts 0x... strings, bn.js after update doesn't. it would be a breaking change\nvar BNwrapped = function(value) {\n    // check negative\n    if (typeof value == \"string\" && value.includes(\"0x\")) {\n        const [negative, hexValue] = value.toLocaleLowerCase().startsWith(\"-\") ? [\n            \"-\",\n            value.slice(3)\n        ] : [\n            \"\",\n            value.slice(2)\n        ];\n        return new BN(negative + hexValue, 16);\n    } else {\n        return new BN(value);\n    }\n};\nObject.setPrototypeOf(BNwrapped, BN);\nObject.setPrototypeOf(BNwrapped.prototype, BN.prototype);\nmodule.exports = {\n    BN: BNwrapped,\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    isAddress: isAddress,\n    isBloom: isBloom,\n    isUserEthereumAddressInBloom: isUserEthereumAddressInBloom,\n    isContractAddressInBloom: isContractAddressInBloom,\n    isTopic: isTopic,\n    isTopicInBloom: isTopicInBloom,\n    isInBloom: isInBloom,\n    checkAddressChecksum: checkAddressChecksum,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    toHex: toHex,\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    isHex: isHex,\n    isHexStrict: isHexStrict,\n    stripHexPrefix: stripHexPrefix,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    toTwosComplement: toTwosComplement,\n    sha3: sha3,\n    sha3Raw: sha3Raw,\n    toNumber: toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7Ozs7Q0FJQztBQUNELElBQUlBLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ2pCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUksdUJBQXVCSixtQkFBT0EsQ0FBQztBQUNuQyxJQUFJLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM1Qjs7Ozs7O0NBTUMsR0FDRCxJQUFJTSxPQUFPLFNBQVVDLE1BQU07SUFDdkIsT0FBT1IsR0FBR08sSUFBSSxDQUFDQztBQUNuQjtBQUNBOzs7Ozs7Q0FNQyxHQUNELElBQUlDLGNBQWMsU0FBVUQsTUFBTTtJQUM5QixPQUFPQSxVQUFVQSxPQUFPRSxXQUFXLElBQUlGLE9BQU9FLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZFO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsSUFBSUMsT0FBTyxTQUFVQyxNQUFNO0lBQ3ZCLElBQUk7UUFDQSxPQUFPWCxXQUFXWSxLQUFLLENBQUMsTUFBTUM7SUFDbEMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sTUFBTSxJQUFJQyxNQUFNRCxJQUFJLG9CQUFvQkgsU0FBUztJQUNyRDtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsSUFBSUssbUJBQW1CLFNBQVVMLE1BQU07SUFDbkMsT0FBTyxPQUFPRCxLQUFLQyxRQUFRTSxNQUFNLENBQUMsS0FBS0MsUUFBUSxDQUFDLElBQUk7QUFDeEQ7QUFDQTs7Ozs7O0NBTUMsR0FDRCxJQUFJQyxZQUFZLFNBQVVDLE9BQU87SUFDN0IsdURBQXVEO0lBQ3ZELElBQUksQ0FBQyx1QkFBdUJDLElBQUksQ0FBQ0QsVUFBVTtRQUN2QyxPQUFPO0lBQ1AsMENBQTBDO0lBQzlDLE9BQ0ss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My11dGlscy9saWIvdXRpbHMuanM/MDg2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgdXRpbHMuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBudW1iZXJUb0JOID0gcmVxdWlyZSgnbnVtYmVyLXRvLWJuJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcbnZhciBldGhlcmV1bWpzVXRpbCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3V0aWwnKTtcbnZhciBldGhlcmV1bUJsb29tRmlsdGVycyA9IHJlcXVpcmUoJ2V0aGVyZXVtLWJsb29tLWZpbHRlcnMnKTtcbnZhciB7IGtlY2NhazI1NiB9ID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcycpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIEJOLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQk5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0JOID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBCTi5pc0JOKG9iamVjdCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIEJpZ051bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0JpZ051bWJlclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yICYmIG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmlnTnVtYmVyJztcbn07XG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYW4gQk5cbiAqXG4gKiBAbWV0aG9kIHRvQk5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyLCBzdHJpbmcsIEhFWCBzdHJpbmcgb3IgQk5cbiAqIEByZXR1cm4ge0JOfSBCTlxuICovXG52YXIgdG9CTiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CTi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSArICcgR2l2ZW4gdmFsdWU6IFwiJyArIG51bWJlciArICdcIicpO1xuICAgIH1cbn07XG4vKipcbiAqIFRha2VzIGFuZCBpbnB1dCB0cmFuc2Zvcm1zIGl0IGludG8gQk4gYW5kIGlmIGl0IGlzIG5lZ2F0aXZlIHZhbHVlLCBpbnRvIHR3bydzIGNvbXBsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIHRvVHdvc0NvbXBsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b1R3b3NDb21wbGVtZW50ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiAnMHgnICsgdG9CTihudW1iZXIpLnRvVHdvcygyNTYpLnRvU3RyaW5nKDE2LCA2NCk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc0FkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQgaGFzIHRoZSBiYXNpYyByZXF1aXJlbWVudHMgb2YgYW4gYWRkcmVzc1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgaXQncyBBTEwgbG93ZXJjYXNlIG9yIEFMTCB1cHBwZXJjYXNlXG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKDB4fDBYKT9bMC05YS1mXXs0MH0kLy50ZXN0KGFkZHJlc3MpIHx8IC9eKDB4fDBYKT9bMC05QS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgZWFjaCBjYXNlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzQ2hlY2tzdW0oYWRkcmVzcyk7XG4gICAgfVxufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBjaGVja0FkZHJlc3NDaGVja3N1bVxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgY2hlY2tBZGRyZXNzQ2hlY2tzdW0gPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIENoZWNrIGVhY2ggY2FzZVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBudGggbGV0dGVyIHNob3VsZCBiZSB1cHBlcmNhc2UgaWYgdGhlIG50aCBkaWdpdCBvZiBjYXNlbWFwIGlzIDFcbiAgICAgICAgaWYgKChwYXJzZUludChhZGRyZXNzSGFzaFtpXSwgMTYpID4gNyAmJiBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCkgIT09IGFkZHJlc3NbaV0pIHx8IChwYXJzZUludChhZGRyZXNzSGFzaFtpXSwgMTYpIDw9IDcgJiYgYWRkcmVzc1tpXS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgbGVmdFBhZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciBsZWZ0UGFkID0gZnVuY3Rpb24gKHN0cmluZywgY2hhcnMsIHNpZ24pIHtcbiAgICB2YXIgaGFzUHJlZml4ID0gL14weC9pLnRlc3Qoc3RyaW5nKSB8fCB0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJztcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIHBhZGRpbmcgPSAoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA+PSAwKSA/IGNoYXJzIC0gc3RyaW5nLmxlbmd0aCArIDEgOiAwO1xuICAgIHJldHVybiAoaGFzUHJlZml4ID8gJzB4JyA6ICcnKSArIG5ldyBBcnJheShwYWRkaW5nKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpICsgc3RyaW5nO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcmlnaHRQYWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gYmUgcGFkZGVkXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhcnMgdGhhdCByZXN1bHQgc3RyaW5nIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbiwgYnkgZGVmYXVsdCAwXG4gKiBAcmV0dXJucyB7U3RyaW5nfSByaWdodCBhbGlnbmVkIHN0cmluZ1xuICovXG52YXIgcmlnaHRQYWQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHZhciBoYXNQcmVmaXggPSAvXjB4L2kudGVzdChzdHJpbmcpIHx8IHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInO1xuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygxNikucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgcGFkZGluZyA9IChjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxID49IDApID8gY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA6IDA7XG4gICAgcmV0dXJuIChoYXNQcmVmaXggPyAnMHgnIDogJycpICsgc3RyaW5nICsgKG5ldyBBcnJheShwYWRkaW5nKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCB1dGY4VG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xudmFyIHV0ZjhUb0hleCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBzdHIgPSB1dGY4LmVuY29kZShzdHIpO1xuICAgIHZhciBoZXggPSBcIlwiO1xuICAgIC8vIHJlbW92ZSBcXHUwMDAwIHBhZGRpbmcgZnJvbSBlaXRoZXIgc2lkZVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKD86XFx1MDAwMCkqLywgJycpO1xuICAgIHN0ciA9IHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXig/OlxcdTAwMDApKi8sICcnKTtcbiAgICBzdHIgPSBzdHIuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGhleFRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgaGV4VG9VdGY4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGlmICghaXNIZXhTdHJpY3QoaGV4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFyYW1ldGVyIFwiJyArIGhleCArICdcIiBtdXN0IGJlIGEgdmFsaWQgSEVYIHN0cmluZy4nKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgY29kZSA9IDA7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgLy8gcmVtb3ZlIDAwIHBhZGRpbmcgZnJvbSBlaXRoZXIgc2lkZVxuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eKD86MDApKi8sICcnKTtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14oPzowMCkqLywgJycpO1xuICAgIGhleCA9IGhleC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICB2YXIgbCA9IGhleC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgY29kZSA9IHBhcnNlSW50KGhleC5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICAgICAgLy8gaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0ZjguZGVjb2RlKHN0cik7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIG51bWJlciByZXByZXNlbnRhdGlvbi5cbiAqIEhvd2V2ZXIsIGlmIHRoZSB2YWx1ZSBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSBzYWZlIGludGVnZXIsIHJldHVybnMgdGhlIHZhbHVlIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgaGV4VG9OdW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYmlnSW50T25PdmVyZmxvdyAtIGlmIHRydWUsIHJldHVybiB0aGUgaGV4IHZhbHVlIGluIGNhc2Ugb2Ygb3ZlcmZsb3dcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gKi9cbnZhciBoZXhUb051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgYmlnSW50T25PdmVyZmxvdyA9IGZhbHNlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFpc0hleFN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLicpO1xuICAgIH1cbiAgICBjb25zdCBuID0gdG9CTih2YWx1ZSk7XG4gICAgaWYgKGJpZ0ludE9uT3ZlcmZsb3cgJiYgKG4gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBuIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQobik7XG4gICAgfVxuICAgIHJldHVybiBuLnRvTnVtYmVyKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gaW4gc3RyaW5nXG4gKlxuICogQG1ldGhvZCBoZXhUb051bWJlclN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgaGV4VG9OdW1iZXJTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzSGV4U3RyaWN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b0JOKHZhbHVlKS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgbnVtYmVyVG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIG51bWJlclRvSGV4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUodmFsdWUpICYmICFpc0hleFN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiBpbnB1dCBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgfVxuICAgIHZhciBudW1iZXIgPSB0b0JOKHZhbHVlKTtcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gbnVtYmVyLmx0KG5ldyBCTigwKSkgPyAnLTB4JyArIHJlc3VsdC5zbGljZSgxKSA6ICcweCcgKyByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAqXG4gKiBOb3RlOiBJbXBsZW1lbnRhdGlvbiBmcm9tIGNyeXB0by1qc1xuICpcbiAqIEBtZXRob2QgYnl0ZXNUb0hleFxuICogQHBhcmFtIHtBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGhleCBzdHJpbmdcbiAqL1xudmFyIGJ5dGVzVG9IZXggPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICBmb3IgKHZhciBoZXggPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgIH1cbiAgICByZXR1cm4gJzB4JyArIGhleC5qb2luKFwiXCIpO1xufTtcbi8qKlxuICogQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gKlxuICogTm90ZTogSW1wbGVtZW50YXRpb24gZnJvbSBjcnlwdG8tanNcbiAqXG4gKiBAbWV0aG9kIGhleFRvQnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgYnl0ZSBhcnJheVxuICovXG52YXIgaGV4VG9CeXRlcyA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgIGlmICghaXNIZXhTdHJpY3QoaGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIFwiJyArIGhleCArICdcIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLicpO1xuICAgIH1cbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc2xpY2UoYywgYyArIDIpLCAxNikpO1xuICAgIHJldHVybiBieXRlcztcbn07XG4vKipcbiAqIEF1dG8gY29udmVydHMgYW55IGdpdmVuIHZhbHVlIGludG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24uXG4gKlxuICogQW5kIGV2ZW4gc3RyaW5naWZ5cyBvYmplY3RzIGJlZm9yZS5cbiAqXG4gKiBAbWV0aG9kIHRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk58T2JqZWN0fEJ1ZmZlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuVHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9IZXggPSBmdW5jdGlvbiAodmFsdWUsIHJldHVyblR5cGUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiBmYWxzZSAqL1xuICAgIGlmIChpc0FkZHJlc3ModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2FkZHJlc3MnIDogJzB4JyArIHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2Jvb2wnIDogdmFsdWUgPyAnMHgwMScgOiAnMHgwMCc7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgdmFsdWUudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICFpc0JpZ051bWJlcih2YWx1ZSkgJiYgIWlzQk4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ3N0cmluZycgOiB1dGY4VG9IZXgoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gaWYgaXRzIGEgbmVnYXRpdmUgbnVtYmVyLCBwYXNzIGl0IHRocm91Z2ggbnVtYmVyVG9IZXhcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignLTB4JykgPT09IDAgfHwgdmFsdWUuaW5kZXhPZignLTBYJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2ludDI1NicgOiBudW1iZXJUb0hleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMHgnKSA9PT0gMCB8fCB2YWx1ZS5pbmRleE9mKCcwWCcpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdieXRlcycgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdzdHJpbmcnIDogdXRmOFRvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICh2YWx1ZSA8IDAgPyAnaW50MjU2JyA6ICd1aW50MjU2JykgOiBudW1iZXJUb0hleCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBzdHJpbmcgaXMgSEVYLCByZXF1aXJlcyBhIDB4IGluIGZyb250XG4gKlxuICogQG1ldGhvZCBpc0hleFN0cmljdFxuICogQHBhcmFtIHtTdHJpbmd9IGhleCB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSGV4U3RyaWN0ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIHJldHVybiAoKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZXggPT09ICdudW1iZXInKSAmJiAvXigtKT8weFswLTlhLWZdKiQvaS50ZXN0KGhleCkpO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgc3RyaW5nIGlzIEhFWFxuICpcbiAqIEBtZXRob2QgaXNIZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnZhciBpc0hleCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICByZXR1cm4gKCh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaGV4ID09PSAnbnVtYmVyJykgJiYgL14oLTB4fDB4KT9bMC05YS1mXSokL2kudGVzdChoZXgpKTtcbn07XG4vKipcbiAqIFJlbW92ZSAweCBwcmVmaXggZnJvbSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIHN0cmlwSGV4UHJlZml4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbnZhciBzdHJpcEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyICE9PSAwICYmIGlzSGV4KHN0cikpXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXigtKT8weC9pLCAnJDEnKTtcbiAgICByZXR1cm4gc3RyO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIEV0aGVyZXVtIGJsb2NrIGhlYWRlciBibG9vbS5cbiAqXG4gKiBAbWV0aG9kIGlzQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmxvb20gPSBmdW5jdGlvbiAoYmxvb20pIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNCbG9vbShibG9vbSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGV0aGVyZXVtIHVzZXJzIGFkZHJlc3MgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gZXRoZXJldW1BZGRyZXNzIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvb20gZXRoZXJldW0gYWRkcmVzc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCBldGhlcmV1bUFkZHJlc3MpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbShibG9vbSwgZXRoZXJldW1BZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJhY3QgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBjb250cmFjdCBhZGRyZXNzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSA9IGZ1bmN0aW9uIChibG9vbSwgY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbShibG9vbSwgY29udHJhY3RBZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBsb2cgdG9waWMuXG4gKlxuICogQG1ldGhvZCBpc1RvcGljXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgZW5jb2RlZCB0b3BpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVG9waWMgPSBmdW5jdGlvbiAodG9waWMpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNUb3BpYyh0b3BpYyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRvcGljIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgaXNUb3BpY0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIGVuY29kZWQgdG9waWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1RvcGljSW5CbG9vbSA9IGZ1bmN0aW9uIChibG9vbSwgdG9waWMpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNUb3BpY0luQmxvb20oYmxvb20sIHRvcGljKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmcgfCBVaW50OEFycmF5fSB0b3BpYyBlbmNvZGVkIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCB0b3BpYykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc0luQmxvb20oYmxvb20sIHRvcGljKTtcbn07XG4vKipcbiAqIEhhc2hlcyB2YWx1ZXMgdG8gYSBzaGEzIGhhc2ggdXNpbmcga2VjY2FrIDI1NlxuICpcbiAqIFRvIGhhc2ggYSBIRVggc3RyaW5nIHRoZSBoZXggbXVzdCBoYXZlIDB4IGluIGZyb250LlxuICpcbiAqIEBtZXRob2Qgc2hhM1xuICogQHJldHVybiB7U3RyaW5nfSB0aGUgc2hhMyBzdHJpbmdcbiAqL1xudmFyIFNIQTNfTlVMTF9TID0gJzB4YzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG52YXIgc2hhMyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChpc0JOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmljdCh2YWx1ZSkgJiYgL14weC9pLnRlc3QoKHZhbHVlKS50b1N0cmluZygpKSkge1xuICAgICAgICB2YWx1ZSA9IGV0aGVyZXVtanNVdGlsLnRvQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYW4gYXJiaXRyYXJ5IHN0cmluZ1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmLTgnKTtcbiAgICB9XG4gICAgdmFyIHJldHVyblZhbHVlID0gZXRoZXJldW1qc1V0aWwuYnVmZmVyVG9IZXgoa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBTSEEzX05VTExfUykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG59O1xuLy8gZXhwb3NlIHRoZSB1bmRlciB0aGUgaG9vZCBrZWNjYWsyNTZcbnNoYTMuX0hhc2ggPSBrZWNjYWsyNTY7XG4vKipcbiAqIEBtZXRob2Qgc2hhM1Jhd1xuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBzaGEzUmF3ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBzaGEzKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFNIQTNfTlVMTF9TO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBBdXRvIGNvbnZlcnRzIGFueSBnaXZlbiB2YWx1ZSBpbnRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uLFxuICogdGhlbiBjb252ZXJ0cyBoZXggdG8gbnVtYmVyLlxuICpcbiAqIEBtZXRob2QgdG9OdW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYmlnSW50T25PdmVyZmxvdyAtIGlmIHRydWUsIHJldHVybiB0aGUgaGV4IHZhbHVlIGluIGNhc2Ugb2Ygb3ZlcmZsb3dcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gKi9cbnZhciB0b051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgYmlnSW50T25PdmVyZmxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IGhleFRvTnVtYmVyKHRvSGV4KHZhbHVlKSwgYmlnSW50T25PdmVyZmxvdyk7XG59O1xuLy8gMS54IGN1cnJlbnRseSBhY2NlcHRzIDB4Li4uIHN0cmluZ3MsIGJuLmpzIGFmdGVyIHVwZGF0ZSBkb2Vzbid0LiBpdCB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZVxudmFyIEJOd3JhcHBlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIG5lZ2F0aXZlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIHZhbHVlLmluY2x1ZGVzKFwiMHhcIikpIHtcbiAgICAgICAgY29uc3QgW25lZ2F0aXZlLCBoZXhWYWx1ZV0gPSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJy0nKSA/IFtcIi1cIiwgdmFsdWUuc2xpY2UoMyldIDogW1wiXCIsIHZhbHVlLnNsaWNlKDIpXTtcbiAgICAgICAgcmV0dXJuIG5ldyBCTihuZWdhdGl2ZSArIGhleFZhbHVlLCAxNik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJOKHZhbHVlKTtcbiAgICB9XG59O1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJOd3JhcHBlZCwgQk4pO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJOd3JhcHBlZC5wcm90b3R5cGUsIEJOLnByb3RvdHlwZSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCTjogQk53cmFwcGVkLFxuICAgIGlzQk46IGlzQk4sXG4gICAgaXNCaWdOdW1iZXI6IGlzQmlnTnVtYmVyLFxuICAgIHRvQk46IHRvQk4sXG4gICAgaXNBZGRyZXNzOiBpc0FkZHJlc3MsXG4gICAgaXNCbG9vbTogaXNCbG9vbSxcbiAgICBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tOiBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tLFxuICAgIGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbTogaXNDb250cmFjdEFkZHJlc3NJbkJsb29tLFxuICAgIGlzVG9waWM6IGlzVG9waWMsXG4gICAgaXNUb3BpY0luQmxvb206IGlzVG9waWNJbkJsb29tLFxuICAgIGlzSW5CbG9vbTogaXNJbkJsb29tLFxuICAgIGNoZWNrQWRkcmVzc0NoZWNrc3VtOiBjaGVja0FkZHJlc3NDaGVja3N1bSxcbiAgICB1dGY4VG9IZXg6IHV0ZjhUb0hleCxcbiAgICBoZXhUb1V0Zjg6IGhleFRvVXRmOCxcbiAgICBoZXhUb051bWJlcjogaGV4VG9OdW1iZXIsXG4gICAgaGV4VG9OdW1iZXJTdHJpbmc6IGhleFRvTnVtYmVyU3RyaW5nLFxuICAgIG51bWJlclRvSGV4OiBudW1iZXJUb0hleCxcbiAgICB0b0hleDogdG9IZXgsXG4gICAgaGV4VG9CeXRlczogaGV4VG9CeXRlcyxcbiAgICBieXRlc1RvSGV4OiBieXRlc1RvSGV4LFxuICAgIGlzSGV4OiBpc0hleCxcbiAgICBpc0hleFN0cmljdDogaXNIZXhTdHJpY3QsXG4gICAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICAgIGxlZnRQYWQ6IGxlZnRQYWQsXG4gICAgcmlnaHRQYWQ6IHJpZ2h0UGFkLFxuICAgIHRvVHdvc0NvbXBsZW1lbnQ6IHRvVHdvc0NvbXBsZW1lbnQsXG4gICAgc2hhMzogc2hhMyxcbiAgICBzaGEzUmF3OiBzaGEzUmF3LFxuICAgIHRvTnVtYmVyOiB0b051bWJlclxufTtcbiJdLCJuYW1lcyI6WyJCTiIsInJlcXVpcmUiLCJudW1iZXJUb0JOIiwidXRmOCIsImV0aGVyZXVtanNVdGlsIiwiZXRoZXJldW1CbG9vbUZpbHRlcnMiLCJrZWNjYWsyNTYiLCJpc0JOIiwib2JqZWN0IiwiaXNCaWdOdW1iZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ0b0JOIiwibnVtYmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJlIiwiRXJyb3IiLCJ0b1R3b3NDb21wbGVtZW50IiwidG9Ud29zIiwidG9TdHJpbmciLCJpc0FkZHJlc3MiLCJhZGRyZXNzIiwidGVzdCIsImNoZWNrQWRkcmVzc0NoZWNrc3VtIiwicmVwbGFjZSIsImFkZHJlc3NIYXNoIiwic2hhMyIsInRvTG93ZXJDYXNlIiwiaSIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJsZWZ0UGFkIiwic3RyaW5nIiwiY2hhcnMiLCJzaWduIiwiaGFzUHJlZml4IiwicGFkZGluZyIsImxlbmd0aCIsIkFycmF5Iiwiam9pbiIsInJpZ2h0UGFkIiwidXRmOFRvSGV4Iiwic3RyIiwiZW5jb2RlIiwiaGV4Iiwic3BsaXQiLCJyZXZlcnNlIiwiY29kZSIsImNoYXJDb2RlQXQiLCJuIiwiaGV4VG9VdGY4IiwiaXNIZXhTdHJpY3QiLCJsIiwic2xpY2UiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkZWNvZGUiLCJoZXhUb051bWJlciIsInZhbHVlIiwiYmlnSW50T25PdmVyZmxvdyIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiQmlnSW50IiwidG9OdW1iZXIiLCJoZXhUb051bWJlclN0cmluZyIsIm51bWJlclRvSGV4IiwidW5kZWZpbmVkIiwiaXNGaW5pdGUiLCJyZXN1bHQiLCJsdCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsInB1c2giLCJoZXhUb0J5dGVzIiwiYyIsInRvSGV4IiwicmV0dXJuVHlwZSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImluZGV4T2YiLCJpc0hleCIsInN0cmlwSGV4UHJlZml4IiwiaXNCbG9vbSIsImJsb29tIiwiaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSIsImV0aGVyZXVtQWRkcmVzcyIsImlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSIsImNvbnRyYWN0QWRkcmVzcyIsImlzVG9waWMiLCJ0b3BpYyIsImlzVG9waWNJbkJsb29tIiwiaXNJbkJsb29tIiwiU0hBM19OVUxMX1MiLCJ0b0J1ZmZlciIsImZyb20iLCJyZXR1cm5WYWx1ZSIsImJ1ZmZlclRvSGV4IiwiX0hhc2giLCJzaGEzUmF3IiwiQk53cmFwcGVkIiwiaW5jbHVkZXMiLCJuZWdhdGl2ZSIsImhleFZhbHVlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js":
/*!***********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\nexports[\"default\"] = assert; //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsWUFBWSxHQUFHQSxhQUFhLEdBQUdBLFlBQVksR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdEcsU0FBU08sT0FBT0MsQ0FBQztJQUNiLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixNQUFNQSxJQUFJLEdBQ2hDLE1BQU0sSUFBSUcsTUFBTSxDQUFDLHdCQUF3QixFQUFFSCxFQUFFLENBQUM7QUFDdEQ7QUFDQVIsY0FBYyxHQUFHTztBQUNqQixTQUFTRCxLQUFLTSxDQUFDO0lBQ1gsSUFBSSxPQUFPQSxNQUFNLFdBQ2IsTUFBTSxJQUFJRCxNQUFNLENBQUMsc0JBQXNCLEVBQUVDLEVBQUUsQ0FBQztBQUNwRDtBQUNBWixZQUFZLEdBQUdNO0FBQ2YsU0FBU0QsTUFBTU8sQ0FBQyxFQUFFLEdBQUdDLE9BQU87SUFDeEIsSUFBSSxDQUFFRCxDQUFBQSxhQUFhRSxVQUFTLEdBQ3hCLE1BQU0sSUFBSUgsTUFBTTtJQUNwQixJQUFJRSxRQUFRRSxNQUFNLEdBQUcsS0FBSyxDQUFDRixRQUFRRyxRQUFRLENBQUNKLEVBQUVHLE1BQU0sR0FDaEQsTUFBTSxJQUFJSixNQUFNLENBQUMsOEJBQThCLEVBQUVFLFFBQVEsZ0JBQWdCLEVBQUVELEVBQUVHLE1BQU0sQ0FBQyxDQUFDO0FBQzdGO0FBQ0FmLGFBQWEsR0FBR0s7QUFDaEIsU0FBU0QsS0FBS0EsSUFBSTtJQUNkLElBQUksT0FBT0EsU0FBUyxjQUFjLE9BQU9BLEtBQUthLE1BQU0sS0FBSyxZQUNyRCxNQUFNLElBQUlOLE1BQU07SUFDcEJKLE9BQU9ILEtBQUtjLFNBQVM7SUFDckJYLE9BQU9ILEtBQUtlLFFBQVE7QUFDeEI7QUFDQW5CLFlBQVksR0FBR0k7QUFDZixTQUFTRCxPQUFPaUIsUUFBUSxFQUFFQyxnQkFBZ0IsSUFBSTtJQUMxQyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSVgsTUFBTTtJQUNwQixJQUFJVSxpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJWixNQUFNO0FBQ3hCO0FBQ0FYLGNBQWMsR0FBR0c7QUFDakIsU0FBU0QsT0FBT3NCLEdBQUcsRUFBRUosUUFBUTtJQUN6QmYsTUFBTW1CO0lBQ04sTUFBTUMsTUFBTUwsU0FBU0YsU0FBUztJQUM5QixJQUFJTSxJQUFJVCxNQUFNLEdBQUdVLEtBQUs7UUFDbEIsTUFBTSxJQUFJZCxNQUFNLENBQUMsc0RBQXNELEVBQUVjLElBQUksQ0FBQztJQUNsRjtBQUNKO0FBQ0F6QixjQUFjLEdBQUdFO0FBQ2pCLE1BQU13QixTQUFTO0lBQ1huQjtJQUNBRDtJQUNBRDtJQUNBRDtJQUNBRDtJQUNBRDtBQUNKO0FBQ0FGLGtCQUFlLEdBQUcwQixRQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanM/MTZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm91dHB1dCIsImV4aXN0cyIsImhhc2giLCJieXRlcyIsImJvb2wiLCJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYiIsImxlbmd0aHMiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJjcmVhdGUiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwib3V0IiwibWluIiwiYXNzZXJ0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js":
/*!********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.add = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nexports.split = split;\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l)=>l;\nconst rotr32L = (h, l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig: exports.toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUNyRSxNQUFNTSxhQUFhQyxPQUFPLEtBQUssS0FBSztBQUNwQyxNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLCtFQUErRTtBQUMvRSxTQUFTRixRQUFRSSxDQUFDLEVBQUVDLEtBQUssS0FBSztJQUMxQixJQUFJQSxJQUNBLE9BQU87UUFBRUMsR0FBR0MsT0FBT0gsSUFBSUg7UUFBYU8sR0FBR0QsT0FBTyxLQUFNSixPQUFRRjtJQUFZO0lBQzVFLE9BQU87UUFBRUssR0FBR0MsT0FBTyxLQUFNSixPQUFRRixjQUFjO1FBQUdPLEdBQUdELE9BQU9ILElBQUlILGNBQWM7SUFBRTtBQUNwRjtBQUNBTixlQUFlLEdBQUdLO0FBQ2xCLFNBQVNELE1BQU1VLEdBQUcsRUFBRUosS0FBSyxLQUFLO0lBQzFCLElBQUlLLEtBQUssSUFBSUMsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFJQyxLQUFLLElBQUlGLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFBSztRQUNqQyxNQUFNLEVBQUVSLENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdSLFFBQVFTLEdBQUcsQ0FBQ0ssRUFBRSxFQUFFVDtRQUNqQyxDQUFDSyxFQUFFLENBQUNJLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDUjtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDRTtRQUFJRztLQUFHO0FBQ25CO0FBQ0FsQixhQUFhLEdBQUdJO0FBQ2hCLE1BQU1ELFFBQVEsQ0FBQ1EsR0FBR0Us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cENpQjtJQUFPRTtJQUNQQztJQUFRQztJQUFRQztJQUFRQztJQUN4QkM7SUFBU0M7SUFDVEM7SUFBUUM7SUFBUUM7SUFBUUM7SUFDeEI5QjtJQUFLaUM7SUFBT0U7SUFBT0c7SUFBT0U7SUFBT0k7SUFBT0Y7QUFDNUM7QUFDQTVDLGtCQUFlLEdBQUdnRCxLQUNsQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanM/N2IyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkID0gZXhwb3J0cy50b0JpZyA9IGV4cG9ydHMuc3BsaXQgPSBleHBvcnRzLmZyb21CaWcgPSB2b2lkIDA7XG5jb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbi8vIFJlbW92aW5nIFwiZXhwb3J0XCIgaGFzIDUlIHBlcmYgcGVuYWx0eSAtXy1cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnOiBleHBvcnRzLnRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkIiwidG9CaWciLCJzcGxpdCIsImZyb21CaWciLCJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsIm4iLCJsZSIsImgiLCJOdW1iZXIiLCJsIiwibHN0IiwiQWgiLCJVaW50MzJBcnJheSIsImxlbmd0aCIsIkFsIiwiaSIsInNoclNIIiwicyIsInNoclNMIiwicm90clNIIiwicm90clNMIiwicm90ckJIIiwicm90ckJMIiwicm90cjMySCIsInJvdHIzMkwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJCaCIsIkJsIiwiYWRkM0wiLCJDbCIsImFkZDNIIiwibG93IiwiQ2giLCJhZGQ0TCIsIkRsIiwiYWRkNEgiLCJEaCIsImFkZDVMIiwiRWwiLCJhZGQ1SCIsIkVoIiwidTY0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixvRkFBb0Y7QUFDcEYsNEJBQTRCO0FBQzVCLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2IsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaENKLGNBQWMsR0FBR0csTUFBTSxPQUFPQSxPQUFPLFlBQVksZUFBZUEsS0FBS0EsR0FBR0UsU0FBUyxHQUFHQyxXQUNwRixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanM/MGZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4vLyBUaGUgZmlsZSB3aWxsIHRocm93IG9uIG5vZGUuanMgMTQgYW5kIGVhcmxpZXIuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBuYyA9IHJlcXVpcmUoXCJub2RlOmNyeXB0b1wiKTtcbmV4cG9ydHMuY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuYyA/IG5jLndlYmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3J5cHRvIiwibmMiLCJyZXF1aXJlIiwid2ViY3J5cHRvIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js":
/*!********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\");\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        _assert_js_1.default.number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        _assert_js_1.default.exists(this, false);\n        _assert_js_1.default.bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        _assert_js_1.default.number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        _assert_js_1.default.output(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ exports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ exports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUM5TyxNQUFNYyxlQUFlQyxtQkFBT0EsQ0FBQywyRkFBYztBQUMzQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxxRkFBVztBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyx1RkFBWTtBQUN2QywyQ0FBMkM7QUFDM0MsTUFBTSxDQUFDRyxTQUFTQyxXQUFXQyxXQUFXLEdBQUc7SUFBQyxFQUFFO0lBQUUsRUFBRTtJQUFFLEVBQUU7Q0FBQztBQUNyRCxNQUFNQyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssU0FBU0wsT0FBTztBQUN0QixJQUFLLElBQUlNLFFBQVEsR0FBR0MsSUFBSU4sS0FBS08sSUFBSSxHQUFHQyxJQUFJLEdBQUdILFFBQVEsSUFBSUEsUUFBUztJQUM1RCxLQUFLO0lBQ0wsQ0FBQ0UsR0FBR0MsRUFBRSxHQUFHO1FBQUNBO1FBQUksS0FBSUQsSUFBSSxJQUFJQyxDQUFBQSxJQUFLO0tBQUU7SUFDakNiLFFBQVFjLElBQUksQ0FBQyxJQUFLLEtBQUlELElBQUlELENBQUFBO0lBQzFCLGFBQWE7SUFDYlgsVUFBVWEsSUFBSSxDQUFDLENBQUdKLFFBQVEsS0FBTUEsQ0FB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L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanM/ZmQzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBleHBvcnRzLnNoYWtlMTI4ID0gZXhwb3J0cy5rZWNjYWtfNTEyID0gZXhwb3J0cy5rZWNjYWtfMzg0ID0gZXhwb3J0cy5rZWNjYWtfMjU2ID0gZXhwb3J0cy5rZWNjYWtfMjI0ID0gZXhwb3J0cy5zaGEzXzUxMiA9IGV4cG9ydHMuc2hhM18zODQgPSBleHBvcnRzLnNoYTNfMjU2ID0gZXhwb3J0cy5zaGEzXzIyNCA9IGV4cG9ydHMuS2VjY2FrID0gZXhwb3J0cy5rZWNjYWtQID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IF91NjRfanNfMSA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSBfdTY0X2pzXzEuZGVmYXVsdC5zcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gX3U2NF9qc18xLmRlZmF1bHQucm90bEJIKGgsIGwsIHMpIDogX3U2NF9qc18xLmRlZmF1bHQucm90bFNIKGgsIGwsIHMpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gX3U2NF9qc18xLmRlZmF1bHQucm90bEJMKGgsIGwsIHMpIDogX3U2NF9qc18xLmRlZmF1bHQucm90bFNMKGgsIGwsIHMpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5mdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnRzLmtlY2Nha1AgPSBrZWNjYWtQO1xuY2xhc3MgS2VjY2FrIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm51bWJlcihvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9ICgwLCB1dGlsc19qc18xLnUzMikodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5LZWNjYWsgPSBLZWNjYWs7XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG5leHBvcnRzLnNoYTNfMjI0ID0gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5zaGEzXzI1NiA9IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5zaGEzXzM4NCA9IGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0cy5zaGEzXzUxMiA9IGdlbigweDA2LCA3MiwgNTEyIC8gOCk7XG5leHBvcnRzLmtlY2Nha18yMjQgPSBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5rZWNjYWtfMjU2ID0gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnRzLmtlY2Nha18zODQgPSBnZW4oMHgwMSwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzUxMiA9IGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc19qc18xLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKSgob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbmV4cG9ydHMuc2hha2UxMjggPSBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYWtlMjU2Iiwic2hha2UxMjgiLCJrZWNjYWtfNTEyIiwia2VjY2FrXzM4NCIsImtlY2Nha18yNTYiLCJrZWNjYWtfMjI0Iiwic2hhM181MTIiLCJzaGEzXzM4NCIsInNoYTNfMjU2Iiwic2hhM18yMjQiLCJLZWNjYWsiLCJrZWNjYWtQIiwiX2Fzc2VydF9qc18xIiwicmVxdWlyZSIsIl91NjRfanNfMSIsInV0aWxzX2pzXzEiLCJTSEEzX1BJIiwiU0hBM19ST1RMIiwiX1NIQTNfSU9UQSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl83biIsIl8yNTZuIiwiXzB4NzFuIiwicm91bmQiLCJSIiwieCIsInkiLCJwdXNoIiwidCIsImoiLCJTSEEzX0lPVEFfSCIsIlNIQTNfSU9UQV9MIiwiZGVmYXVsdCIsInNwbGl0Iiwicm90bEgiLCJoIiwibCIsInMiLCJyb3RsQkgiLCJyb3RsU0giLCJyb3RsTCIsInJvdGxCTCIsInJvdGxTTCIsInJvdW5kcyIsIkIiLCJVaW50MzJBcnJheSIsImlkeDEiLCJpZHgwIiwiQjAiLCJCMSIsIlRoIiwiVGwiLCJjdXJIIiwiY3VyTCIsInNoaWZ0IiwiUEkiLCJmaWxsIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJzdWZmaXgiLCJvdXRwdXRMZW4iLCJlbmFibGVYT0YiLCJwb3MiLCJwb3NPdXQiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsIm51bWJlciIsIkVycm9yIiwic3RhdGUiLCJVaW50OEFycmF5Iiwic3RhdGUzMiIsInUzMiIsImtlY2NhayIsInVwZGF0ZSIsImRhdGEiLCJleGlzdHMiLCJ0b0J5dGVzIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnl0ZXMiLCJidWZmZXJPdXQiLCJzZXQiLCJzdWJhcnJheSIsInhvZkludG8iLCJ4b2YiLCJkaWdlc3RJbnRvIiwib3V0cHV0IiwiZGVzdHJveSIsImRpZ2VzdCIsIl9jbG9uZUludG8iLCJ0byIsImdlbiIsIndyYXBDb25zdHJ1Y3RvciIsImdlblNoYWtlIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJvcHRzIiwiZGtMZW4iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js\");\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!exports.isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n}\nexports.randomBytes = randomBytes; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9FQUFvRSxHQUNwRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsWUFBWSxHQUFHQSxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHQSxrQkFBa0IsR0FBR0EsV0FBVyxHQUFHQSxVQUFVLEdBQUcsS0FBSztBQUM1WCxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDhEQUE4RDtBQUM5RCxNQUFNb0IsV0FBV0MsbUJBQU9BLENBQUMsc0dBQXNCO0FBQy9DLE1BQU1DLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsK0JBQStCO0FBQy9CLE1BQU1MLEtBQUssQ0FBQ00sTUFBUSxJQUFJRCxXQUFXQyxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVTtBQUM3RTVCLFVBQVUsR0FBR21CO0FBQ2IsTUFBTUQsTUFBTSxDQUFDTyxNQUFRLElBQUlJLFlBQVlKLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRyxLQUFLQyxLQUFLLENBQUNOLElBQUlHLFVBQVUsR0FBRztBQUM3RjVCLFdBQVcsR0FBR2tCO0FBQ2QscUJBQXFCO0FBQ3JCLE1BQU1ELGFBQWEsQ0FBQ1EsTUFBUSxJQUFJTyxTQUFTUCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVTtBQUNuRjVCLGtCQUFrQixH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QWUsQ0FBQyxJQUFJeEUsV0FBV3NFO0lBQzFEO0lBQ0EsTUFBTSxJQUFJM0QsTUFBTTtBQUNwQjtBQUNBbkMsbUJBQW1CLEdBQUdFLGFBQ3RCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtdGFpbHdpbmRjc3MtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanM/Yjc2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5jb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLnU4ID0gdTg7XG5jb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5leHBvcnRzLnUzMiA9IHUzMjtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gd3JhcENvbnN0cnVjdG9yO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM7XG5mdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cztcbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJhbmRvbUJ5dGVzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBDb25zdHJ1Y3RvciIsImNoZWNrT3B0cyIsIkhhc2giLCJjb25jYXRCeXRlcyIsInRvQnl0ZXMiLCJ1dGY4VG9CeXRlcyIsImFzeW5jTG9vcCIsIm5leHRUaWNrIiwiaGV4VG9CeXRlcyIsImJ5dGVzVG9IZXgiLCJpc0xFIiwicm90ciIsImNyZWF0ZVZpZXciLCJ1MzIiLCJ1OCIsImNyeXB0b18xIiwicmVxdWlyZSIsInU4YSIsImEiLCJVaW50OEFycmF5IiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsIkRhdGFWaWV3Iiwid29yZCIsInNoaWZ0IiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInYiLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzIiwiaGV4IiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImRhdGEiLCJhcnJheXMiLCJyIiwicmVkdWNlIiwic3VtIiwicGFkIiwiZm9yRWFjaCIsInNldCIsImNsb25lIiwiX2Nsb25lSW50byIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90b3R5cGUiLCJjYWxsIiwiY29uc3RydWN0b3IiLCJkZWZhdWx0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJtZXJnZWQiLCJhc3NpZ24iLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJjcmVhdGUiLCJieXRlc0xlbmd0aCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js":
/*!******************************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js\");\nexports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);\nexports.keccak256 = (()=>{\n    const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);\n    k.create = sha3_1.keccak_256.create;\n    return k;\n})();\nexports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);\nexports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNyRixNQUFNTSxTQUFTQyxtQkFBT0EsQ0FBQyw4RkFBb0I7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsK0ZBQVk7QUFDdkNQLGlCQUFpQixHQUFHLENBQUMsR0FBR1EsV0FBV0MsUUFBUSxFQUFFSCxPQUFPSSxVQUFVO0FBQzlEVixpQkFBaUIsR0FBRyxDQUFDO0lBQ2pCLE1BQU1XLElBQUksQ0FBQyxHQUFHSCxXQUFXQyxRQUFRLEVBQUVILE9BQU9NLFVBQVU7SUFDcERELEVBQUVFLE1BQU0sR0FBR1AsT0FBT00sVUFBVSxDQUFDQyxNQUFNO0lBQ25DLE9BQU9GO0FBQ1g7QUFDQVgsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHUSxXQUFXQyxRQUFRLEVBQUVILE9BQU9RLFVBQVU7QUFDOURkLGlCQUFpQixHQUFHLENBQUMsR0FBR1EsV0FBV0MsUUFBUSxFQUFFSCxPQUFPUyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC10YWlsd2luZGNzcy1hcHAvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcz82NzA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5rZWNjYWs1MTIgPSBleHBvcnRzLmtlY2NhazM4NCA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5rZWNjYWsyMjQgPSB2b2lkIDA7XG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuZXhwb3J0cy5rZWNjYWsyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwSGFzaCkoc2hhM18xLmtlY2Nha18yMjQpO1xuZXhwb3J0cy5rZWNjYWsyNTYgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGsgPSAoMCwgdXRpbHNfanNfMS53cmFwSGFzaCkoc2hhM18xLmtlY2Nha18yNTYpO1xuICAgIGsuY3JlYXRlID0gc2hhM18xLmtlY2Nha18yNTYuY3JlYXRlO1xuICAgIHJldHVybiBrO1xufSkoKTtcbmV4cG9ydHMua2VjY2FrMzg0ID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMzg0KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfNTEyKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImtlY2NhazUxMiIsImtlY2NhazM4NCIsImtlY2NhazI1NiIsImtlY2NhazIyNCIsInNoYTNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwid3JhcEhhc2giLCJrZWNjYWtfMjI0IiwiayIsImtlY2Nha18yNTYiLCJjcmVhdGUiLCJrZWNjYWtfMzg0Iiwia2VjY2FrXzUxMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\nconst _assert_1 = __importDefault(__webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js\"));\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\");\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\nvar utils_2 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"bytesToHex\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.bytesToHex;\n    }\n}));\nObject.defineProperty(exports, \"toHex\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.bytesToHex;\n    }\n}));\nObject.defineProperty(exports, \"concatBytes\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.concatBytes;\n    }\n}));\nObject.defineProperty(exports, \"createView\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.createView;\n    }\n}));\nObject.defineProperty(exports, \"utf8ToBytes\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.utf8ToBytes;\n    }\n}));\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexports.bytesToUtf8 = bytesToUtf8;\nfunction hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return (0, utils_1.hexToBytes)(sliced);\n}\nexports.hexToBytes = hexToBytes;\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equalsBytes = equalsBytes;\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg)=>{\n        _assert_1.default.bytes(msg);\n        return hash(msg);\n    };\n}\nexports.wrapHash = wrapHash;\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nexports.crypto = (()=>{\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire =  true && typeof module.require === \"function\" && module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsYUFBYSxHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDM1AsTUFBTWMsWUFBWW5CLGdCQUFnQm9CLG1CQUFPQSxDQUFDLG9HQUF1QjtBQUNqRSxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxnR0FBcUI7QUFDN0MsTUFBTUYsYUFBYUMsVUFBVUcsT0FBTyxDQUFDQyxJQUFJO0FBQ3pDbEIsa0JBQWtCLEdBQUdhO0FBQ3JCLE1BQU1ELGNBQWNFLFVBQVVHLE9BQU8sQ0FBQ0UsS0FBSztBQUMzQ25CLG1CQUFtQixHQUFHWTtBQUN0QixJQUFJUSxVQUFVTCxtQkFBT0EsQ0FBQyxnR0FBcUI7QUFDM0NqQiw4Q0FBNkM7SUFBRXVCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFULFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSGIseUNBQXdDO0lBQUV1QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRVCxVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUdiLCtDQUE4QztJQUFFdUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUVgsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JIWCw4Q0FBNkM7SUFBRXVCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFaLFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSFYsK0NBQThDO0lBQUV1QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRYixXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckgsMkNBQTJDO0FBQzNDLFNBQVNELFlBQVlpQixJQUFJO0lBQ3JCLElBQUksQ0FBRUEsQ0FBQUEsZ0JBQWdCQyxVQUFTLEdBQUk7UUFDL0IsTUFBTSxJQUFJQyxVQUFVLENBQUMscUNBQXFDLEVBQUUsT0FBT0YsS0FBSyxDQUFDO0lBQzdFO0lBQ0EsT0FBTyxJQUFJRyxjQUFjQyxNQUFNLENBQUNKO0FBQ3BDO0FBQ0F2QixtQkFBbUIsR0FBR007QUFDdEIsU0FBU0QsV0FBV2tCLElBQUk7SUFDcEIsTUFBTUssU0FBU0wsS0FBS00sVUFBVSxDQUFDLFFBQVFOLEtBQUtPLFNBQVMsQ0FBQyxLQUFLUDtJQUMzRCxPQUFPLENBQUMsR0FBR1AsUUFBUVgsVUFBVSxFQUFFdUI7QUFDbkM7QUFDQTVCLGtCQUFrQixHQUFHSztBQUNyQiw2Q0FBNkM7QUFDN0MsU0FBU0QsWUFBWTJCLENBQUMsRUFBRUMsQ0FBQztJQUNyQixJQUFJRCxFQUFFRSxNQUFNLEtBQUtELEVBQUVDLE1BQU0sRUFBRTtRQUN2QixPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsRUFBRUUsTUFBTSxFQUFFQyxJQUFLO1FBQy9CLElBQUlILENBQUMsQ0FBQ0csRUFBRSxLQUFLRixDQUFDLENBQUNFLEVBQUUsRUFBRTtZQUNmLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0FsQyxtQkFBbUIsR0FBR0k7QUFDdEIsaUJBQWlCO0FBQ2pCLFNBQVNELFNBQVNnQyxJQUFJO0lBQ2xCLE9BQU8sQ0FBQ0M7UUFDSnRCLFVBQVVHLE9BQU8sQ0FBQ0UsS0FBSyxDQUFDaUI7UUFDeEIsT0FBT0QsS0FBS0M7SUFDaEI7QUFDSjtBQUNBcEMsZ0JBQWdCLEdBQUdHO0FBQ25CLDRFQUE0RTtBQUM1RUgsY0FBYyxHQUFHLENBQUM7SUFDZCxNQUFNcUMsWUFBWSxPQUFPQyxlQUFlLFlBQVksWUFBWUEsYUFBYUEsV0FBV3BDLE1BQU0sR0FBR3FDO0lBQ2pHLE1BQU1DLGNBQWMsS0FBNkIsSUFDN0MsT0FBT0MsT0FBTzFCLE9BQU8sS0FBSyxjQUMxQjBCLE9BQU8xQixPQUFPLENBQUMyQixJQUFJLENBQUNEO0lBQ3hCLE9BQU87UUFDSEUsTUFBTUgsZUFBZSxDQUFDSCxZQUFZRyxZQUFZLFlBQVlEO1FBQzFESyxLQUFLUDtJQUNUO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLXRhaWx3aW5kY3NzLWFwcC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvdXRpbHMuanM/NGJjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gZXhwb3J0cy53cmFwSGFzaCA9IGV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9VdGY4ID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvSGV4ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGV4cG9ydHMuYXNzZXJ0Qm9vbCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9fYXNzZXJ0XCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGFzc2VydEJvb2wgPSBfYXNzZXJ0XzEuZGVmYXVsdC5ib29sO1xuZXhwb3J0cy5hc3NlcnRCb29sID0gYXNzZXJ0Qm9vbDtcbmNvbnN0IGFzc2VydEJ5dGVzID0gX2Fzc2VydF8xLmRlZmF1bHQuYnl0ZXM7XG5leHBvcnRzLmFzc2VydEJ5dGVzID0gYXNzZXJ0Qnl0ZXM7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnl0ZXNUb0hleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5ieXRlc1RvSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmNvbmNhdEJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVmlld1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5jcmVhdGVWaWV3OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXRmOFRvQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIudXRmOFRvQnl0ZXM7IH0gfSk7XG4vLyBidWYudG9TdHJpbmcoJ3V0ZjgnKSAtPiBieXRlc1RvVXRmOChidWYpXG5mdW5jdGlvbiBieXRlc1RvVXRmOChkYXRhKSB7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ5dGVzVG9VdGY4IGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5ieXRlc1RvVXRmOCA9IGJ5dGVzVG9VdGY4O1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhkYXRhKSB7XG4gICAgY29uc3Qgc2xpY2VkID0gZGF0YS5zdGFydHNXaXRoKFwiMHhcIikgPyBkYXRhLnN1YnN0cmluZygyKSA6IGRhdGE7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHNsaWNlZCk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gYnVmLmVxdWFscyhidWYyKSAtPiBlcXVhbHNCeXRlcyhidWYsIGJ1ZjIpXG5mdW5jdGlvbiBlcXVhbHNCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5lcXVhbHNCeXRlcyA9IGVxdWFsc0J5dGVzO1xuLy8gSW50ZXJuYWwgdXRpbHNcbmZ1bmN0aW9uIHdyYXBIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4gKG1zZykgPT4ge1xuICAgICAgICBfYXNzZXJ0XzEuZGVmYXVsdC5ieXRlcyhtc2cpO1xuICAgICAgICByZXR1cm4gaGFzaChtc2cpO1xuICAgIH07XG59XG5leHBvcnRzLndyYXBIYXNoID0gd3JhcEhhc2g7XG4vLyBUT0RPKHYzKTogc3dpdGNoIGF3YXkgZnJvbSBub2RlIGNyeXB0bywgcmVtb3ZlIHRoaXMgdW5uZWNlc3NhcnkgdmFyaWFibGUuXG5leHBvcnRzLmNyeXB0byA9ICgoKSA9PiB7XG4gICAgY29uc3Qgd2ViQ3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiYgXCJjcnlwdG9cIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZVJlcXVpcmUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBtb2R1bGUucmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIG1vZHVsZS5yZXF1aXJlLmJpbmQobW9kdWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlUmVxdWlyZSAmJiAhd2ViQ3J5cHRvID8gbm9kZVJlcXVpcmUoXCJjcnlwdG9cIikgOiB1bmRlZmluZWQsXG4gICAgICAgIHdlYjogd2ViQ3J5cHRvXG4gICAgfTtcbn0pKCk7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3J5cHRvIiwid3JhcEhhc2giLCJlcXVhbHNCeXRlcyIsImhleFRvQnl0ZXMiLCJieXRlc1RvVXRmOCIsInV0ZjhUb0J5dGVzIiwiY3JlYXRlVmlldyIsImNvbmNhdEJ5dGVzIiwidG9IZXgiLCJieXRlc1RvSGV4IiwiYXNzZXJ0Qnl0ZXMiLCJhc3NlcnRCb29sIiwiX2Fzc2VydF8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJkZWZhdWx0IiwiYm9vbCIsImJ5dGVzIiwidXRpbHNfMiIsImVudW1lcmFibGUiLCJnZXQiLCJkYXRhIiwiVWludDhBcnJheSIsIlR5cGVFcnJvciIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwic2xpY2VkIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImEiLCJiIiwibGVuZ3RoIiwiaSIsImhhc2giLCJtc2ciLCJ3ZWJDcnlwdG8iLCJnbG9iYWxUaGlzIiwidW5kZWZpbmVkIiwibm9kZVJlcXVpcmUiLCJtb2R1bGUiLCJiaW5kIiwibm9kZSIsIndlYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js\n");

/***/ })

};
;